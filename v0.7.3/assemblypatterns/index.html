<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Assembly Patterns · GradientRobustMultiPhysics.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GradientRobustMultiPhysics.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Problem Description</span><ul><li><a class="tocitem" href="../pdedescription/">PDE Description</a></li><li><a class="tocitem" href="../pdeoperators/">PDE Operators</a></li><li><a class="tocitem" href="../functionoperators/">Function Operators</a></li><li><a class="tocitem" href="../userdata/">User Data and Actions</a></li><li><a class="tocitem" href="../boundarydata/">Boundary Data</a></li><li><a class="tocitem" href="../globalconstraints/">Global Constraints</a></li><li><a class="tocitem" href="../pdeprototypes/">PDE Prototypes</a></li></ul></li><li><span class="tocitem">Discretisation</span><ul><li><a class="tocitem" href="../meshing/">Meshing</a></li><li><a class="tocitem" href="../fems/">Implemented Finite Elements</a></li><li><a class="tocitem" href="../fespace/">Finite Element Spaces and Arrays</a></li><li><a class="tocitem" href="../interpolations/">Finite Element Interpolations</a></li></ul></li><li><span class="tocitem">Solving</span><ul><li><a class="tocitem" href="../pdesolvers/">Fixed-Time Solvers</a></li><li><a class="tocitem" href="../timecontrolsolver/">Time-Dependent Solvers</a></li></ul></li><li><span class="tocitem">Postprocessing</span><ul><li><a class="tocitem" href="../itemintegrators/">Item Integrators</a></li><li><a class="tocitem" href="../pointevaluators/">Point Evaluators</a></li><li><a class="tocitem" href="../viewers/">Viewers</a></li><li><a class="tocitem" href="../export/">Data Export</a></li></ul></li><li><span class="tocitem">Low-Level Structures</span><ul><li><a class="tocitem" href="../quadrature/">Quadrature</a></li><li class="is-active"><a class="tocitem" href>Assembly Patterns</a></li><li><a class="tocitem" href="../febasisevaluators/">FE Basis Evaluators</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples_intro/">About the examples</a></li><li><a class="tocitem" href="../examples/Example101_Bestapproximation1D/">101 : L2-Bestapproximation 1D</a></li><li><a class="tocitem" href="../examples/Example201_PoissonProblem2D/">201 : Poisson-Problem 2D</a></li><li><a class="tocitem" href="../examples/Example202_LinearElasticity2D/">202 : Linear Elasticity</a></li><li><a class="tocitem" href="../examples/Example203_ReactionConvectionDiffusion2D/">203 : Reaction-Convection-Diffusion-Problem 2D</a></li><li><a class="tocitem" href="../examples/Example204_PoissonLshapeAdaptive2D/">204 : Poisson L-shape Adaptive Mesh Refinement</a></li><li><a class="tocitem" href="../examples/Example205_PlanarLatticeFlow2D/">205 : Planar Lattice Flow 2D</a></li><li><a class="tocitem" href="../examples/Example206_PressureRobustness2D/">206 : Pressure-robustness 2D</a></li><li><a class="tocitem" href="../examples/Example207_StokesTransient2D/">207 : Stokes Transient 2D</a></li><li><a class="tocitem" href="../examples/Example208_FlowTransport2D/">208 : Flow + Transport 2D</a></li><li><a class="tocitem" href="../examples/Example209_FaceLagrangeMultiplier2D/">209 : Lagrange Multiplier on Faces</a></li><li><a class="tocitem" href="../examples/Example210_NonlinearPoisson2D/">210 : Nonlinear Poisson Problem 2D</a></li><li><a class="tocitem" href="../examples/Example211_NonlinearElasticityBimetal2D/">211 : Nonlinear Elasticity Bimetal 2D</a></li><li><a class="tocitem" href="../examples/Example212_NonlinearPoissonTransient2D/">212 : Nonlinear Poisson Transient 2D</a></li><li><a class="tocitem" href="../examples/Example214_TwoNonlinearCoupled2D/">214 : Two nonlinearly coupled PDEs (2D)</a></li><li><a class="tocitem" href="../examples/Example215_ObstacleProblem2D/">215 : Obstacle Problem 2D</a></li><li><a class="tocitem" href="../examples/Example221_StokesIterated2D/">221 : Stokes iterated penalty method 2D</a></li><li><a class="tocitem" href="../examples/Example222_NavierStokesAnderson2D/">222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration</a></li><li><a class="tocitem" href="../examples/Example223_NaturalConvection2D/">223 : Natural Convection 2D</a></li><li><a class="tocitem" href="../examples/Example224_FlowAroundCylinder2D/">224 : Flow around a cylinder 2D</a></li><li><a class="tocitem" href="../examples/Example225_CompressibleStokes2D/">225 : Compressible Stokes 2D</a></li><li><a class="tocitem" href="../examples/Example230_StokesHdivDG2D/">230 : Stokes Hdiv-DG 2D</a></li><li><a class="tocitem" href="../examples/Example231_StokesHdivP1RT/">231 : Stokes <span>$(P1 \oplus RT0) \times P0$</span></a></li><li><a class="tocitem" href="../examples/Example240_TransientFlowAroundCylinder2D/">240 : Transient Flow around a cylinder 2D</a></li><li><a class="tocitem" href="../examples/Example301_Poisson3D/">301 : Poisson-Problem 3D</a></li><li><a class="tocitem" href="../examples/Example302_BestapproximationHdiv3D/">302 : Bestapproximation Hdiv 3D</a></li><li><a class="tocitem" href="../examples/ExampleA01_RationalMassMatrix/">A01 : Rational Mass Matrix</a></li><li><a class="tocitem" href="../examples/ExampleA02_CommutingInterpolators2D/">A02 : Commuting Interpolators 2D</a></li><li><a class="tocitem" href="../examples/ExampleA03_CommutingInterpolators3D/">A03 : Commuting Interpolators 3D</a></li><li><a class="tocitem" href="../examples/ExampleA04_CustomLinearSolver/">A04 : Custom Linear Solvers</a></li><li><a class="tocitem" href="../examples/ExampleA05_DiffEQ/">A05 : Comparison with DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples/ExampleA06_LocalEquilibratedFluxes2D/">A06 : Local Equilibrated Fluxes 2D</a></li><li><a class="tocitem" href="../examples/ExampleA07_InterpolationBetweenMeshes/">A07 : Interpolation Between Meshes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Low-Level Structures</a></li><li class="is-active"><a href>Assembly Patterns</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Assembly Patterns</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/master/docs/src/assemblypatterns.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Assembly-Patterns"><a class="docs-heading-anchor" href="#Assembly-Patterns">Assembly Patterns</a><a id="Assembly-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly-Patterns" title="Permalink"></a></h1><p>The definition and assembly of an operator is essentially based on Assembly Patterns and a <a href="../pdeoperators/#Assembly-Type">Assembly Type</a> to choose the geometry information needed for providing quadrature and dof handling. The assembly pattern then basically evaluates the function operators and action for the ansatz and test functions and does the quadrature-weighted accumulation into matrices or vectors that represent the operators.</p><p>Each pattern comes with a number of arguments/quantities with associated <a href="../functionoperators/#Function-Operators">Function Operators</a> as well as one of the <a href="../pdeoperators/#Assembly-Type">Assembly Type</a> that states whether the form is evaluated over CELLS, FACES order BFACES (see above). Important note: this assembly type is relative to the grid of the first argument of the pattern. If this argument already lives ON<em>FACES and the pattern is also ON</em>FACES, it will ultimatively assemble on the faces of the faces (that are the edges of the grid with these faces). Moreover, patterns can have an <a href="../userdata/#Action">Action</a> that allow to make the evaluations parameter-, region- and/or function-dependent. Each pattern then has usually on to three implementation that writes into FEMatrix or FEVector (where e.g. a subset of arguments is fixed) or evaluates the pattern in the given FEVectorBlocks.</p><p>The patterns are used to assembly the PDE operators defined in a <a href="../pdedescription/#PDE-Description">PDE Description</a>.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.AssemblyPattern" href="#GradientRobustMultiPhysics.AssemblyPattern"><code>GradientRobustMultiPhysics.AssemblyPattern</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct AssemblyPattern{APT&lt;:AssemblyPatternType, T&lt;:Real, AT&lt;:AssemblyType, Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}</code></pre><p>each assembly pattern has one of the assembly pattern types (APT) that trigger different assemblies for the involved finite element spaces, operators and an assigned action. The assembly type (AT) determines if the assembly takes place on cells, faces or edges etc. (relatively to the assembly type of the first argument of the pattern)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/8c0dc3d49368392d123013d903cba14f90939d62/src/assemblypatterns.jl#L244">source</a></section></article><p>The following table lists all available assembly patterns, their constuctor names and how they can be used for assembly or evaluations.</p><table><tr><th style="text-align: left">AssemblyPatternType</th><th style="text-align: left">constructor</th><th style="text-align: center">evaluate</th><th style="text-align: center">assembly into matrix</th><th style="text-align: center">assembly into vector</th></tr><tr><td style="text-align: left">APT_ItemIntegrator</td><td style="text-align: left">ItemIntegrator</td><td style="text-align: center">yes</td><td style="text-align: center">no</td><td style="text-align: center">no</td></tr><tr><td style="text-align: left">APT_LinearForm</td><td style="text-align: left">LinearForm</td><td style="text-align: center">no</td><td style="text-align: center">no</td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left">APT_BilinearForm</td><td style="text-align: left">BilinearForm</td><td style="text-align: center">no</td><td style="text-align: center">yes</td><td style="text-align: center">yes (1)</td></tr><tr><td style="text-align: left">APT_TrilinearForm</td><td style="text-align: left">TrilinearForm</td><td style="text-align: center">no</td><td style="text-align: center">yes (1)</td><td style="text-align: center">yes (2)</td></tr><tr><td style="text-align: left">APT_MultiLinearForm</td><td style="text-align: left">MultilinearForm</td><td style="text-align: center">no</td><td style="text-align: center">no</td><td style="text-align: center">yes (N-1)</td></tr><tr><td style="text-align: left">APT_NonlinearForm</td><td style="text-align: left">NonlinearForm</td><td style="text-align: center">no</td><td style="text-align: center">yes (L)</td><td style="text-align: center">yes (L)</td></tr></table><p>Number in brackets denotes the number of fixed arguments needed for this assembly, (L) means that a current solution is needed to evaluate (to evaluate the linearisation of the nonlinear form in this state). Evaluations of the other AssemblyPatterns may be possible in a future update, but currently have to be performed by maintaining a duplicate of the pattern rewritten as an ItemIntegrator.</p><h4 id="Constructor-details"><a class="docs-heading-anchor" href="#Constructor-details">Constructor details</a><a id="Constructor-details-1"></a><a class="docs-heading-anchor-permalink" href="#Constructor-details" title="Permalink"></a></h4><p>Below all constructors are detailed. (For the ItemIntegrator see <a href="../itemintegrators/#Item-Integrators">Item Integrators</a>.)</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.LinearForm" href="#GradientRobustMultiPhysics.LinearForm"><code>GradientRobustMultiPhysics.LinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function LinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AssemblyType},
    FE::Array{FESpace,1},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates a LinearForm assembly pattern with the given FESpaces, operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/8c0dc3d49368392d123013d903cba14f90939d62/src/assemblypatterns/linearform.jl#L13-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.BilinearForm" href="#GradientRobustMultiPhysics.BilinearForm"><code>GradientRobustMultiPhysics.BilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function BilinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AssemblyType},
    FE::Array{FESpace,1},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates a general BilinearForm assembly pattern with the given FESpaces, operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/8c0dc3d49368392d123013d903cba14f90939d62/src/assemblypatterns/bilinearform.jl#L53-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.TrilinearForm" href="#GradientRobustMultiPhysics.TrilinearForm"><code>GradientRobustMultiPhysics.TrilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function TrilinearForm(
    T::Type{&lt;:Real},
    FES::Array{FESpace,1},          
    operators::Array{DataType,1},
    action::AbstractAction;
    regions::Array{Int,1} = [0])</code></pre><p>Creates a TrilinearForm assembly pattern with the given FESpaces, operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/8c0dc3d49368392d123013d903cba14f90939d62/src/assemblypatterns/trilinearform.jl#L13-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.MultilinearForm" href="#GradientRobustMultiPhysics.MultilinearForm"><code>GradientRobustMultiPhysics.MultilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function MultilinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AssemblyType},
    FE::Array{FESpace,1},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates a MultilinearForm assembly pattern with the given FESpaces, operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/8c0dc3d49368392d123013d903cba14f90939d62/src/assemblypatterns/multilinearform.jl#L13-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.NonlinearForm" href="#GradientRobustMultiPhysics.NonlinearForm"><code>GradientRobustMultiPhysics.NonlinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function NonlinearForm(
    T::Type{&lt;:Real},
    FES::Array{FESpace,1},          # finite element spaces for each operator of the ansatz function and the last one refers to the test function
    operators::Array{DataType,1},   # operators that should be evaluated for the ansatz function and the last one refers to the test function
    action::AbstractAction;         # action that shoul have an AbstractNLActionKernel
    regions::Array{Int,1} = [0])</code></pre><p>Creates a NonlinearForm assembly pattern.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/8c0dc3d49368392d123013d903cba14f90939d62/src/assemblypatterns/nonlinearform.jl#L13-L24">source</a></section></article><h4 id="Assemble"><a class="docs-heading-anchor" href="#Assemble">Assemble</a><a id="Assemble-1"></a><a class="docs-heading-anchor-permalink" href="#Assemble" title="Permalink"></a></h4><p>Below all assemble! functions of the patterns are listed. (For evaluation of the ItemIntegrator see <a href="../itemintegrators/#Item-Integrators">Item Integrators</a>.)</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!" href="#GradientRobustMultiPhysics.assemble!"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble!(
    b::Union{AbstractArray{T,1},AbstractArray{T,2}},    # target vector/matrix
    AP::AssemblyPattern{APT,T,AT};                      # LinearForm pattern
    factor = 1)                                         # factor that is multiplied
    where {APT &lt;: APT_LinearForm, T, AT}</code></pre><p>Assembly of a LinearForm pattern AP into a vector or matrix (if action is vetor-valued).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/8c0dc3d49368392d123013d903cba14f90939d62/src/assemblypatterns/linearform.jl#L33-L43">source</a></section><section><div><pre><code class="nohighlight hljs">assemble!(
    A::AbstractArray{T,2},                  # target matrix
    AP::AssemblyPattern{APT,T,AT};          # BilinearForm Pattern
    apply_action_to::Int = 1,               # action is applied to which argument?
    factor = 1,                             # factor that is multiplied
    transposed_assembly::Bool = false,      # transpose result?
    transpose_copy = Nothing)               # copy a transposed block to this matrix
    where {APT &lt;: APT_BilinearForm, T, AT}</code></pre><p>Assembly of a BilinearForm BLF into given two-dimensional AbstractArray (e.g. FEMatrixBlock or a ExtendableSparseMatrix).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/8c0dc3d49368392d123013d903cba14f90939d62/src/assemblypatterns/bilinearform.jl#L94-L107">source</a></section><section><div><pre><code class="nohighlight hljs">assemble!(
    b::AbstractArray{T,1},          # target vector
    AP::AssemblyPattern{APT,T,AT},  # BilinearForm Pattern
    fixedFE::AbstractArray;         # coefficients for fixed argument
    apply_action_to::Int = 1,       # action is applied to 1st or 2nd argument?
    fixed_arguments = [1],        # which argument is fixed?
    factor = 1)                     # factor that is multiplied
    where {APT &lt;: APT_BilinearForm, T, AT}</code></pre><p>Assembly of a BilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the second argument is fixed (default) by the given coefficients in fixedFE. With apply<em>action</em>to=2 the action can be also applied to the second argument instead of the first one (default).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/8c0dc3d49368392d123013d903cba14f90939d62/src/assemblypatterns/bilinearform.jl#L359-L374">source</a></section><section><div><pre><code class="nohighlight hljs">assemble!(
    assemble!(
    A::AbstractArray{T,2},                  # target matrix
    AP::AssemblyPattern{APT,T,AT},          # TrilinearForm pattern
    fixedFE::Array{&lt;:FEVectorBlock,1};      # coefficients for fixed argument
    fixed_argument = [1],                   # position of fixed argument (as an array)
    transposed_assembly::Bool = false,      # transpose result?
    factor = 1)                             # factor that is multiplied
    where {APT &lt;: APT_TrilinearForm, T, AT}</code></pre><p>Assembly of a TrilinearForm AP into given two-dimensional AbstractArray (e.g. a FEMatrixBlock). Here, one argument (specified by fixed_argument) is fixed by the given coefficients in fixedFE[1]. Note, that the action is (currently) always applied to the first and second argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/8c0dc3d49368392d123013d903cba14f90939d62/src/assemblypatterns/trilinearform.jl#L39-L55">source</a></section><section><div><pre><code class="nohighlight hljs">assemble!(
    assemble!(
    b::AbstractVector,                      # target vector
    AP::AssemblyPattern{APT,T,AT},          # coefficients for fixed arguments
    fixedFE::Array{&lt;:FEVectorBlock,1};      # TrilinearForm pattern
    factor = 1)                             # factor that is multiplied
    where {APT &lt;: APT_TrilinearForm, T, AT}</code></pre><p>Assembly of a TrilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the first two arguments are fixed by the given coefficients in FE1 and FE2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/8c0dc3d49368392d123013d903cba14f90939d62/src/assemblypatterns/trilinearform.jl#L220-L233">source</a></section><section><div><pre><code class="nohighlight hljs">assemble!(
    b::AbstractVector,                        # target vector
    FE::Array{&lt;:FEVectorBlock,1},             # coefficients of all but last argument
    AP::AssemblyPattern{APT,T,AT};            # Multilinearform pattern
    factor = 1)                               # factor that is multiplied
    where {APT &lt;: APT_MultilinearForm, T, AT}</code></pre><p>Assembly of a MultilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the all but the last arguments are fixed by the given coefficients in the components of FE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/8c0dc3d49368392d123013d903cba14f90939d62/src/assemblypatterns/multilinearform.jl#L39-L51">source</a></section><section><div><pre><code class="nohighlight hljs">assemble!(
    A::AbstractArray{T,2},                 # target matrix
    AP::AssemblyPattern{APT,T,AT};         # NonlinearForm pattern
    FEB::Array{&lt;:FEVectorBlock,1};         # coefficients of current solution for each operator
    factor = 1,                            # factor that is multiplied
    transposed_assembly::Bool = false)     # transpose result?
    where {APT &lt;: APT_NonlinearForm, T, AT}</code></pre><p>Assembly of a NonlinearForm assembly pattern into given two-dimensional AbstractArray (e.g. FEMatrixBlock).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/8c0dc3d49368392d123013d903cba14f90939d62/src/assemblypatterns/nonlinearform.jl#L42-L54">source</a></section><section><div><pre><code class="nohighlight hljs">assemble!(
    b::AbstractVector,                     # target vector
    AP::AssemblyPattern{APT,T,AT},         # NonlinearForm pattern
    FEB::Array{&lt;:FEVectorBlock,1};         # coefficients of current solution for each operator
    factor = 1)                            # factor that is multiplied
    where {APT &lt;: APT_NonlinearForm, T, AT}</code></pre><p>Assembly of a NonlinearForm AP into given AbstractVector (e.g. FEMatrixBlock).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/8c0dc3d49368392d123013d903cba14f90939d62/src/assemblypatterns/nonlinearform.jl#L227-L238">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quadrature/">« Quadrature</a><a class="docs-footer-nextpage" href="../febasisevaluators/">FE Basis Evaluators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 21 October 2021 20:09">Thursday 21 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
