<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PDE Description · GradientRobustMultiPhysics.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GradientRobustMultiPhysics.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../fems/">Implemented Finite Elements</a></li><li><a class="tocitem" href="../fespace/">FE Spaces and Arrays</a></li><li><a class="tocitem" href="../interpolations/">FE Interpolation</a></li><li><a class="tocitem" href="../functionoperators/">Function Operators</a></li><li class="is-active"><a class="tocitem" href>PDE Description</a><ul class="internal"><li><a class="tocitem" href="#Purpose"><span>Purpose</span></a></li><li><a class="tocitem" href="#Creating/Extending-a-PDEDescription"><span>Creating/Extending a PDEDescription</span></a></li><li><a class="tocitem" href="#PDE-Operators"><span>PDE Operators</span></a></li><li><a class="tocitem" href="#Other-Operators"><span>Other Operators</span></a></li><li><a class="tocitem" href="#Global-Constraints"><span>Global Constraints</span></a></li><li><a class="tocitem" href="#Dirichlet-Boundary-Data"><span>Dirichlet Boundary Data</span></a></li><li><a class="tocitem" href="#Other-Boundary-Data"><span>Other Boundary Data</span></a></li></ul></li><li><a class="tocitem" href="../pdeprototypes/">PDE Prototypes</a></li><li><a class="tocitem" href="../pdesolvers/">PDE Solvers</a></li><li><a class="tocitem" href="../userdata/">User Data</a></li><li><a class="tocitem" href="../assembly_details/">Assembly Details</a></li><li><a class="tocitem" href="../meshing/">Meshing</a></li><li><a class="tocitem" href="../quadrature/">Quadrature</a></li><li><a class="tocitem" href="../viewers/">Export/Viewers</a></li><li><span class="tocitem">Examples (Intro)</span><ul><li><a class="tocitem" href="../examples_intro/">How to run the examples</a></li><li><a class="tocitem" href="../examples/doc_1d_bestapprox/">1D L2-Bestapproximation</a></li><li><a class="tocitem" href="../examples/doc_2d_bestapprox_curlpreserve/">2D Curl-Preserving L2-Bestapproximation</a></li><li><a class="tocitem" href="../examples/doc_2d_commutinginterpolators/">Commuting Interpolators (2D)</a></li><li><a class="tocitem" href="../examples/doc_2d_convectiondiffusion/">2D Convection-Diffusion-Problem</a></li><li><a class="tocitem" href="../examples/doc_2d_cookmembrane/">2D Linear Elasticity</a></li><li><a class="tocitem" href="../examples/doc_2d_fe_on_faces/">2D Finite Elements on Faces</a></li><li><a class="tocitem" href="../examples/doc_2d_flowtransport/">2D Flow + Transport</a></li><li><a class="tocitem" href="../examples/doc_2d_liddrivencavity_anderson/">2D Lid-driven cavity (Anderson Acceleration)</a></li><li><a class="tocitem" href="../examples/doc_2d_lshape_adaptivity/">2D Adaptive Mesh Refinement (L-shape)</a></li><li><a class="tocitem" href="../examples/doc_2d_nonlin_poisson/">2D Nonlinear Poisson-Problem</a></li><li><a class="tocitem" href="../examples/doc_2d_stokes_iterated/">2D Stokes (iterated penalty method)</a></li><li><a class="tocitem" href="../examples/doc_2d_stokes_probust/">2D Pressure-robustness</a></li><li><a class="tocitem" href="../examples/doc_2d_transientstokes/">2D Transient Stokes-Problem</a></li><li><a class="tocitem" href="../examples/doc_3d_bestapprox_divpreserve/">3D Divergence-Preserving L2-Bestapproximation</a></li><li><a class="tocitem" href="../examples/doc_3d_commutinginterpolators/">Commuting Interpolators (3D)</a></li><li><a class="tocitem" href="../examples/doc_3d_poisson/">3D Poisson-Problem</a></li><li><a class="tocitem" href="../examples/doc_rational_massmatrix/">Rational Mass Matrix</a></li></ul></li><li><span class="tocitem">Examples (Advanced)</span><ul><li><a class="tocitem" href="../examples_advanced/doc_2d_compressiblestokes/">2D Compressible Stokes</a></li><li><a class="tocitem" href="../examples_advanced/doc_2d_lshape_adaptivity_eq/">2D Equilibration Error Estimation (Global)</a></li><li><a class="tocitem" href="../examples_advanced/doc_2d_lshape_adaptivity_loceq/">2D Equilibration Error Estimation (Local)</a></li><li><a class="tocitem" href="../examples_advanced/doc_2d_naturalconvection/">2D Natural Convection</a></li><li><a class="tocitem" href="../examples_advanced/doc_2d_nonlin_diffeq/">2D Comparison with DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples_advanced/doc_2d_other_linsolver/">2D User-defined Linear Solvers</a></li><li><a class="tocitem" href="../examples_advanced/doc_2d_stokes_hdiv-dg/">2D DG-Hdiv discretisation for Stokes</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>PDE Description</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PDE Description</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/master/docs/src/pdedescription.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PDE-Description"><a class="docs-heading-anchor" href="#PDE-Description">PDE Description</a><a id="PDE-Description-1"></a><a class="docs-heading-anchor-permalink" href="#PDE-Description" title="Permalink"></a></h1><h2 id="Purpose"><a class="docs-heading-anchor" href="#Purpose">Purpose</a><a id="Purpose-1"></a><a class="docs-heading-anchor-permalink" href="#Purpose" title="Permalink"></a></h2><p>Although a more manually low-level assembly of your problem is possible, it is advised to describe it in the form of a PDEDescription to get access to certain automated mechanisms (in particular concerning fixpoint solvers).</p><p>The PDEDescription has similarities with the weak form of your problem (without time derivatives that are added separately by TimeControlSolver) and in general does not need any information on the discretisation at this point.</p><p>The following flow chart summarises the assemble process that is run during the solve process. The green parts can be modified/specified by the user, the rest is handled automatically. For details on steering the solver see <a href="../pdesolvers/#PDE-Solvers">PDE Solvers</a></p><p><img src="../assembly_flowchart.png" alt="Assembly Flowchart"/> </p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.PDEDescription" href="#GradientRobustMultiPhysics.PDEDescription"><code>GradientRobustMultiPhysics.PDEDescription</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct PDEDescription
    name::String
    equation_names::Array{String,1}
    unknown_names::Array{String,1}
    LHS::Array{Array{AbstractPDEOperator,1},2}
    RHS::Array{Array{AbstractPDEOperator,1},1}
    BoundaryOperators::Array{BoundaryOperator,1}
    GlobalConstraints::Array{AbstractGlobalConstraint,1}
end</code></pre><p>struct that describes a PDE system with n equations and n unknowns</p><p>A PDE system is described by</p><ul><li>its name</li><li>the names of its equations</li><li>the names of its unknowns</li><li>a size n x n array of Array{AbstractPDEOperator,1} LHS that describes the left-hand sides</li><li>a length n array of Array{AbstractPDEOperator,1} RHS that describes the right-hand sides</li><li>a length n array of BoundaryOperators that describes the boundary conditions for each unknown</li><li>an array of GlobalConstraints that describes additional global constraints</li></ul><p>A PDEDescription mainly is a set of PDEOperators arranged in a quadratic n by n matrix. Every matrix row refers to one equation and the positioning of the PDEOperators (e.g. a bilinearform) immediately sets the information which unknowns have to be used to evaluate the operator. Also  nonlinear PDEOperators are possible where extra information on the further involved uknowns have to be specified. UserData is also assigned to the PDEDescription depending on their type. Operator coefficients are assigned directly to the PDEOperators (in form of AbstractActions), right-hand side data is assigned to the right-hand side array of PDEOperators and boundary data is assigned to the BoundaryOperators of the PDEDescription. Additionaly global constraints (like a global zero integral mean) can be assigned as a GlobalConstraint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdedescription.jl#L2-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, PDEDescription}" href="#Base.show-Tuple{IO, PDEDescription}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">show(io::IO, PDE::PDEDescription)
</code></pre><p>Custom <code>show</code> function for <code>PDEDescription</code> that prints the PDE systems and all assigned operators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdedescription.jl#L196">source</a></section></article><h2 id="Creating/Extending-a-PDEDescription"><a class="docs-heading-anchor" href="#Creating/Extending-a-PDEDescription">Creating/Extending a PDEDescription</a><a id="Creating/Extending-a-PDEDescription-1"></a><a class="docs-heading-anchor-permalink" href="#Creating/Extending-a-PDEDescription" title="Permalink"></a></h2><p>Several add...! functions allow to extend the problems at any stage. There are several prototype PDEs documented on the <a href="../pdeprototypes/#PDE-Prototypes">PDE Prototypes</a> page that can be used as a point of departure. Below is a list of functions that allows to initialise and extend a PDEDescription.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.PDEDescription-Tuple{String, Int64}" href="#GradientRobustMultiPhysics.PDEDescription-Tuple{String, Int64}"><code>GradientRobustMultiPhysics.PDEDescription</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PDEDescription(name::String, nunknowns::Int64; unknown_names, equation_names) -&gt; PDEDescription
</code></pre><p>Create empty PDEDescription for a specified number of unknowns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdedescription.jl#L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.PDEDescription-Tuple{String}" href="#GradientRobustMultiPhysics.PDEDescription-Tuple{String}"><code>GradientRobustMultiPhysics.PDEDescription</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PDEDescription(name::String) -&gt; PDEDescription
</code></pre><p>Create empty PDEDescription with no unknowns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdedescription.jl#L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.add_boundarydata!-Tuple{PDEDescription, Int64, Any, Type{var&quot;#s600&quot;} where var&quot;#s600&quot;&lt;:AbstractBoundaryType}" href="#GradientRobustMultiPhysics.add_boundarydata!-Tuple{PDEDescription, Int64, Any, Type{var&quot;#s600&quot;} where var&quot;#s600&quot;&lt;:AbstractBoundaryType}"><code>GradientRobustMultiPhysics.add_boundarydata!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_boundarydata!(PDE::PDEDescription, position::Int64, regions::Any, btype::Type{var&quot;#s600&quot;} where var&quot;#s600&quot;&lt;:AbstractBoundaryType; data)
</code></pre><p>Adds the given boundary data with the specified AbstractBoundaryType at the specified position in the BoundaryOperator of the PDEDescription.</p><p>If timedependent == true, that data function depends also on time t and is reassembled in any advance! step of a TimeControlSolver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdedescription.jl#L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.add_constraint!-Tuple{PDEDescription, AbstractGlobalConstraint}" href="#GradientRobustMultiPhysics.add_constraint!-Tuple{PDEDescription, AbstractGlobalConstraint}"><code>GradientRobustMultiPhysics.add_constraint!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_constraint!(PDE::PDEDescription, GC::AbstractGlobalConstraint)
</code></pre><p>Adds the given global constraint to the PDEDescription.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdedescription.jl#L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.add_operator!-Tuple{PDEDescription, Vector{Int64}, AbstractPDEOperator}" href="#GradientRobustMultiPhysics.add_operator!-Tuple{PDEDescription, Vector{Int64}, AbstractPDEOperator}"><code>GradientRobustMultiPhysics.add_operator!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_operator!(PDE::PDEDescription, position::Vector{Int64}, O::AbstractPDEOperator; equation_name)
</code></pre><p>Adds the given abstract PDEOperator to the left-hand side of the PDEDescription at the specified position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdedescription.jl#L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.add_operator!-Tuple{PDEDescription, Vector{Int64}, GradientRobustMultiPhysics.PDEOperator}" href="#GradientRobustMultiPhysics.add_operator!-Tuple{PDEDescription, Vector{Int64}, GradientRobustMultiPhysics.PDEOperator}"><code>GradientRobustMultiPhysics.add_operator!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_operator!(PDE::PDEDescription, position::Vector{Int64}, O::GradientRobustMultiPhysics.PDEOperator; equation_name)
</code></pre><p>Adds the given PDEOperator to the left-hand side of the PDEDescription at the specified position. Optionally, the name of the equation can be changed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdedescription.jl#L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.add_rhsdata!-Tuple{PDEDescription, Int64, AbstractPDEOperator}" href="#GradientRobustMultiPhysics.add_rhsdata!-Tuple{PDEDescription, Int64, AbstractPDEOperator}"><code>GradientRobustMultiPhysics.add_rhsdata!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_rhsdata!(PDE::PDEDescription, position::Int64, O::AbstractPDEOperator)
</code></pre><p>Adds the given PDEOperator to the right-hand side of the PDEDescription at the specified position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdedescription.jl#L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.add_unknown!-Tuple{PDEDescription}" href="#GradientRobustMultiPhysics.add_unknown!-Tuple{PDEDescription}"><code>GradientRobustMultiPhysics.add_unknown!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_unknown!(PDE::PDEDescription; equation_name, unknown_name)
</code></pre><p>Adds another unknown to the PDEDescription.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdedescription.jl#L101">source</a></section></article><h2 id="PDE-Operators"><a class="docs-heading-anchor" href="#PDE-Operators">PDE Operators</a><a id="PDE-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#PDE-Operators" title="Permalink"></a></h2><p>The PDE consists of PDEOperators characterising some feature of the model (like friction, convection, exterior forces etc.), they describe the continuous weak form of the PDE. </p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.PDEOperator" href="#GradientRobustMultiPhysics.PDEOperator"><code>GradientRobustMultiPhysics.PDEOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct PDEOperator{T&lt;:Real, APT&lt;:AssemblyPatternType, AT&lt;:AbstractAssemblyType} &lt;: AbstractPDEOperator</code></pre><p>common structures for all finite element operators that are assembled with GradientRobustMultiPhysics; better look at the AssemblyPatternType and the constructors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdeoperators.jl#L57">source</a></section></article><p>The following table lists all available operators and physics-motivated constructors for them. Click on them or scroll down to find out more details.</p><table><tr><th style="text-align: left">Main constructors</th><th style="text-align: left">Special constructors</th><th style="text-align: left">Mathematically</th></tr><tr><td style="text-align: left"><a href="#GradientRobustMultiPhysics.AbstractBilinearForm"><code>AbstractBilinearForm</code></a></td><td style="text-align: left"></td><td style="text-align: left"><span>$(\mathrm{A}(\mathrm{FO}_1(u)),\mathrm{FO}_2(v))$</span> or <span>$(\mathrm{FO}_1(u),\mathrm{A}(\mathrm{FO}_2(v)))$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.LaplaceOperator"><code>LaplaceOperator</code></a></td><td style="text-align: left"><span>$(\kappa \nabla u,\nabla v)$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.ReactionOperator"><code>ReactionOperator</code></a></td><td style="text-align: left"><span>$(\alpha u, v)$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.LagrangeMultiplier"><code>LagrangeMultiplier</code></a></td><td style="text-align: left"><span>$(\mathrm{FO}_1(u), v)$</span> (automatically assembles 2nd transposed block)</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.ConvectionOperator"><code>ConvectionOperator</code></a></td><td style="text-align: left"><span>$(\beta \cdot \nabla u, v)$</span> (beta is function)</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.HookStiffnessOperator2D"><code>HookStiffnessOperator2D</code></a></td><td style="text-align: left"><span>$(\mathbb{C} \epsilon(u),\epsilon(v))$</span> (also 1D or 3D variants exist)</td></tr><tr><td style="text-align: left"><a href="#GradientRobustMultiPhysics.AbstractTrilinearForm"><code>AbstractTrilinearForm</code></a></td><td style="text-align: left"></td><td style="text-align: left"><span>$(\mathrm{A}(\mathrm{FO}_1(a),\mathrm{FO}_2(u)),\mathrm{FO}_3(v))$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.ConvectionOperator"><code>ConvectionOperator</code></a></td><td style="text-align: left"><span>$((a \cdot \nabla) u, v)$</span> (a is registered unknown)</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.ConvectionRotationFormOperator"><code>ConvectionRotationFormOperator</code></a></td><td style="text-align: left"><span>$((a \times \nabla) u,v)$</span> (a is registered unknown, only 2D for now)</td></tr><tr><td style="text-align: left"><a href="#GradientRobustMultiPhysics.GenerateNonlinearForm"><code>GenerateNonlinearForm</code></a></td><td style="text-align: left"></td><td style="text-align: left"><span>$(\mathrm{NA}(\mathrm{FO}_1(u),...,\mathrm{FO}_{N-1}(u)),\mathrm{FO}_N(v))$</span></td></tr><tr><td style="text-align: left"><a href="#GradientRobustMultiPhysics.RhsOperator"><code>RhsOperator</code></a></td><td style="text-align: left"></td><td style="text-align: left"><span>$(f \cdot \mathrm{FO}(v))$</span></td></tr></table><p>Legend: <span>$\mathrm{FO}$</span>  are placeholders for <a href="../functionoperators/#Function-Operators">Function Operators</a>, and <span>$\mathrm{A}$</span> stands for a (linear) <a href="../userdata/#Actions">Actions</a> (that only expects the operator value of the finite element function as an input) and <span>$\mathrm{NA}$</span> stands for a (nonlinear) <a href="../userdata/#Actions">Actions</a> (see <a href="#GradientRobustMultiPhysics.GenerateNonlinearForm"><code>GenerateNonlinearForm</code></a> for details).</p><h3 id="Common-Operators"><a class="docs-heading-anchor" href="#Common-Operators">Common Operators</a><a id="Common-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Operators" title="Permalink"></a></h3><p>Below you find the special constructors of available common linear, bilinear and trilinear forms.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.AbstractBilinearForm" href="#GradientRobustMultiPhysics.AbstractBilinearForm"><code>GradientRobustMultiPhysics.AbstractBilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function AbstractBilinearForm(
    operators::Array{AbstractFunctionOperator,1},
    action::AbstractAction;
    name = &quot;auto&quot;,
    AT::Type{&lt;:AbstractAssemblyType} = ON_CELLS,
    apply_action_to = 1,
    regions::Array{Int,1} = [0],
    transposed_assembly::Bool = false,
    store::Bool = false)</code></pre><p>abstract bilinearform constructor that assembles</p><ul><li>b(u,v) = int<em>regions action(operator1(u)) * operator2(v) if apply</em>action_to = 1</li><li>b(u,v) = int<em>regions operator1(u) * action(operator2(v)) if apply</em>action_to = 2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdeoperators.jl#L296-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.AbstractTrilinearForm" href="#GradientRobustMultiPhysics.AbstractTrilinearForm"><code>GradientRobustMultiPhysics.AbstractTrilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function AbstractTrilinearForm(
    operators::Array{AbstractFunctionOperator,1},
    a_from::Int,
    a_to::Int,
    action::AbstractAction;
    name = &quot;auto&quot;,
    AT::Type{&lt;:AbstractAssemblyType} = ON_CELLS,
    regions::Array{Int,1} = [0],
    transposed_assembly::Bool = false)</code></pre><p>abstract trilinearform constructor that assembles</p><ul><li>c(a,u,v) = int_regions action(operator1(a),operator2(u)) * operator3(v)</li></ul><p>where u and are the ansatz and test function coressponding to the PDE coordinates and a is an additional unknown of the PDE. The argument a can be moved to the other positions with a<em>to and gets it data from unknown a</em>from of the full PDEdescription.</p><p>(Note that this operator is always marked as nonlinear by the Solver configuration.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdeoperators.jl#L340-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.LaplaceOperator" href="#GradientRobustMultiPhysics.LaplaceOperator"><code>GradientRobustMultiPhysics.LaplaceOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">LaplaceOperator() -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, on cells}
LaplaceOperator(diffusion::Any; name, AT, gradient_operator, regions, store) -&gt; Union{Nothing, GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, on cells}}
</code></pre><p>constructor for a bilinearform that describes a(u,v) = (kappa * nabla u, nabla v) where kappa is some constant diffusion coefficient</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdeoperators.jl#L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ReactionOperator" href="#GradientRobustMultiPhysics.ReactionOperator"><code>GradientRobustMultiPhysics.ReactionOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ReactionOperator() -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, on cells}
ReactionOperator(coefficient::Any; name, AT, identity_operator, regions, store) -&gt; Union{Nothing, GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, on cells}}
</code></pre><p>constructor for a bilinearform that describes a(u,v) = (A(u),v) or (u,A(v)) with some user-specified action A</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdeoperators.jl#L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ConvectionOperator" href="#GradientRobustMultiPhysics.ConvectionOperator"><code>GradientRobustMultiPhysics.ConvectionOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function ConvectionOperator(
    a_from::Int, 
    beta_operator::Type{&lt;:AbstractFunctionOperator},
    xdim::Int,
    ncomponents::Int;
    name = &quot;auto&quot;,
    AT::Type{&lt;:AbstractAssemblyType} = ON_CELLS,
    fixed_argument::Int = 1,
    factor = 1,
    ansatzfunction_operator::Type{&lt;:AbstractFunctionOperator} = Gradient,
    testfunction_operator::Type{&lt;:AbstractFunctionOperator} = Identity,
    regions::Array{Int,1} = [0],
    auto_newton::Bool = false,
    quadorder = 0)</code></pre><p>constructs a trilinearform for a convection term of the form c(a,u,v) = (beta<em>operator(a)*grad(u),v) where a</em>from is the id of some unknown of the PDEDescription. xdim is the space dimension (= number of components of beta<em>operato(a)) and ncomponents is the number of components of u. With fixed</em>argument = 2 a and u can switch their places, i.e.  c(u,a,v) = (beta<em>operator(u)*grad(a),v), With auto</em>newton = true a Newton scheme for a(u,v) = (u*grad(u),v) is automatically derived (and fixed_argument is ignored).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdeoperators.jl#L388-L411">source</a></section><section><div><pre><code class="language-julia">ConvectionOperator(beta::UserData{AbstractDataFunction, ndim} where ndim, ncomponents::Int64; name, store, AT, ansatzfunction_operator, testfunction_operator, regions) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, on cells}
</code></pre><p>constructor for a bilinearform that describes a(u,v) = (beta*grad(u),v) with some user-specified DataFunction beta that writes into an result array of length ncomponents</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdeoperators.jl#L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ConvectionRotationFormOperator" href="#GradientRobustMultiPhysics.ConvectionRotationFormOperator"><code>GradientRobustMultiPhysics.ConvectionRotationFormOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ConvectionRotationFormOperator(beta::Int64, beta_operator::Type{var&quot;#s182&quot;} where var&quot;#s182&quot;&lt;:??, xdim::Int64, ncomponents::Int64; name, AT, factor, ansatzfunction_operator, testfunction_operator, regions) -&gt; Union{Nothing, GradientRobustMultiPhysics.PDEOperator{Float64, TrilinearForm, on cells}}
</code></pre><p>constructor for a trilinearform that describes a(u,v) = (beta x curl(u),v) where beta is the id of some unknown vector field of the PDEDescription, u and v are also vector-fields and x is the cross product (so far this is only implemented in 2D)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdeoperators.jl#L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.HookStiffnessOperator1D" href="#GradientRobustMultiPhysics.HookStiffnessOperator1D"><code>GradientRobustMultiPhysics.HookStiffnessOperator1D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HookStiffnessOperator1D(mu::Any; name, regions, gradient_operator, store) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, on cells}
</code></pre><p>constructor for a bilinearform that describes a(u,v) = (C grad(u), grad(v)) where C is the 1D stiffness tensor C grad(u) = mu grad(u)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdeoperators.jl#L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.HookStiffnessOperator2D" href="#GradientRobustMultiPhysics.HookStiffnessOperator2D"><code>GradientRobustMultiPhysics.HookStiffnessOperator2D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HookStiffnessOperator2D(mu::Any, lambda::Any; name, AT, regions, gradient_operator, store) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, on cells}
</code></pre><p>constructor for a bilinearform that describes a(u,v) = (C eps(u), eps(v)) where C is the 3D stiffness tensor for isotropic media in Voigt notation, i.e. C eps(u) = 2 mu eps(u) + lambda tr(eps(u)) for Lame parameters mu and lambda</p><pre><code class="language-none">In Voigt notation C is a 3 x 3 matrix
C = [c11,c12,  0
     c12,c11,  0
       0,  0,c33]

where c33 = shear_modulus, c12 = lambda and c11 = 2*c33 + c12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdeoperators.jl#L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.HookStiffnessOperator3D" href="#GradientRobustMultiPhysics.HookStiffnessOperator3D"><code>GradientRobustMultiPhysics.HookStiffnessOperator3D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HookStiffnessOperator3D(mu::Any, lambda::Any; name, AT, regions, gradient_operator, store) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, on cells}
</code></pre><p>constructor for a bilinearform that describes a(u,v) = (C eps(u), eps(v)) where C is the 3D stiffness tensor for isotropic media in Voigt notation, i.e. C eps(u) = 2 mu eps(u) + lambda tr(eps(u)) for Lame parameters mu and lambda</p><pre><code class="language-none">In Voigt notation C is a 6 x 6 matrix
C = [c11,c12,c12,  0,  0,  0
     c12,c11,c12,  0,  0,  0
     c12,c12,c11,  0,  0,  0
       0,  0,  0,c44,  0,  0
       0,  0,  0,  0,c44,  0
       0,  0,  0,  0,  0,c44]   

where c44 = shear_modulus, c12 = lambda and c11 = 2*c44 + c12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdeoperators.jl#L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.RhsOperator" href="#GradientRobustMultiPhysics.RhsOperator"><code>GradientRobustMultiPhysics.RhsOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RhsOperator(operator::Type{var&quot;#s206&quot;} where var&quot;#s206&quot;&lt;:??, action::AbstractAction; name, AT, regions, factor, store) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, LinearForm, on cells}
</code></pre><p>generates a linearform from an action</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdeoperators.jl#L635">source</a></section><section><div><pre><code class="language-julia">RhsOperator(operator::Type{var&quot;#s180&quot;} where var&quot;#s180&quot;&lt;:??, regions::Vector{Int64}, data::UserData{var&quot;#s179&quot;, ndim} where {var&quot;#s179&quot;&lt;:AbstractDataFunction, ndim}; name, AT, factor, store) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, LinearForm, on cells}
</code></pre><p>generates a linearform from a given UserData{&lt;:DataFunction} (whose result dimension has to be 1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdeoperators.jl#L657">source</a></section></article><h3 id="Lagrange-Multipliers"><a class="docs-heading-anchor" href="#Lagrange-Multipliers">Lagrange Multipliers</a><a id="Lagrange-Multipliers-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrange-Multipliers" title="Permalink"></a></h3><p>There is a special bilinearform intended to use for the assembly of Lagrange multipliers that automatically copies itself to the transposed block of the PDEdescription.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.LagrangeMultiplier" href="#GradientRobustMultiPhysics.LagrangeMultiplier"><code>GradientRobustMultiPhysics.LagrangeMultiplier</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">LagrangeMultiplier(operator::Type{var&quot;#s206&quot;} where var&quot;#s206&quot;&lt;:??; name, AT, action, regions, store, factor) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, on cells}
</code></pre><p>constructor for a bilinearform that describes a(u,v) = (A(operator(u)), id(v)) and assembles a second transposed block at the block of the transposed PDE coordinates. It is intended to use to render one unknown of the PDE the Lagrange multiplier for another unknown by putting this operator on the coressponding subdiagonal block of the PDE description.</p><p>Example: LagrangeMultiplier(Divergence) is used to render the pressure the LagrangeMultiplier for the velocity divergence constraint in the Stokes prototype.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdeoperators.jl#L189">source</a></section></article><h3 id="Nonlinear-Operators"><a class="docs-heading-anchor" href="#Nonlinear-Operators">Nonlinear Operators</a><a id="Nonlinear-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Operators" title="Permalink"></a></h3><p>Nonlinear Operators can be setup in two ways. The manual way requires the user to define an action with a nonlinear action kernel (see <a href="../userdata/#Action-Kernels">Action Kernels</a>) that specifies the linearisation of the nonlinearity. The is also an automatic way where the user specifies a norml action kernel (where the input can be used nonlinearly) which is then automatically differentiated to generate the linearised action kernel, see below for details.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.GenerateNonlinearForm" href="#GradientRobustMultiPhysics.GenerateNonlinearForm"><code>GradientRobustMultiPhysics.GenerateNonlinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function GenerateNonlinearForm(
    name::String,
    operator1::Array{DataType,1},
    coeff_from::Array{Int,1},
    operator2::Type{&lt;:AbstractFunctionOperator},
    action_kernel::Function,
    argsizes::Array{Int,1},
    dim::Int;
    AT::Type{&lt;:AbstractAssemblyType} = ON_CELLS,
    ADnewton::Bool = false,
    action_kernel_rhs = nothing,
    regions = [0])</code></pre><p>generates an abstract nonlinearform operator G.  The array coeff_from stores the ids of the unknowns that should be used to evaluate the operators. The array argsizes is a vector with two entries where the first one is the length of the expected result vector and the second one is the length of the input vector.</p><p>If ADnewton == true, the specified action<em>kernel is automatically differentiated to assemble the Jacobian DG and setup a Newton iteration. The action</em>kernel has to be a function of the interface </p><pre><code class="language-none">function name(result,input)</code></pre><p>where input is a vector of the operators of the solution and result is what then is multiplied with operator2 of the testfunction. Given some operator G(u), the Newton iteration reads DG u_next = DG u - G(u) which is added to the rest of the (linear) operators in the PDEDescription.</p><p>If ADnewton == false, the user is epected to prescribe a linearisation of the nonlinear operator. In this case the action_kernel has to satisfy the interface</p><pre><code class="language-none">function name(result, input_current, input_ansatz)</code></pre><p>where input<em>current is a vector of the operators of the solution and input</em>ansatz is a vecor with the operators evaluated at one of the basis functions. If necessary, also a right-hand side action in the same format can be prescribed in action<em>kernel</em>rhs.</p><p>Note: this is a highly experimental feature at the moment and will possibly only work when all operators are associated with the same unknown.</p><p>can only be applied in PDE LHS</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdeoperators.jl#L517-L556">source</a></section></article><h2 id="Other-Operators"><a class="docs-heading-anchor" href="#Other-Operators">Other Operators</a><a id="Other-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Operators" title="Permalink"></a></h2><p>There are some more operators that do not fit into the structures above. Also, in the future, the goal is to open up the operator level for exterior code to setup operators that are assembled elsewhere.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.FVConvectionDiffusionOperator" href="#GradientRobustMultiPhysics.FVConvectionDiffusionOperator"><code>GradientRobustMultiPhysics.FVConvectionDiffusionOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FVConvectionDiffusionOperator(beta_from::Int64; diffusion) -&gt; FVConvectionDiffusionOperator
</code></pre><p>finite-volume convection diffusion operator (for cell-wise P0 rho)</p><ul><li>div(diffusion * grad(rho) + beta rho)</li></ul><p>For diffusion = 0, the upwind divergence: div_upw(beta*rho) is generated  For diffusion &gt; 0, TODO</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdeoperators.jl#L1173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.DiagonalOperator" href="#GradientRobustMultiPhysics.DiagonalOperator"><code>GradientRobustMultiPhysics.DiagonalOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiagonalOperator() -&gt; DiagonalOperator
DiagonalOperator(value::Real) -&gt; DiagonalOperator
DiagonalOperator(value::Real, onlynz::Bool; regions) -&gt; DiagonalOperator
</code></pre><p>puts <em>value</em> on the diagonal entries of the cell dofs within given <em>regions</em></p><p>if <em>onlyz</em> == true only values that are zero are changed</p><p>can only be applied in PDE LHS</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdeoperators.jl#L1132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.CopyOperator" href="#GradientRobustMultiPhysics.CopyOperator"><code>GradientRobustMultiPhysics.CopyOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CopyOperator(copy_from::Any, factor::Any) -&gt; CopyOperator
</code></pre><p>copies entries from TargetVector to rhs block</p><p>can only be applied in PDE RHS</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdeoperators.jl#L1152">source</a></section></article><h2 id="Global-Constraints"><a class="docs-heading-anchor" href="#Global-Constraints">Global Constraints</a><a id="Global-Constraints-1"></a><a class="docs-heading-anchor-permalink" href="#Global-Constraints" title="Permalink"></a></h2><p>GlobalConstraints are additional constraints that the user does not wish to implement as a global Lagrange multiplier because it e.g. causes a dense row in the system matrix and therefore may destroy the performance of the sparse matrix routines. Such a constraint may be a fixed integral mean. Another application are periodic boundary conditions or glued-together quantities in different regions of the grid. Here a CombineDofs constraint may help.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.CombineDofs" href="#GradientRobustMultiPhysics.CombineDofs"><code>GradientRobustMultiPhysics.CombineDofs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CombineDofs &lt;: AbstractGlobalConstraint</code></pre><p>combines specified degrees of freedom of two unknown (can be the same), which allows to glue together different unknowns in different regions or periodic boundary conditions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/globalconstraints.jl#L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.FixedIntegralMean" href="#GradientRobustMultiPhysics.FixedIntegralMean"><code>GradientRobustMultiPhysics.FixedIntegralMean</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct FixedIntegralMean &lt;: AbstractGlobalConstraint</code></pre><p>fixes integral mean of the unknown to the specified value</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/globalconstraints.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.add_constraint!" href="#GradientRobustMultiPhysics.add_constraint!"><code>GradientRobustMultiPhysics.add_constraint!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_constraint!(PDE::PDEDescription, GC::AbstractGlobalConstraint)
</code></pre><p>Adds the given global constraint to the PDEDescription.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdedescription.jl#L185">source</a></section></article><h2 id="Dirichlet-Boundary-Data"><a class="docs-heading-anchor" href="#Dirichlet-Boundary-Data">Dirichlet Boundary Data</a><a id="Dirichlet-Boundary-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Dirichlet-Boundary-Data" title="Permalink"></a></h2><p>BoundaryOperators carry the boundary data for each unknown. Each regions can have a different AbstractBoundaryType and an associated data function that satisfies the interface function data!(result,x::Array{&lt;:Real,1}) or function data!(result,x::Array{&lt;:Real,1},t::Real) if it is also time-dependent.</p><table><tr><th style="text-align: left">AbstractBoundaryType</th><th style="text-align: left">Subtypes</th><th style="text-align: left">causes</th></tr><tr><td style="text-align: left"><a href="@ref"><code>DirichletBoundary</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="@ref"><code>BestapproxDirichletBoundary</code></a></td><td style="text-align: left">computation of Dirichlet data by bestapproximation along boundary faces</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="@ref"><code>InterpolateDirichletBoundary</code></a></td><td style="text-align: left">computation of Dirichlet data by interpolation along boundary faces</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="@ref"><code>HomogeneousDirichletBoundary</code></a></td><td style="text-align: left">zero Dirichlet data on all dofs</td></tr></table><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.BoundaryOperator" href="#GradientRobustMultiPhysics.BoundaryOperator"><code>GradientRobustMultiPhysics.BoundaryOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct BoundaryOperator &lt;: AbstractPDEOperator</code></pre><p>collects boundary data for a component of the system and allows to specify a AbstractBoundaryType for each boundary region so far only DirichletBoundary types (see above)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/boundarydata.jl#L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.add_boundarydata!" href="#GradientRobustMultiPhysics.add_boundarydata!"><code>GradientRobustMultiPhysics.add_boundarydata!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_boundarydata!(PDE::PDEDescription, position::Int64, regions::Any, btype::Type{var&quot;#s600&quot;} where var&quot;#s600&quot;&lt;:AbstractBoundaryType; data)
</code></pre><p>Adds the given boundary data with the specified AbstractBoundaryType at the specified position in the BoundaryOperator of the PDEDescription.</p><p>If timedependent == true, that data function depends also on time t and is reassembled in any advance! step of a TimeControlSolver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b9cea31052933a6c99e06fa80e41aa910e215754/src/pdedescription.jl#L172">source</a></section></article><h2 id="Other-Boundary-Data"><a class="docs-heading-anchor" href="#Other-Boundary-Data">Other Boundary Data</a><a id="Other-Boundary-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Boundary-Data" title="Permalink"></a></h2><p>NeumannBoundary can be implemented as a RhsOperator with AT = ON_BFACES</p><p>PeriodicBoundary can be implemented as a CombineDofs &lt;: AbstractGlobalConstraint</p><p>SymmetryBoundary can be implemented by penalisation as a AbstractBilinearForm on BFaces and specified boundary regions with operator NormalFlux + MultiplyScalarAction(penalty).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../functionoperators/">« Function Operators</a><a class="docs-footer-nextpage" href="../pdeprototypes/">PDE Prototypes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 16 April 2021 13:45">Friday 16 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
