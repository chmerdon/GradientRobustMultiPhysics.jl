var documenterSearchIndex = {"docs":
[{"location":"interpolations/#Finite-Element-Interpolations","page":"FE Interpolation","title":"Finite Element Interpolations","text":"","category":"section"},{"location":"interpolations/","page":"FE Interpolation","title":"FE Interpolation","text":"Each finite element has its standard interpolator that can be applied to some user-defined DataFunction. Instead of interpolating on the full cells, the interpolation can be restricted to faces or edges, by specifying one of the Assembly Types in the call.","category":"page"},{"location":"interpolations/","page":"FE Interpolation","title":"FE Interpolation","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"interpolations.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"interpolations/#GradientRobustMultiPhysics.interpolate!-Tuple{FEVectorBlock, Type{var\"#s183\"} where var\"#s183\"<:AbstractAssemblyType, UserData{AbstractDataFunction, ndim} where ndim}","page":"FE Interpolation","title":"GradientRobustMultiPhysics.interpolate!","text":"function interpolate!(Target::FEVectorBlock,\n     AT::Type{<:AbstractAssemblyType},\n     source_data::UserData{AbstractDataFunction};\n     items = [],\n     time = 0)\n\nInterpolates the given sourcedata into the finite elements space assigned to the Target FEVectorBlock with the specified AbstractAssemblyType (usualy ONCELLS). The optional time argument is only used if the source_data depends on time.\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#GradientRobustMultiPhysics.interpolate!-Tuple{FEVectorBlock, UserData{AbstractDataFunction, ndim} where ndim}","page":"FE Interpolation","title":"GradientRobustMultiPhysics.interpolate!","text":"function interpolate!(Target::FEVectorBlock,\n     source_data::UserData{AbstractDataFunction};\n     items = [],\n     time = 0)\n\nInterpolates the given sourcedata into the finite element space assigned to the Target FEVectorBlock. The optional time argument is only used if the sourcedata depends on time.\n\n\n\n\n\n","category":"method"},{"location":"interpolations/#GradientRobustMultiPhysics.nodevalues!","page":"FE Interpolation","title":"GradientRobustMultiPhysics.nodevalues!","text":"function nodevalues!(\n    Target::AbstractArray{<:Real,2},\n    Source::FEVectorBlock,\n    operator::Type{<:AbstractFunctionOperator} = Identity;\n    regions::Array{Int,1} = [0],\n    target_offset::Int = 0,   # start to write into Target after offset\n    zero_target::Bool = true, # target vector is zeroed\n    continuous::Bool = false)\n\nEvaluates the finite element function with the coefficient vector Source and the specified FunctionOperator at all the nodes of the (specified regions of the) grid and writes the values into Target. Discontinuous (continuous = false) quantities are averaged.\n\n\n\n\n\n","category":"function"},{"location":"examples/doc_3d_bestapprox_divpreserve/#D-Divergence-Preserving-L2-Bestapproximation","page":"3D Divergence-Preserving L2-Bestapproximation","title":"3D Divergence-Preserving L2-Bestapproximation","text":"","category":"section"},{"location":"examples/doc_3d_bestapprox_divpreserve/","page":"3D Divergence-Preserving L2-Bestapproximation","title":"3D Divergence-Preserving L2-Bestapproximation","text":"(source code)","category":"page"},{"location":"examples/doc_3d_bestapprox_divpreserve/","page":"3D Divergence-Preserving L2-Bestapproximation","title":"3D Divergence-Preserving L2-Bestapproximation","text":"This example computes the L2-bestapproximation of some given vector-valued function into an Hdiv-conforming finite element space. It also preserves the divergence of the function in the sense that the divergence of the approximation equals the piecewise integral mean of the exact divergence. Afterwards the L2 error (also of the divergence) is computed.","category":"page"},{"location":"examples/doc_3d_bestapprox_divpreserve/","page":"3D Divergence-Preserving L2-Bestapproximation","title":"3D Divergence-Preserving L2-Bestapproximation","text":"module Example_3DBestapproxDivpreserve\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\n\n# define some vector field that should be approximated\nfunction exact_function!(result,x::Array{<:Real,1})\n    result[1] = x[1]^3+x[3]^2\n    result[2] = -x[1]^2 + x[2] + 1\n    result[3] = x[1]*x[2]\nend\n# define its divergence\nfunction exact_divergence!(result,x::Array{<:Real,1})\n    result[1] = 3*x[1]*x[1] + 1\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # generate a unit square mesh and refine\n    xgrid = uniform_refine(reference_domain(Tetrahedron3D),4)\n\n    # negotiate exact_function! and exact_curl! to the package\n    user_function = DataFunction(exact_function!, [3,3]; name = \"u\", dependencies = \"X\", quadorder = 3)\n    user_function_div = DataFunction(exact_divergence!, [1,3]; name = \"div(u)\", dependencies = \"X\", quadorder = 2)\n\n    # setup a bestapproximation problem via a predefined prototype\n    Problem = L2BestapproximationProblem(user_function; bestapprox_boundary_regions = [])\n\n    # add a new unknown (Lagrange multiplier that handles the divergence constraint)\n    # here 1 is the number of components (it is scalarvalued) and 3 is the space dimension\n    add_unknown!(Problem; unknown_name = \"p\", equation_name = \"divergence constraint\")\n    add_operator!(Problem, [1,2], LagrangeMultiplier(Divergence))\n\n    # add the right-hand side data for the constraint and inspect the defined problem\n    add_rhsdata!(Problem, 2, RhsOperator(Identity, [0], user_function_div))\n    @show Problem\n\n    # choose some (inf-sup stable) finite element types\n    #FEType = [HDIVRT0{3}, H1P0{1}]\n    FEType = [HDIVBDM1{3}, H1P0{1}]\n    FES = [FESpace{FEType[1]}(xgrid),FESpace{FEType[2]}(xgrid; broken = true)]\n\n    # create a solution vector and solve the problem\n    Solution = FEVector{Float64}([\"u_h\",\"p_h\"],FES)\n    solve!(Solution, Problem)\n\n    # calculate L2 error and L2 divergence error\n    L2ErrorEvaluator = L2ErrorIntegrator(Float64, user_function, Identity)\n    L2DivergenceErrorEvaluator = L2ErrorIntegrator(Float64, user_function_div, Divergence)\n    println(\"\\tL2error(Id) = $(sqrt(evaluate(L2ErrorEvaluator,Solution[1])))\")\n    println(\"\\tL2error(div) = $(sqrt(evaluate(L2DivergenceErrorEvaluator,Solution[1])))\")\nend\n\nend","category":"page"},{"location":"examples/doc_3d_bestapprox_divpreserve/","page":"3D Divergence-Preserving L2-Bestapproximation","title":"3D Divergence-Preserving L2-Bestapproximation","text":"Main.##270.Example_3DBestapproxDivpreserve","category":"page"},{"location":"examples/doc_3d_bestapprox_divpreserve/#Output-of-default-main()-run","page":"3D Divergence-Preserving L2-Bestapproximation","title":"Output of default main() run","text":"","category":"section"},{"location":"examples/doc_3d_bestapprox_divpreserve/","page":"3D Divergence-Preserving L2-Bestapproximation","title":"3D Divergence-Preserving L2-Bestapproximation","text":"Example_3DBestapproxDivpreserve.main()","category":"page"},{"location":"examples/doc_3d_bestapprox_divpreserve/","page":"3D Divergence-Preserving L2-Bestapproximation","title":"3D Divergence-Preserving L2-Bestapproximation","text":"\nPDE-DESCRIPTION\n===============\n  system name = L2-Bestapproximation problem\n\n     id   | unknown name / equation name\n    [1]   | u / L2-bestapproximation equation \n    [2]   | p / divergence constraint \n\n  LHS block | PDEOperator(s)\n    [1,1]   | u ⋅ v (regions = [0])\n    [1,2]   | div(v) ⋅ q (regions = [0])\n    [2,1]   | none\n    [2,2]   | none\n\n  RHS block | PDEOperator(s)\n     [1]    | u⋅id(v) (regions = [0])\n     [2]    | div(u)⋅id(v) (regions = [0])\n\n   BoundaryOperator[1] : \n   BoundaryOperator[2] : \n\nProblem = \n┌ Info: ----- Solving L2-Bestapproximation problem -----\n│ \tEquation (1.1) L2-bestapproximation equation : u >> u_h (HDIVBDM1{3}, ndofs = 26112)\n│ \tEquation (1.2) divergence constraint : p >> p_h (H1P0{1} (broken), ndofs = 4096)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 1.4239135366618736e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tL2error(Id) = 0.00017706474627459623\n\tL2error(div) = 0.00987828043623494\n","category":"page"},{"location":"examples/doc_3d_bestapprox_divpreserve/","page":"3D Divergence-Preserving L2-Bestapproximation","title":"3D Divergence-Preserving L2-Bestapproximation","text":"","category":"page"},{"location":"examples/doc_3d_bestapprox_divpreserve/","page":"3D Divergence-Preserving L2-Bestapproximation","title":"3D Divergence-Preserving L2-Bestapproximation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_1d_bestapprox/#D-L2-Bestapproximation","page":"1D L2-Bestapproximation","title":"1D L2-Bestapproximation","text":"","category":"section"},{"location":"examples/doc_1d_bestapprox/","page":"1D L2-Bestapproximation","title":"1D L2-Bestapproximation","text":"(source code)","category":"page"},{"location":"examples/doc_1d_bestapprox/","page":"1D L2-Bestapproximation","title":"1D L2-Bestapproximation","text":"This example computes the L2-bestapproximation of some given scalar-valued function into the piecewise quadratic continuous polynomials. Afterwards the L2 error is computed and the solution is plotted.","category":"page"},{"location":"examples/doc_1d_bestapprox/","page":"1D L2-Bestapproximation","title":"1D L2-Bestapproximation","text":"module Example_1DBestapprox\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# define some (vector-valued) function (to be L2-bestapproximated in this example)\nfunction exact_function!(result,x::Array{<:Real,1})\n    result[1] = (x[1]-1//2)*(x[1]-9//10)*(x[1]-1//3)*(x[1]-1//10)\nend\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, verbosity = 0, nrefs = 2, broken::Bool = false)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # generate mesh and uniform refine nrefs times\n    xgrid = simplexgrid([0.0,1//3,2//3,1.0])\n    xgrid = uniform_refine(xgrid,nrefs)\n\n    # negotiate exact_function! to the package\n    user_function = DataFunction(exact_function!, [1,1]; name = \"u\", dependencies = \"X\", quadorder = 4)\n\n    # setup a bestapproximation problem via a predefined prototype\n    # and an L2ErrorEvaluator that can be used later to compute the L2 error\n    Problem = L2BestapproximationProblem(user_function; bestapprox_boundary_regions = [1,2])\n    L2ErrorEvaluator = L2ErrorIntegrator(Float64, user_function, Identity)\n\n    # choose some finite element type and generate a FESpace for the grid\n    # (here it is a one-dimensional H1-conforming P2 element H1P2{1,1})\n    # the broken switch toggles a broken dofmap\n    FEType = H1P2{1,1}\n    FES = FESpace{FEType}(xgrid; broken = broken)\n\n    # generate a solution vector and solve the problem\n    # (the verbosity argument that many functions have steers the talkativity,\n    #  the larger the number, the more details)\n    Solution = FEVector{Float64}(\"u_h\",FES)\n    solve!(Solution, Problem)\n\n    # calculate the L2 error\n    L2error = sqrt(evaluate(L2ErrorEvaluator,Solution[1]))\n    println(\"\\t|| u - u_h || = $L2error\")\n\n    # to compare our discrete solution with a finer one, we interpolate the exact function\n    # again on some more refined mesh and also compute the L2 error on this one\n    xgrid_fine = uniform_refine(xgrid,2)\n    FES_fine = FESpace{FEType}(xgrid_fine)\n    Interpolation = FEVector{Float64}(\"u_h (fine)\",FES_fine)\n    interpolate!(Interpolation[1], ON_CELLS, user_function)\n    println(\"\\t|| u - u_h (fine) ||= $(sqrt(evaluate(L2ErrorEvaluator,Interpolation[1])))\")\n\n    # evaluate/interpolate function at nodes and plot\n    if Plotter != nothing\n        nodevals = zeros(Float64,1,size(xgrid[Coordinates],2))\n        nodevalues!(nodevals,Solution[1],FES)\n        p=GridVisualizer(Plotter=Plotter,layout=(1,1))\n        scalarplot!(p[1,1],xgrid, nodevals[1,:], color=(0,1,0), label = \"coarse approximation\")\n\n        nodevals_fine = zeros(Float64,1,size(xgrid_fine[Coordinates],2))\n        nodevalues!(nodevals_fine,Interpolation[1],FES_fine)\n        scalarplot!(p[1,1],xgrid_fine, nodevals_fine[1,:], clear = false, color = (1,0,0), label = \"fine interpolation\",show=true)\n    end\nend\n\nend","category":"page"},{"location":"examples/doc_1d_bestapprox/","page":"1D L2-Bestapproximation","title":"1D L2-Bestapproximation","text":"Main.##257.Example_1DBestapprox","category":"page"},{"location":"examples/doc_1d_bestapprox/#Output-of-default-main()-run","page":"1D L2-Bestapproximation","title":"Output of default main() run","text":"","category":"section"},{"location":"examples/doc_1d_bestapprox/","page":"1D L2-Bestapproximation","title":"1D L2-Bestapproximation","text":"Example_1DBestapprox.main()","category":"page"},{"location":"examples/doc_1d_bestapprox/","page":"1D L2-Bestapproximation","title":"1D L2-Bestapproximation","text":"┌ Info: ----- Solving L2-Bestapproximation problem -----\n│ \tEquation (1.1) L2-bestapproximation equation : u >> u_h (H1P2{1,1}, ndofs = 25)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 1.420618447913876e-19\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\t|| u - u_h || = 2.2963141201221227e-5\n\t|| u - u_h (fine) ||= 3.639106661449333e-7\n","category":"page"},{"location":"examples/doc_1d_bestapprox/","page":"1D L2-Bestapproximation","title":"1D L2-Bestapproximation","text":"","category":"page"},{"location":"examples/doc_1d_bestapprox/","page":"1D L2-Bestapproximation","title":"1D L2-Bestapproximation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_2d_stokes_iterated/#D-Stokes-(iterated-penalty-method)","page":"2D Stokes (iterated penalty method)","title":"2D Stokes (iterated penalty method)","text":"","category":"section"},{"location":"examples/doc_2d_stokes_iterated/","page":"2D Stokes (iterated penalty method)","title":"2D Stokes (iterated penalty method)","text":"(source code)","category":"page"},{"location":"examples/doc_2d_stokes_iterated/","page":"2D Stokes (iterated penalty method)","title":"2D Stokes (iterated penalty method)","text":"This example computes a velocity mathbfu and pressure mathbfp of the incompressible Navier–Stokes problem","category":"page"},{"location":"examples/doc_2d_stokes_iterated/","page":"2D Stokes (iterated penalty method)","title":"2D Stokes (iterated penalty method)","text":"beginaligned\n- mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = mathbf0\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"examples/doc_2d_stokes_iterated/","page":"2D Stokes (iterated penalty method)","title":"2D Stokes (iterated penalty method)","text":"with some viscosity parameter mu.","category":"page"},{"location":"examples/doc_2d_stokes_iterated/","page":"2D Stokes (iterated penalty method)","title":"2D Stokes (iterated penalty method)","text":"Here we solve the simple Hagen-Poiseuille flow on the two-dimensional unit square domain with the iterated penalty method. Given intermediate solution  mathbfu and  p the next approximations are computed by the two equations","category":"page"},{"location":"examples/doc_2d_stokes_iterated/","page":"2D Stokes (iterated penalty method)","title":"2D Stokes (iterated penalty method)","text":"beginaligned\n(nabla mathbfu^next nabla mathbfv) + ((mathbfu^next cdot nabla) mathbfu^next mathbfv) + epsilon (mathrmdiv(mathbfu) mathrmdiv(v))  = (mathbffmathbfv) + (pmathrmdiv(mathbfv))\n textfor all  mathbfv in mathbfV\n(p^nextq)  = (pq) - (mathrmdiv(mathbfu^next)q)  textfor all  mathbfq in Q\nendaligned","category":"page"},{"location":"examples/doc_2d_stokes_iterated/","page":"2D Stokes (iterated penalty method)","title":"2D Stokes (iterated penalty method)","text":"This is done consecutively until the residual of both equations is small enough. (The convection term is linearised by auto-differentiated Newton terms.)","category":"page"},{"location":"examples/doc_2d_stokes_iterated/","page":"2D Stokes (iterated penalty method)","title":"2D Stokes (iterated penalty method)","text":"module Example_2DIteratedPenaltyStokes\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing Printf\n\n# data for Hagen-Poiseuille flow\nfunction exact_pressure!(viscosity)\n    function closure(result,x::Array{<:Real,1})\n        result[1] = viscosity*(-2*x[1]+1.0)\n    end\nend\nfunction exact_velocity!(result,x::Array{<:Real,1})\n    result[1] = x[2]*(1.0-x[2]);\n    result[2] = 0.0;\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, Plotter = nothing, nonlinear = false, div_penalty = 1e4, viscosity = 1.0)\n\n    # set verbosity level\n    set_verbosity(verbosity)\n\n    # initial grid\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D),4);\n\n    # Taylor--Hood element\n    FETypes = [H1P2{2,2}, H1P1{1}];\n\n    # negotiate data functions to the package\n    user_function_velocity = DataFunction(exact_velocity!, [2,2]; name = \"u\", dependencies = \"X\", quadorder = 2)\n    user_function_pressure = DataFunction(exact_pressure!(viscosity), [1,2]; name = \"p\", dependencies = \"X\", quadorder = 1)\n\n    # generate Stokes problem\n    Problem = PDEDescription(\"NSE (iterated penalty)\")\n    add_unknown!(Problem; equation_name = \"velocity update\", unknown_name = \"u\")\n    add_unknown!(Problem; equation_name = \"pressure update\", unknown_name = \"p\")\n    add_constraint!(Problem, FixedIntegralMean(2,0))\n\n    # add boundary data\n    add_boundarydata!(Problem, 1, [1,2,3,4], InterpolateDirichletBoundary; data = user_function_velocity)\n\n    # velocity update equation\n    add_operator!(Problem, [1,1], LaplaceOperator(viscosity; store = true))\n    add_operator!(Problem, [1,2], AbstractBilinearForm([Divergence, Identity]; name = \"(div(v),p)\", store = true, factor = -1))\n    add_operator!(Problem, [1,1], ConvectionOperator(1, Identity, 2, 2; auto_newton = true))\n    add_operator!(Problem, [1,1], AbstractBilinearForm([Divergence, Divergence]; name = \"ϵ (div(u),div(v))\", store = true, factor = div_penalty))\n\n    # pressure update equation\n    BLF_MAMA = AbstractBilinearForm([Identity, Identity]; name = \"(p,q)\")\n    add_operator!(Problem, [2,1], AbstractBilinearForm([Identity, Divergence]; name = \"(q,div(u))\", store = true, factor = div_penalty))\n    add_operator!(Problem, [2,2], BLF_MAMA)\n    add_rhsdata!(Problem, 2, restrict_operator(BLF_MAMA; fixed_arguments = [1], fixed_arguments_ids = [2]))\n\n    @show Problem\n\n    # discretise and solve problem\n    FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid; broken = true)]\n    Solution = FEVector{Float64}([\"u_h\",\"p_h\"],[FES[1],FES[2]])\n    solve!(Solution, Problem; subiterations = [[1],[2]], maxiterations = 20, show_solver_config = true)\n\n    # calculate L2 error and L2 curl error\n    L2ErrorEvaluatorV = L2ErrorIntegrator(Float64, user_function_velocity, Identity)\n    L2ErrorEvaluatorP = L2ErrorIntegrator(Float64, user_function_pressure, Identity)\n    println(\"|| u - u_h || = $(sqrt(evaluate(L2ErrorEvaluatorV,Solution[1])))\")\n    println(\"|| p - p_h || = $(sqrt(evaluate(L2ErrorEvaluatorP,Solution[2])))\")\n\n    # plot\n    GradientRobustMultiPhysics.plot(xgrid, [Solution[1], Solution[2]], [Identity, Identity]; Plotter = Plotter)\nend\nend","category":"page"},{"location":"examples/doc_2d_stokes_iterated/","page":"2D Stokes (iterated penalty method)","title":"2D Stokes (iterated penalty method)","text":"Main.##267.Example_2DIteratedPenaltyStokes","category":"page"},{"location":"examples/doc_2d_stokes_iterated/#Output-of-default-main()-run","page":"2D Stokes (iterated penalty method)","title":"Output of default main() run","text":"","category":"section"},{"location":"examples/doc_2d_stokes_iterated/","page":"2D Stokes (iterated penalty method)","title":"2D Stokes (iterated penalty method)","text":"Example_2DIteratedPenaltyStokes.main()","category":"page"},{"location":"examples/doc_2d_stokes_iterated/","page":"2D Stokes (iterated penalty method)","title":"2D Stokes (iterated penalty method)","text":"\nPDE-DESCRIPTION\n===============\n  system name = NSE (iterated penalty)\n\n     id   | unknown name / equation name\n    [1]   | u / velocity update \n    [2]   | p / pressure update \n\n  LHS block | PDEOperator(s)\n    [1,1]   | ∇(u):∇(v) (regions = [0])\n            | (u ⋅ ∇) u ⋅ v [AD-Newton] (regions = [0])\n            | ϵ (div(u),div(v)) (regions = [0])\n    [1,2]   | (div(v),p) (regions = [0])\n    [2,1]   | (q,div(u)) (regions = [0])\n    [2,2]   | (p,q) (regions = [0])\n\n  RHS block | PDEOperator(s)\n     [1]    | (u ⋅ ∇) u ⋅ v [AD-Newton] (regions = [0])\n     [2]    | (p,q) (regions = [0])\n\n   BoundaryOperator[1] : InterpolateDirichletBoundary -> [1, 2, 3, 4]\n                         \n   BoundaryOperator[2] : \n\n  GlobalConstraints[1] : Mean[2] != 0 \nProblem = \n┌ Info: ----- Solving NSE (iterated penalty) -----\n│ \tEquation (1.1) velocity update : u >> u_h (H1P2{2,2}, ndofs = 4226)\n│ \tEquation (2.2) pressure update : p >> p_h (H1P1{1} (broken), ndofs = 3072)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\nSC = \nSOLVER-CONFIGURATION\n======================\n  overall nonlinear = true\n  overall timedependent = false\n  anderson_iterations = 0\n  subiterations = [[1], [2]]\n  show_iteration_details = true\n  timedependent_equations = Any[]\n  anderson_unknowns = [1]\n  show_statistics = false\n  anderson_metric = l2\n  skip_update = [1, 1]\n  linsolver = GradientRobustMultiPhysics.LinearSystemDirectUMFPACK{Float64}\n  damping = 0\n  time = 0\n  show_solver_config = true\n  anderson_damping = 1\n  check_nonlinear_residual = true\n  fixed_penalty = 1.0e60\n  target_residual = 1.0e-10\n  maxiterations = 20\n  AssemblyTriggers = \n         LHS_AT[1] :  A  T \n         LHS_AT[2] :  T  I \n         RHS_AT[1] :  A \n         RHS_AT[2] :  A \n                     (I = Once, T = EachTimeStep/SubIteration, A = Always, N = Never)\n\n  LHS_dependencies = [[1] [1, 2]; [2, 1] [2]]\n\n\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 4.199491e-11 | 5.048465e-02\n\t      2   | 4.330189e-11 | 2.431378e-05\n\t      3   | 4.326201e-11 | 7.249697e-07\n\t      4   | 4.155748e-11 | 9.760339e-08\n\t      5   | 4.203249e-11 | 1.364189e-08\n\t      6   | 4.202485e-11 | 1.932356e-09\n\t      7   | 4.203106e-11 | 2.846068e-10\n\t      8   | 4.115005e-11 | 9.072551e-11\n┌ Info: target residual reached after 8 iterations\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1063\n\n|| u - u_h || = 6.062550723729551e-12\n|| p - p_h || = 3.609339412758741e-10\n","category":"page"},{"location":"examples/doc_2d_stokes_iterated/","page":"2D Stokes (iterated penalty method)","title":"2D Stokes (iterated penalty method)","text":"","category":"page"},{"location":"examples/doc_2d_stokes_iterated/","page":"2D Stokes (iterated penalty method)","title":"2D Stokes (iterated penalty method)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"viewers/#Export-and-Viewers","page":"Export/Viewers","title":"Export and Viewers","text":"","category":"section"},{"location":"viewers/","page":"Export/Viewers","title":"Export/Viewers","text":"Plotting is possible e.g. via calculation of nodal values and the plot routines from ExtendableGrids.jl. It is also possible to export (the nodal values) of a FEVector as a vtk datafile and load it into e.g. paraview.","category":"page"},{"location":"viewers/","page":"Export/Viewers","title":"Export/Viewers","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"plots.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"viewers/#GradientRobustMultiPhysics.plot-Tuple{ExtendableGrid, Vector{var\"#s205\"} where var\"#s205\"<:FEVectorBlock, Vector{DataType}}","page":"Export/Viewers","title":"GradientRobustMultiPhysics.plot","text":"plot(xgrid::ExtendableGrid, Sources::Vector{var\"#s205\"} where var\"#s205\"<:FEVectorBlock, operators::Vector{DataType}; add_grid_plot, Plotter, subplots_per_column, resolution, use_subplots, colorlevels, isolines, aspect, show, clear, cbar, cmap, maintitle, fsize)\n\n\nPlots operators applied to components of a given vector of FEVectorBlocks Sources (operator[j] is applied to block j) via ExtendablePlots.plot, either in one window with subplots or several single plots.\n\nPlotter = PyPlot should work in 2D Plotter = Makie should work in 3D (but only with a single plot currently)\n\n\n\n\n\n","category":"method"},{"location":"viewers/","page":"Export/Viewers","title":"Export/Viewers","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"dataexport.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"viewers/#GradientRobustMultiPhysics.writeCSV!-Tuple{String, FEVector}","page":"Export/Viewers","title":"GradientRobustMultiPhysics.writeCSV!","text":"writeCSV!(filename::String, Source::FEVector; blockids, operators, names, seperator)\n\n\nWrites the specified FEVector into a CSV datafile with the given filename. First d colomuns are the grid coordinates, the remaining column are filled with the evaluations of the operators where operator[j] is applied to Source[blockids[j]].\n\n\n\n\n\n","category":"method"},{"location":"viewers/#GradientRobustMultiPhysics.writeVTK!-Tuple{String, FEVector}","page":"Export/Viewers","title":"GradientRobustMultiPhysics.writeVTK!","text":"writeVTK!(filename::String, Data::FEVector; blocks, operators, names, vectorabs)\n\n\nWrites the specified FEVector into a vtk datafile with the given filename. Each component of each FEVectorBlock (or the subset specified by blocks) is saved separately. Vector-valued quantities also generate a data field that represents the absolute value of the vector field at each grid point.\n\n\n\n\n\n","category":"method"},{"location":"userdata/#User-Data-and-Action-Kernels","page":"User Data","title":"User Data and Action Kernels","text":"","category":"section"},{"location":"userdata/","page":"User Data","title":"User Data","text":"There is a variety of different user data, like scalar- and vector-valued constants, time-dependent data, region-dependent data or plain functions that depend on the the space coordinates. To allow for flexible user-specified data, all functions have to be negotiated by the UserData interface that fixes the order and number of dependencies.","category":"page"},{"location":"userdata/#Data-Functions","page":"User Data","title":"Data Functions","text":"","category":"section"},{"location":"userdata/","page":"User Data","title":"User Data","text":"The simplest form of user data is called DataFunction and satisfies the interface","category":"page"},{"location":"userdata/","page":"User Data","title":"User Data","text":"function data_function!(result,x::Array{<:Real,1},t::Real)\n    # definition of result, possibly dependent on\n    # X = space coordinates\n    # T = time\nend","category":"page"},{"location":"userdata/","page":"User Data","title":"User Data","text":"where the result vector carries the result of the function. Additionally, it can (but not has to) depend on the further inputs X (space coordinates) or T (time) DataFunctions can be used to define boundary data, right-hand side functions and can be interpolated by the finite element standard interpolations.","category":"page"},{"location":"userdata/","page":"User Data","title":"User Data","text":"There are also ExtendedDataFunction that can additionally depend on R (region), I (item number) and L (local coordinates). The dependencies are stated via a string in the constructor that should be a substring of \"XTRIL\". However, extended data functions cannot be used everywhere.","category":"page"},{"location":"userdata/","page":"User Data","title":"User Data","text":"DataFunction\nExtendedDataFunction","category":"page"},{"location":"userdata/#GradientRobustMultiPhysics.DataFunction","page":"User Data","title":"GradientRobustMultiPhysics.DataFunction","text":"function DataFunction(\n    f::Function,\n    dimensions::Array{Int,1};\n    name = \"user data function\",\n    dependencies::String = \"\",\n    quadorder::Int = 0)\n\nProvides a negotation interface for some user-defined function that  can be used in integrate! and boundary or right-hand side data assignments. The function f has to obey the interface\n\nf(result, [X, T])\n\nwhere the parameters X (= space coordinates) and T ( = time) are optional. Which of them are used has to be specified in the  String dependencies. The string \"X\" for example specifies that the interface is only space-dependent, i.e\n\nf(result, X)\n\nThe array dimensions specifies the expected length of result and input and quadorder determines the additional quadrature order to be used if this function is involved in some quadrature-requireing procedure.\n\n\n\n\n\n","category":"function"},{"location":"userdata/#GradientRobustMultiPhysics.ExtendedDataFunction","page":"User Data","title":"GradientRobustMultiPhysics.ExtendedDataFunction","text":"function ExtendedDataFunction(\n    f::Function,\n    dimensions::Array{Int,1};\n    name = \"user data function\",\n    dependencies::String = \"\",\n    quadorder::Int = 0)\n\nProvides a negotation interface for some data function with extended dependencies (region number, item number and local coordinates) that can be used in integrate!. The function f has to obey the interface\n\nf(result, [X, T, R, I, L])\n\nwhere the parameters X (= space coordinates) and T ( = time) are optional. Which of them are used has to be specified in the  String dependencies. The string \"X,I\" for example specifies that the interface is only space-dependent and item-dependent, i.e\n\nf(result, X, I)\n\nThe array dimensions specifies the expected length of result and X (if X-depdendent, otherwise will be ignored) and quadorder determines the additional quadrature order to be used if this function is involved in some quadrature-requireing procedure.\n\n\n\n\n\n","category":"function"},{"location":"userdata/#Action-Kernels","page":"User Data","title":"Action Kernels","text":"","category":"section"},{"location":"userdata/","page":"User Data","title":"User Data","text":"Another for of user data are action kernel used to define an AbstractAction. Actions modify arguments of Assembly Patterns (usually all but the last one) and so allow parameter-depend assemblies. To use them, the user defines some kernel function for the action that has the interface","category":"page"},{"location":"userdata/","page":"User Data","title":"User Data","text":"function action_kernel!(result,input,X,T,R,I,L)\n    # result = modified input, e.g.\n    # multiplication with some parameter that can depend on\n    # X = space coordinates\n    # T = time\n    # R = region number\n    # I = item number (cell, face or edge number depending on assembly type)\n    # L = local coordinates on item reference domain\nend","category":"page"},{"location":"userdata/","page":"User Data","title":"User Data","text":"During assembly, input (in general) takes the role of all non-testfunction arguments and the result vector will be the one that is multiplied with the testfunctions. Additionally, the kernel function can depend on X, T, R, I and L as specified above. Again, the dependencies of an action_kernel are stated via a string in the constructor that should be a substring of \"XTRIL\". Note, that the avoidance of the X-dependency spares the computation of the global coordinates of the quadrature points in the assembly loops. Moreover, time-dependency of an action kernel e.g. triggers reassembly of the associated PDEoperator in each time step.","category":"page"},{"location":"userdata/","page":"User Data","title":"User Data","text":"ActionKernel\nNLActionKernel","category":"page"},{"location":"userdata/#GradientRobustMultiPhysics.ActionKernel","page":"User Data","title":"GradientRobustMultiPhysics.ActionKernel","text":"function ActionKernel(\n    f::Function,\n    dimensions::Array{Int,1};\n    name = \"user action kernel\",\n    dependencies::String = \"\",\n    quadorder::Int = 0)\n\nProvides a negotation interface for some function that can be used in the Action constructor to define a user-defined operator action. The function has to obey the interface\n\nf(result, input, [X, T, R, I, L])\n\nwhere the parameters X (= space coordinates), T ( = time), R (= region number), I (= item number), L (= local coordinates) are optional. Which of them are used has to be specified in the String dependencies. The string \"XT\" for example specifies that the interface is only space and time dependent, i.e\n\nf(result, input, X, T)\n\nThe input vector usually provides the FunctionOperator evaluations of (a subset of) the ansatz arguments of the assembly pattern where the action is used. The array dimensions specifies the expected length of result and input and quadorder determines the additional quadrature order to be used if this function (or its derived action) is involved in an assembly process.\n\n\n\n\n\n","category":"function"},{"location":"userdata/#GradientRobustMultiPhysics.NLActionKernel","page":"User Data","title":"GradientRobustMultiPhysics.NLActionKernel","text":"function NLActionKernel(\n    f::Function,\n    dimensions::Array{Int,1};\n    name = \"nonlinear user action kernel\",\n    dependencies::String = \"\",\n    quadorder::Int = 0)\n\nProvides a negotation interface for some function to be used as a nonlinear action kernel that can be used in the NonlinearOperator constructor without automatic differentiation. The function f has to obey the interface\n\nf(result, input_current, input_ansatz)\n\nand can be seen as a linearisation of a nonlinearity that can depend on the operator evaluation of the current iterate (inputcurrent) and, as usual, the operator evaluations of the ansatz function (inputansatz).\n\nNo further dependencies are allowed currently. Note, that this is a work-in-progress feature.\n\n\n\n\n\n","category":"function"},{"location":"userdata/#Actions","page":"User Data","title":"Actions","text":"","category":"section"},{"location":"userdata/","page":"User Data","title":"User Data","text":"Actions are used by Assembly Patterns and consist of an action kernel plus some additional infratructure. To generate an action from an action kernel works via the following functions.","category":"page"},{"location":"userdata/","page":"User Data","title":"User Data","text":"Action","category":"page"},{"location":"userdata/#GradientRobustMultiPhysics.Action","page":"User Data","title":"GradientRobustMultiPhysics.Action","text":"function Action(\n    T::Type{<:Real},\n    kernel::UserData{<:AbstractActionKernel};\n    name::String = \"user action\")\n\nCreates an Action from a given specified action kernel that then can be used in an assembly pattern. T specifies the number format that should match the number format of the used quadrature rules and grid coordinates in the mesh (usually Float64).\n\n\n\n\n\nfunction Action(\n    T::Type{<:Real},\n    kernel_function::Function,\n    dimensions::Array{Int,1};\n    name = \"user action\",\n    dependencies = \"\",\n    quadorder = 0)\n\nCreates an Action directly from a kernel function (plus additional information to complement the action kernel) that then can be used in an assembly pattern. T specifies the number format that should match the number format of the used quadrature rules and grid coordinates in the mesh (usually Float64).\n\n\n\n\n\n","category":"type"},{"location":"userdata/","page":"User Data","title":"User Data","text":"Moreover, there are some shortcut action constructors that can be used directly without defining an action kernel first.","category":"page"},{"location":"userdata/","page":"User Data","title":"User Data","text":"NoAction\nMultiplyScalarAction","category":"page"},{"location":"userdata/#GradientRobustMultiPhysics.NoAction","page":"User Data","title":"GradientRobustMultiPhysics.NoAction","text":"function NoAction()\n\nCreates a NoAction that causes the assembly pattern to ignore the action assembly.\n\n\n\n\n\n","category":"type"},{"location":"userdata/#GradientRobustMultiPhysics.MultiplyScalarAction","page":"User Data","title":"GradientRobustMultiPhysics.MultiplyScalarAction","text":"function MultiplyScalarAction(value, ncomponents::Int)\n\nDirectly creates an Action that multiplies a scalar value to the input (vector of length ncomponents).\n\n\n\n\n\n","category":"function"},{"location":"examples_advanced/doc_2d_nonlin_diffeq/#D-Comparison-with-DifferentialEquations.jl","page":"2D Comparison with DifferentialEquations.jl","title":"2D Comparison with DifferentialEquations.jl","text":"","category":"section"},{"location":"examples_advanced/doc_2d_nonlin_diffeq/","page":"2D Comparison with DifferentialEquations.jl","title":"2D Comparison with DifferentialEquations.jl","text":"(source code)","category":"page"},{"location":"examples_advanced/doc_2d_nonlin_diffeq/","page":"2D Comparison with DifferentialEquations.jl","title":"2D Comparison with DifferentialEquations.jl","text":"This example computes a transient velocity mathbfu solution of the nonlinear Poisson problem","category":"page"},{"location":"examples_advanced/doc_2d_nonlin_diffeq/","page":"2D Comparison with DifferentialEquations.jl","title":"2D Comparison with DifferentialEquations.jl","text":"beginaligned\nmathbfu_t - mathrmdiv((1+betamathbfu^2) nabla mathbfu)  = mathbff\nendaligned","category":"page"},{"location":"examples_advanced/doc_2d_nonlin_diffeq/","page":"2D Comparison with DifferentialEquations.jl","title":"2D Comparison with DifferentialEquations.jl","text":"with (some time-dependent) exterior force mathbff. The parameter beta steers the strength of the nonlinearity.","category":"page"},{"location":"examples_advanced/doc_2d_nonlin_diffeq/","page":"2D Comparison with DifferentialEquations.jl","title":"2D Comparison with DifferentialEquations.jl","text":"The time integration will be performed by a solver from DifferentialEquations.jl or by the iternal backward Euler method of GradientRobustMultiPhysics. An quadratic exact solution is prescribed to test if the solver computes the exact solution. In case of  beta  0 the time integration of GradientRobustMultiPhysics performs 5 stationary nonlinear Newton subiterations (which essentially results in this particular linear-in-time example to the fact that even one timestep would be enough, so this is a rather unfair comparison).","category":"page"},{"location":"examples_advanced/doc_2d_nonlin_diffeq/","page":"2D Comparison with DifferentialEquations.jl","title":"2D Comparison with DifferentialEquations.jl","text":"Note: To run this example the DifferentialEquations.jl package has to be installed.","category":"page"},{"location":"examples_advanced/doc_2d_nonlin_diffeq/","page":"2D Comparison with DifferentialEquations.jl","title":"2D Comparison with DifferentialEquations.jl","text":"module Example_2DTransientNonlinDiffEQ\n\nusing GradientRobustMultiPhysics\nusing DifferentialEquations\nusing Printf\n\n\n# problem data\nfunction exact_solution!(result,x::Array{<:Real,1}, t)\n    result[1] = x[1]*x[2]*(1-t)\n    return nothing\nend\nfunction exact_gradient!(result,x::Array{<:Real,1}, t)\n    result[1] = x[2]\n    result[2] = x[1]\n    result .*= 1-t\n    return nothing\nend\nfunction rhs!(beta)\n    function closure(result,x::Array{<:Real,1},t)\n        result[1] = -2*beta*(x[1]^3*x[2] + x[2]^3*x[1]) # = -div(beta*u^2*grad(u))\n        result .*= (1-t)^3\n        result[1] += -x[1]*x[2] ## = u_t\n        return nothing\n    end\nend\n\n# everything is wrapped in a main function\n# the last four parametes steer the solver from DifferentialEquations.jl\n# for beta = 0, abstol and reltol can be choosen much larger\nfunction main(; verbosity = 0, Plotter = nothing, nlevels = 3, timestep = 1e-1, T = 0.5, FEType = H1P2{1,2}, beta = 1,\n    use_diffeq::Bool = true, solver = Rosenbrock23(autodiff = false), adaptive_timestep = true,  abstol = 1e-3, reltol = 1e-3)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # initial grid and final time\n    xgrid = grid_unitsquare(Triangle2D);\n\n    # negotiate data functions to the package\n    user_function = DataFunction(exact_solution!, [1,1]; name = \"u\", dependencies = \"XT\", quadorder = 5)\n    user_function_gradient = DataFunction(exact_gradient!, [2,1]; name = \"∇(u)\", dependencies = \"XT\", quadorder = 4)\n    user_function_rhs = DataFunction(rhs!(beta), [1,1]; name = \"f\", dependencies = \"XT\", quadorder = 5)\n\n    # prepare nonlinear expression (1+u^2)*grad(u)\n    function nonlin_kernel(result::Array{<:Real,1}, input::Array{<:Real,1})\n        # input = [u, grad(u)]\n        result[1] = (1+beta*input[1]^2)*input[2]\n        result[2] = (1+beta*input[1]^2)*input[3]\n        return nothing\n    end\n    action_kernel = ActionKernel(nonlin_kernel, [2,3]; dependencies = \"\", quadorder = 2)\n    nonlin_diffusion = GenerateNonlinearForm(\"(1+ β u^2) ∇(u)⋅∇(v)\", [Identity, Gradient], [1,1], Gradient, action_kernel; ADnewton = true)\n\n    # generate problem description and assign nonlinear operator and data\n    Problem = PDEDescription(beta == 0 ? \"linear Poisson problem\" : \"nonlinear Poisson problem\")\n    add_unknown!(Problem; unknown_name = \"u\", equation_name = beta == 0 ? \"linear Poisson problem\" : \"nonlinear Poisson equation\")\n    add_operator!(Problem, [1,1], beta == 0 ? LaplaceOperator() : nonlin_diffusion)\n    add_boundarydata!(Problem, 1, [1,2,3,4], BestapproxDirichletBoundary; data = user_function)\n    add_rhsdata!(Problem, 1,  RhsOperator(Identity, [0], user_function_rhs))\n\n    # define error evaluators\n    L2ErrorEvaluator = L2ErrorIntegrator(Float64, user_function, Identity; time = T)\n    H1ErrorEvaluator = L2ErrorIntegrator(Float64, user_function_gradient, Gradient; time = T)\n    L2error = []; NDofs = []; H1error = [];\n\n    # loop over levels\n    for level = 1 : nlevels\n\n        # refine grid\n        xgrid = uniform_refine(xgrid)\n\n        # generate FESpace and solution vector\n        FES = FESpace{FEType}(xgrid)\n        Solution = FEVector{Float64}(\"u_h\",FES)\n        push!(NDofs,length(Solution.entries))\n\n        # set initial solution\n        interpolate!(Solution[1], user_function)\n\n        # generate time-dependent solver\n        sys = TimeControlSolver(Problem, Solution, BackwardEuler; timedependent_equations = [1], skip_update = [beta == 0 ? -1 : 1], nonlinear_iterations = beta == 0 ? 1 : 5)\n\n        if use_diffeq == true\n            # use time integration by DifferentialEquations\n            advance_until_time!(DifferentialEquations, sys, timestep, T; solver = solver, abstol = abstol, reltol = reltol, adaptive = adaptive_timestep)\n        else\n            # use time control solver by GradientRobustMultiPhysics\n            advance_until_time!(sys, timestep, T)\n        end\n\n        # plot solution at final time\n        GradientRobustMultiPhysics.plot(xgrid, [Solution[1]], [Identity]; Plotter = Plotter)\n\n        # compute L2 and H1 error of all solutions\n        append!(L2error,sqrt(evaluate(L2ErrorEvaluator,Solution[1])))\n        append!(H1error,sqrt(evaluate(H1ErrorEvaluator,Solution[1])))\n\n        # ouput errors\n        if (level == nlevels)\n            println(\"\\n   NDOF  |   L2ERROR      order   \")\n            order = 0\n            for j=1:nlevels\n                if j > 1\n                    order = log(L2error[j-1]/L2error[j]) / (log(NDofs[j]/NDofs[j-1])/2)\n                end\n                @printf(\"  %6d |\",NDofs[j]);\n                @printf(\" %.5e \",L2error[j])\n                @printf(\"   %.3f   \\n\",order)\n            end\n            println(\"\\n   NDOF  |   H1ERROR      order   \")\n            order = 0\n            for j=1:nlevels\n                if j > 1\n                    order = log(H1error[j-1]/H1error[j]) / (log(NDofs[j]/NDofs[j-1])/2)\n                end\n                @printf(\"  %6d |\",NDofs[j]);\n                @printf(\" %.5e \",H1error[j])\n                @printf(\"   %.3f   \\n\",order)\n            end\n        end\n    end\nend\n\nend","category":"page"},{"location":"examples_advanced/doc_2d_nonlin_diffeq/","page":"2D Comparison with DifferentialEquations.jl","title":"2D Comparison with DifferentialEquations.jl","text":"","category":"page"},{"location":"examples_advanced/doc_2d_nonlin_diffeq/","page":"2D Comparison with DifferentialEquations.jl","title":"2D Comparison with DifferentialEquations.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples_advanced/doc_2d_other_linsolver/#D-User-defined-Linear-Solvers","page":"2D User-defined Linear Solvers","title":"2D User-defined Linear Solvers","text":"","category":"section"},{"location":"examples_advanced/doc_2d_other_linsolver/","page":"2D User-defined Linear Solvers","title":"2D User-defined Linear Solvers","text":"(source code)","category":"page"},{"location":"examples_advanced/doc_2d_other_linsolver/","page":"2D User-defined Linear Solvers","title":"2D User-defined Linear Solvers","text":"This example revisits the nonlinear Poisson example from the introductory examples and showcases how to define a user-specified linear solver.","category":"page"},{"location":"examples_advanced/doc_2d_other_linsolver/","page":"2D User-defined Linear Solvers","title":"2D User-defined Linear Solvers","text":"module Example_2DCustomLinSolver\n\nusing GradientRobustMultiPhysics\nusing ExtendableSparse\nusing Printf\n\n\n# first define a subtype of AbstractLinearSystem, which is later given as an optional parameter to the problem solve! call\nmutable struct MySolver{T} <: GradientRobustMultiPhysics.AbstractLinearSystem{T}\n    x::AbstractVector{T}\n    A::ExtendableSparseMatrix{T,Int64}\n    b::AbstractVector{T}\n    # add stuff here that you need e.g. for preconditioners\n    MySolver{T}(x,A,b) where {T} = new{T}(x,A,b)\nend\n\n# you need to define update! and solve! functions for your new subtype\nfunction GradientRobustMultiPhysics.update!(LS::MySolver{T}) where {T}\n    # this function is called before the solve (if other solver configuration not cause to skip it)\n    # do anything here (e.g. updating the preconditioner)\n    print(\"\\n                                            Hi! update! is called at start and every skip_update time...\")\nend\nfunction GradientRobustMultiPhysics.solve!(LS::MySolver{T}) where {T}\n    # this function is called to solve the linear system\n    print(\"\\n                                            Hi! solve! under way...\")\n    LS.x .= LS.A \\ LS.b\nend\n\n\n# problem data\nfunction exact_function!(result,x::Array{<:Real,1})\n    result[1] = x[1]*x[2]\n    return nothing\nend\nfunction exact_gradient!(result,x::Array{<:Real,1})\n    result[1] = x[2]\n    result[2] = x[1]\n    return nothing\nend\nfunction rhs!(result,x::Array{<:Real,1})\n    result[1] = -2*(x[1]^3*x[2] + x[2]^3*x[1]) # = -div((1+u^2)*grad(u))\n    return nothing\nend\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, verbosity = 0, nrefinements = 5, FEType = H1P1{1}, testmode = false, skip_update = 2)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # choose initial mesh\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D),nrefinements)\n\n    # negotiate data functions to the package\n    user_function = DataFunction(exact_function!, [1,2]; name = \"u_exact\", dependencies = \"X\", quadorder = 2)\n    user_function_gradient = DataFunction(exact_gradient!, [2,2]; name = \"grad(u_exact)\", dependencies = \"X\", quadorder = 1)\n    user_function_rhs = DataFunction(rhs!, [1,2]; dependencies = \"X\", name = \"f\", quadorder = 4)\n\n    # prepare nonlinear expression (1+u^2)*grad(u)\n    function nonlin_kernel(result::Array{<:Real,1}, input::Array{<:Real,1})\n        # input = [u, grad(u)]\n        result[1] = (1+input[1]^2)*input[2]\n        result[2] = (1+input[1]^2)*input[3]\n        return nothing\n    end\n    action_kernel = ActionKernel(nonlin_kernel, [2,3]; dependencies = \"\", quadorder = 2)\n    nonlin_diffusion = GenerateNonlinearForm(\"((1+u^2)*grad(u))*grad(v)\", [Identity, Gradient], [1,1], Gradient, action_kernel; ADnewton = true)\n\n    # generate problem description and assign nonlinear operator and data\n    Problem = PDEDescription(\"nonlinear Poisson problem\")\n    add_unknown!(Problem; unknown_name = \"u\", equation_name = \"nonlinear Poisson equation\")\n    add_operator!(Problem, [1,1], nonlin_diffusion)\n    add_boundarydata!(Problem, 1, [1,2,3,4], BestapproxDirichletBoundary; data = user_function)\n    add_rhsdata!(Problem, 1,  RhsOperator(Identity, [0], user_function_rhs; store = true))\n\n    # create finite element space and solution vector\n    FES = FESpace{FEType}(xgrid)\n    Solution = FEVector{Float64}(\"u_h\",FES)\n\n    # solve the problem (here the newly defined linear solver type is used)\n    solve!(Solution, Problem; linsolver = MySolver{Float64}, skip_update = [skip_update])\n\n    # calculate error\n    L2ErrorEvaluator = L2ErrorIntegrator(Float64, user_function, Identity)\n    H1ErrorEvaluator = L2ErrorIntegrator(Float64, user_function_gradient, Gradient)\n    println(\"\\tL2error = $(sqrt(evaluate(L2ErrorEvaluator,Solution[1])))\")\n    println(\"\\tH1error = $(sqrt(evaluate(H1ErrorEvaluator,Solution[1])))\")\n\n    # plot\n    GradientRobustMultiPhysics.plot(xgrid, [Solution[1]], [Identity]; Plotter = Plotter)\nend\n\n\nend","category":"page"},{"location":"examples_advanced/doc_2d_other_linsolver/","page":"2D User-defined Linear Solvers","title":"2D User-defined Linear Solvers","text":"","category":"page"},{"location":"examples_advanced/doc_2d_other_linsolver/","page":"2D User-defined Linear Solvers","title":"2D User-defined Linear Solvers","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_2d_lshape_adaptivity/#D-Adaptive-Mesh-Refinement-(L-shape)","page":"2D Adaptive Mesh Refinement (L-shape)","title":"2D Adaptive Mesh Refinement (L-shape)","text":"","category":"section"},{"location":"examples/doc_2d_lshape_adaptivity/","page":"2D Adaptive Mesh Refinement (L-shape)","title":"2D Adaptive Mesh Refinement (L-shape)","text":"(source code)","category":"page"},{"location":"examples/doc_2d_lshape_adaptivity/","page":"2D Adaptive Mesh Refinement (L-shape)","title":"2D Adaptive Mesh Refinement (L-shape)","text":"This example computes the standard-residual error estimator for the H^1 error e = u - u_h of some H^1-conforming approximation u_h to the solution u of some Poisson problem -Delta u = f on an L-shaped domain, i.e.","category":"page"},{"location":"examples/doc_2d_lshape_adaptivity/","page":"2D Adaptive Mesh Refinement (L-shape)","title":"2D Adaptive Mesh Refinement (L-shape)","text":"eta^2(u_h) = sum_T in mathcalT lvert T rvert  f + Delta u_h ^2_L^2(T)\n+ sum_F in mathcalF lvert F rvert  nabla u_h cdot mathbfn ^2_L^2(F)","category":"page"},{"location":"examples/doc_2d_lshape_adaptivity/","page":"2D Adaptive Mesh Refinement (L-shape)","title":"2D Adaptive Mesh Refinement (L-shape)","text":"This example script showcases the evaluation of 2nd order derivatives like the Laplacian and adaptive mesh refinement.","category":"page"},{"location":"examples/doc_2d_lshape_adaptivity/","page":"2D Adaptive Mesh Refinement (L-shape)","title":"2D Adaptive Mesh Refinement (L-shape)","text":"module Example_Lshape\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing Printf\n\n# exact solution u for the Poisson problem\nfunction exact_function!(result,x::Array{<:Real,1})\n    result[1] = atan(x[2],x[1])\n    if result[1] < 0\n        result[1] += 2*pi\n    end\n    result[1] = sin(2*result[1]/3)\n    result[1] *= (x[1]^2 + x[2]^2)^(1/3)\nend\n# ... and its gradient\nfunction exact_function_gradient!(result,x::Array{<:Real,1})\n    result[1] = atan(x[2],x[1])\n    if result[1] < 0\n        result[1] += 2*pi\n    end\n    # du/dy = du/dr * sin(phi) + (1/r) * du/dphi * cos(phi)\n    result[2] = sin(2*result[1]/3) * sin(result[1]) + cos(2*result[1]/3) * cos(result[1])\n    result[2] *= (x[1]^2 + x[2]^2)^(-1/6) * 2/3\n    # du/dx = du/dr * cos(phi) - (1/r) * du/dphi * sin(phi)\n    result[1] = sin(2*result[1]/3) * cos(result[1]) - cos(2*result[1]/3) * sin(result[1])\n    result[1] *= (x[1]^2 + x[2]^2)^(-1/6) * 2/3\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, nlevels = 20, theta = 1//3, Plotter = nothing)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # initial grid\n    xgrid = grid_lshape(Triangle2D)\n\n    # choose some finite element\n    FEType = H1P2{1,2}\n\n    # negotiate data functions to the package\n    user_function = DataFunction(exact_function!, [1,2]; name = \"u_exact\", dependencies = \"X\", quadorder = 5)\n    user_function_gradient = DataFunction(exact_function_gradient!, [2,2]; name = \"grad(u_exact)\", dependencies = \"X\", quadorder = 4)\n\n    # setup Poisson problem\n    Problem = PoissonProblem()\n    add_boundarydata!(Problem, 1, [2,3,4,5,6,7], BestapproxDirichletBoundary; data = user_function)\n    add_boundarydata!(Problem, 1, [1,8], HomogeneousDirichletBoundary)\n\n    # setup exact error evaluations\n    L2ErrorEvaluator = L2ErrorIntegrator(Float64, user_function, Identity)\n    H1ErrorEvaluator = L2ErrorIntegrator(Float64, user_function_gradient, Gradient)\n\n    # define error estimator\n    # kernel for jump term : |F| ||[[grad(u_h)*n_F]]||^2_L^2(F)\n    xFaceVolumes::Array{Float64,1} = xgrid[FaceVolumes]\n    xFaceNormals::Array{Float64,2} = xgrid[FaceNormals]\n    xCellVolumes::Array{Float64,1} = xgrid[CellVolumes]\n    function L2jump_integrand(result, input, item)\n        result[1] = ((input[1]*xFaceNormals[1,item])^2 + (input[2]*xFaceNormals[2,item])^2) * xFaceVolumes[item]\n        return nothing\n    end\n    # kernel for volume term : |T| * ||f + Laplace(u_h)||^2_L^2(T)\n    # note: f = 0 here, but integrand can also be made x-dpendent to allow for non-homogeneous rhs\n    function L2vol_integrand(result, input, item)\n        result[1] = 0\n        for j = 1 : length(input)\n            result[1] += input[j]^2 * xCellVolumes[item]\n        end\n        return nothing\n    end\n    # ... which generates an action...\n    eta_jumps_action = Action(Float64, L2jump_integrand, [1,2]; name = \"estimator kernel jumps\", dependencies = \"I\", quadorder = 2)\n    eta_vol_action = Action(Float64, L2vol_integrand, [1,2]; name = \"estimator kernel volume\", dependencies = \"I\", quadorder = 1)\n    # ... which is used inside an ItemIntegrator\n    jumpIntegrator = ItemIntegrator(Float64,ON_IFACES,[Jump(Gradient)],eta_jumps_action; name = \"η_F\")\n    volIntegrator = ItemIntegrator(Float64,ON_CELLS,[Laplacian],eta_vol_action; name = \"η_T\")\n\n    # refinement loop\n    NDofs = zeros(Int, nlevels)\n    Results = zeros(Float64, nlevels, 3)\n    Solution = nothing\n    for level = 1 : nlevels\n\n        # create a solution vector and solve the problem\n        println(\"------- LEVEL $level\")\n        FES = FESpace{FEType}(xgrid)\n        Solution = FEVector{Float64}(\"u_h\",FES)\n        solve!(Solution, Problem)\n        NDofs[level] = length(Solution[1])\n\n        # calculate local error estimator contributions\n        xFaceVolumes = xgrid[FaceVolumes]\n        xFaceNormals = xgrid[FaceNormals]\n        xCellVolumes = xgrid[CellVolumes]\n        vol_error = zeros(Float64,1,num_sources(xgrid[CellNodes]))\n        jump_error = zeros(Float64,1,num_sources(xgrid[FaceNodes]))\n        evaluate!(vol_error,volIntegrator,[Solution[1]])\n        evaluate!(jump_error,jumpIntegrator,[Solution[1]])\n\n        # calculate exact L2 error, H1 error and total estimator\n        Results[level,1] = sqrt(evaluate(L2ErrorEvaluator,[Solution[1]]))\n        Results[level,2] = sqrt(evaluate(H1ErrorEvaluator,[Solution[1]]))\n        Results[level,3] = sqrt(sum(jump_error) + sum(vol_error))\n        println(\"\\tη = $(Results[level,3])\\n\\te = $(Results[level,2])\")\n\n        if level == nlevels\n            break;\n        end\n\n        # mesh refinement\n        if theta >= 1\n            # uniform mesh refinement\n            xgrid = uniform_refine(xgrid)\n        else\n            # adaptive mesh refinement\n            # compute refinement indicators\n            nfaces = num_sources(xgrid[FaceNodes])\n            refinement_indicators = sum(jump_error, dims = 1)\n            xFaceCells = xgrid[FaceCells]\n            cell::Int = 0\n            for face = 1 : nfaces, k = 1 : 2\n                cell = xFaceCells[k,face]\n                if cell > 0\n                    refinement_indicators[face] += vol_error[1,cell]\n                end\n            end\n\n            # refine by red-green-blue refinement (incl. closuring)\n            facemarker = bulk_mark(xgrid, refinement_indicators, theta; indicator_AT = ON_FACES)\n            xgrid = RGB_refine(xgrid, facemarker)\n        end\n    end\n\n    # plot\n    GradientRobustMultiPhysics.plot(xgrid, [Solution[1]], [Identity]; add_grid_plot = true, Plotter = Plotter)\n\n    # print results\n    @printf(\"\\n  NDOFS  |   L2ERROR      order   |   H1ERROR      order   | H1-ESTIMATOR   order   \")\n    @printf(\"\\n=========|========================|========================|========================\\n\")\n    order = 0\n    for j=1:nlevels\n        @printf(\"  %6d |\",NDofs[j]);\n        for k = 1 : 3\n            if j > 1\n                order = log(Results[j-1,k]/Results[j,k]) / (log(NDofs[j]/NDofs[j-1])/2)\n            end\n            @printf(\" %.5e \",Results[j,k])\n            @printf(\"   %.3f   |\",order)\n        end\n        @printf(\"\\n\")\n    end\n\nend\n\nend","category":"page"},{"location":"examples/doc_2d_lshape_adaptivity/","page":"2D Adaptive Mesh Refinement (L-shape)","title":"2D Adaptive Mesh Refinement (L-shape)","text":"Main.##265.Example_Lshape","category":"page"},{"location":"examples/doc_2d_lshape_adaptivity/#Output-of-default-main()-run","page":"2D Adaptive Mesh Refinement (L-shape)","title":"Output of default main() run","text":"","category":"section"},{"location":"examples/doc_2d_lshape_adaptivity/","page":"2D Adaptive Mesh Refinement (L-shape)","title":"2D Adaptive Mesh Refinement (L-shape)","text":"Example_Lshape.main()","category":"page"},{"location":"examples/doc_2d_lshape_adaptivity/","page":"2D Adaptive Mesh Refinement (L-shape)","title":"2D Adaptive Mesh Refinement (L-shape)","text":"------- LEVEL 1\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 21)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 1.076401158743041e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 1.1809216557030233\n\te = 0.2076474651624387\n------- LEVEL 2\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 33)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 1.1657341758564144e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 0.7574690118747248\n\te = 0.16086233264174035\n------- LEVEL 3\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 41)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 1.560248521776408e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 0.5060512659008009\n\te = 0.12710035674542716\n------- LEVEL 4\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 67)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 1.923763753981895e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 0.3333391179306109\n\te = 0.0820803030509537\n------- LEVEL 5\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 93)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 2.0692335422473954e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 0.23308314458993296\n\te = 0.05500436313527561\n------- LEVEL 6\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 119)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 1.6233452938007536e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 0.17869532534602417\n\te = 0.03945622994399559\n------- LEVEL 7\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 159)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 2.7267381059712232e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 0.13915850782044387\n\te = 0.029372552786887583\n------- LEVEL 8\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 215)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 2.621488036222892e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 0.10982145223347517\n\te = 0.022390159079847215\n------- LEVEL 9\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 287)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 3.322808367122337e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 0.08174488804164001\n\te = 0.015716863066144327\n------- LEVEL 10\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 377)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 4.021312025623715e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 0.061643133234804595\n\te = 0.011660924169566596\n------- LEVEL 11\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 527)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 4.3512442787078964e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 0.045131254768195773\n\te = 0.008394383730370722\n------- LEVEL 12\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 729)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 5.7762643766630905e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 0.033081738690084767\n\te = 0.0061174746553588726\n------- LEVEL 13\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 1025)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 6.7008327888243124e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 0.024323647581148147\n\te = 0.004508865557953344\n------- LEVEL 14\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 1403)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 9.331491455577904e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 0.017721168129910595\n\te = 0.0031946413430606517\n------- LEVEL 15\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 1951)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 1.021435784254183e-14\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 0.01286507905625896\n\te = 0.0023110894198585708\n------- LEVEL 16\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 2685)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 1.1888477157237247e-14\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 0.009428615043435638\n\te = 0.001686587332501176\n------- LEVEL 17\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 3647)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 1.3924194627772985e-14\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 0.00694215084171859\n\te = 0.0012444240066276143\n------- LEVEL 18\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 4953)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 1.673208469766901e-14\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 0.005073360038187438\n\te = 0.0008976812517408595\n------- LEVEL 19\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 6781)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 2.0173029982121463e-14\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 0.0037228221405321894\n\te = 0.0006539955724163114\n------- LEVEL 20\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P2{1,2}, ndofs = 9271)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 2.256585891779066e-14\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tη = 0.0027250673116202134\n\te = 0.0004767733246008107\n\n  NDOFS  |   L2ERROR      order   |   H1ERROR      order   | H1-ESTIMATOR   order   \n=========|========================|========================|========================\n      21 | 2.51263e-02    0.000   | 2.07647e-01    0.000   | 1.18092e+00    0.000   |\n      33 | 1.90247e-02    1.231   | 1.60862e-01    1.130   | 7.57469e-01    1.965   |\n      41 | 1.26917e-02    3.730   | 1.27100e-01    2.171   | 5.06051e-01    3.716   |\n      67 | 4.79055e-03    3.968   | 8.20803e-02    1.781   | 3.33339e-01    1.700   |\n      93 | 2.38377e-03    4.257   | 5.50044e-02    2.441   | 2.33083e-01    2.182   |\n     119 | 1.78155e-03    2.362   | 3.94562e-02    2.695   | 1.78695e-01    2.156   |\n     159 | 1.24278e-03    2.486   | 2.93726e-02    2.037   | 1.39159e-01    1.726   |\n     215 | 7.86008e-04    3.037   | 2.23902e-02    1.799   | 1.09821e-01    1.569   |\n     287 | 4.04477e-04    4.600   | 1.57169e-02    2.450   | 8.17449e-02    2.044   |\n     377 | 3.33412e-04    1.417   | 1.16609e-02    2.189   | 6.16431e-02    2.069   |\n     527 | 1.95675e-04    3.182   | 8.39438e-03    1.963   | 4.51313e-02    1.862   |\n     729 | 1.14131e-04    3.323   | 6.11747e-03    1.950   | 3.30817e-02    1.914   |\n    1025 | 8.23682e-05    1.914   | 4.50887e-03    1.791   | 2.43236e-02    1.805   |\n    1403 | 4.27727e-05    4.175   | 3.19464e-03    2.195   | 1.77212e-02    2.018   |\n    1951 | 2.80610e-05    2.557   | 2.31109e-03    1.964   | 1.28651e-02    1.942   |\n    2685 | 1.67382e-05    3.236   | 1.68659e-03    1.973   | 9.42862e-03    1.946   |\n    3647 | 1.15905e-05    2.400   | 1.24442e-03    1.986   | 6.94215e-03    1.999   |\n    4953 | 6.26521e-06    4.020   | 8.97681e-04    2.134   | 5.07336e-03    2.049   |\n    6781 | 3.91776e-06    2.989   | 6.53996e-04    2.016   | 3.72282e-03    1.971   |\n    9271 | 2.50250e-06    2.866   | 4.76773e-04    2.021   | 2.72507e-03    1.995   |\n","category":"page"},{"location":"examples/doc_2d_lshape_adaptivity/","page":"2D Adaptive Mesh Refinement (L-shape)","title":"2D Adaptive Mesh Refinement (L-shape)","text":"","category":"page"},{"location":"examples/doc_2d_lshape_adaptivity/","page":"2D Adaptive Mesh Refinement (L-shape)","title":"2D Adaptive Mesh Refinement (L-shape)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"functionoperators/#Function-Operators","page":"Function Operators","title":"Function Operators","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"FunctionOperators are building blocks for the weak form and define the operations that should be applied to the trial and test functions (and their discrete representatives) inside some PDEOperator. Below is a list of currently available FunctionOperators. Note, that not all operators can be applied to all finite element types.","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"Function operator Description\nIdentity identity\nIdentityComponent{c} identity of c-th component\nNormalFlux normal flux (function times normal)\nTangentFlux tangent flux (function times tangent)\nGradient gradient/Jacobian (as a vector)\nSymmetricGradient symmetric part of the gradient\nDivergence divergence\nCurlScalar curl operator 1D to 2D (rotated gradient)\nCurl2D curl operator 2D to 1D\nCurl3D curl operator 3D to 3D\nHessian Hesse matrix = all 2nd order derivatives (as a vector)\nLaplacian Laplace Operator\nReconstructionIdentity{FEType} reconstruction operator into specified FEType\nReconstructionDivergence{FEType} divergence of FEType reconstruction operator\nReconstructionGradient{FEType} gradient of FEType reconstruction operator","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"note: Note\nEspecially note the operators ReconstructionIdentity{FEType} etc. that allow to evaluate operators of some reconstructed version of a vector-valued testfunction. These operators keep the discrete divergence and so allow for gradient-robust discretisations with classical non divergence-conforming ansatz spaces. So far such operators are available for the vector-valued Crouzeix-Raviart and Bernardi–Raugel finite element types.","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"note: Note\nAs each finite element type is transformed differently from the reference domain to the general domain, the evaluation of each function operator has to be implemented for each finite element class. Currently, not every function operator works in any dimension and for any finite element. More evaluations are added as soon as they are needed (and possibly upon request).","category":"page"},{"location":"functionoperators/#Jumps-and-Averages","page":"Function Operators","title":"Jumps and Averages","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"If one of the operators above is evaluted ON_FACES for a finite element that is not continuous there, the code usual will crash or produce weird results. However, some operators can be transformed into a Jump- or Average operator and then either the jumps or the average of this operator along the face is assembled. The operator Jump(Identity) for example gives the jump of the identity evaluation on both sides of the face.","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"Jump\nAverage","category":"page"},{"location":"functionoperators/#GradientRobustMultiPhysics.Jump","page":"Function Operators","title":"GradientRobustMultiPhysics.Jump","text":"function Jump(::Type{<:AbstractFunctionOperator})\n\nTransforms operator inito its jump evaluation.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#GradientRobustMultiPhysics.Average","page":"Function Operators","title":"GradientRobustMultiPhysics.Average","text":"function Average::Type{<:AbstractFunctionOperator})\n\nTransforms operator inito its average evaluation.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"note: Note\nCurrently this feature is only available for assembly on faces (2D and 3D) and certain function operators like Identity, Gradient, ReconstructionIdentity, ReconstructionGradient, NormalFlux, TangentFlux, but more are added as soon as they are needed (and possibly upon request).","category":"page"},{"location":"pdeprototypes/#PDE-Prototypes","page":"PDE Prototypes","title":"PDE Prototypes","text":"","category":"section"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Below all available prototypes (i.e. pre-defined constructors for PDEDescription) are listed.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"note: Note\nFor most prototypes boundary data and right-hand side data or other modifications to the weak form of the PDE have to be added after a proto-type constructor has been called, see the examples for further assistance.","category":"page"},{"location":"pdeprototypes/#Poisson-equation","page":"PDE Prototypes","title":"Poisson equation","text":"","category":"section"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The Poisson equation seeks a function u such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"- mu Delta u = f","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"where mu is some diffusion coefficient and f some given right-hand side data.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The (primal) weak formulation (for homogeneous Dirichlet boundary data) seeks u such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"(mu nabla unabla v)  = (fv) quad textfor all  vin H^1_0(Omega)","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"A vanilla PDEDescription for this weak formulation (without boundary data) can be created with the constructor below.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"PoissonProblem","category":"page"},{"location":"pdeprototypes/#GradientRobustMultiPhysics.PoissonProblem","page":"PDE Prototypes","title":"GradientRobustMultiPhysics.PoissonProblem","text":"function PoissonProblem(diffusion = 1.0)\n\nCreates a PDEDescription for a Poisson problem with globally constant diffusion parameter.\n\nBoundary and right-hand side data or other modifications have to be added afterwards.\n\n\n\n\n\n","category":"function"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Example-Script: 2D Convection-Diffusion-Problem","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Remarks:","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"dual weak formulations are also possible but are not available as a prototype currently","category":"page"},{"location":"pdeprototypes/#Incompressible-Navier–Stokes-equations","page":"PDE Prototypes","title":"Incompressible Navier–Stokes equations","text":"","category":"section"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The Navier–Stokes equations in d dimensions seek a (vector-valued) velocity mathbfu and a pressure p such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"beginaligned\n- mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = mathbff\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"where mu is some viscosity coefficient and f some given right-hand side data.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The weak formulation (for homogeneous Dirichlet boundary data) seeks (mathbfup) such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"beginaligned\n(mu nabla mathbfunabla mathbfv) + ((u cdot nabla) mathbfu mathbfv) + (mathrmdiv mathbfv p)  = (mathbffmathbfv)  textfor all  mathbfvin H^1_0(Omega)^d\n(mathrmdiv mathbfu q)  = 0  textfor all  q in L^2_0(Omega)\nendaligned","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"A vanilla PDEDescription for this weak formulation (without boundary data) can be created with the constructor below.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"IncompressibleNavierStokesProblem","category":"page"},{"location":"pdeprototypes/#GradientRobustMultiPhysics.IncompressibleNavierStokesProblem","page":"PDE Prototypes","title":"GradientRobustMultiPhysics.IncompressibleNavierStokesProblem","text":"function IncompressibleNavierStokesProblem(\n    dimension::Int = 2;\n    viscosity = 1.0,\n    nonlinear::Bool = false,\n    auto_newton::Bool = false,\n    nopressureconstraint::Bool = false,\n    pmean = 0)\n\nCreates a PDEDescription for the incompressible (Navier-)Stokes equations of the specified dimension and globally constant viscosity parameter. If nonlinear = true the nonlinear convection term is added to the PDEDescription. If also auto_newton = true, a Newton iteration is devised by automatic differentiation of the convection term.\n\n\n\n\n\n","category":"function"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Remarks:","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"if nonlinear == false the nonlinear convection term is not added to the equation resulting in the plain Stokes equations.\nif nopressureconstraint == true removes the integral mean constraint on the pressure.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Example-Script: 2D Hagen-Poiseuille (Navier–Stokes)","category":"page"},{"location":"pdeprototypes/#Navier-Lame-equations-(linear-elasticity)","page":"PDE Prototypes","title":"Navier-Lame equations (linear elasticity)","text":"","category":"section"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The Navier-Lame equations seek a displacement mathbfu such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"- mathrmdiv( mathbbC epsilon( mathbfu)) = mathbff","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"where epsilon( mathbfu) is the symmetric part of the gradient, mathbbC is the stiffness tensor (according to Hooke's law) and mathbff some given right-hand side data.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"In 1D, it is assumed that the stiffness tensor has the form","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"mathbbC epsilon( u) = mu nabla u","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"where mu is the elasticity modulus. In 2D, it is assumed that the stiffness tensor has the form","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"mathbbC epsilon( u) = 2 mu epsilon( mathbfu) + lambda mathrmtr(epsilon( mathbfu))","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"where mu and lambda are the Lame coefficients.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The (primal) weak formulation (for homogeneous Dirichlet boundary data) seeks u such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"(mathbbC epsilon(mathbfu)epsilon(mathbfv)) = (mathbffmathbfv) quad textfor all  vin H^1_0(Omega)^d","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"A vanilla PDEDescription for this weak formulation (without boundary data) can be created with the constructor below.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"LinearElasticityProblem","category":"page"},{"location":"pdeprototypes/#GradientRobustMultiPhysics.LinearElasticityProblem","page":"PDE Prototypes","title":"GradientRobustMultiPhysics.LinearElasticityProblem","text":"function LinearElasticityProblem(\n    dimension::Int = 2;\n    elasticity_modulus = 1.0,\n    shear_modulus = 1.0,\n    lambda = 1.0)\n\nCreates a PDEDescription for the linear elasticity problem of the specified dimension.\n\nIf dimension == 1, only the elasticitymodulus is used as a parameter in the Hookian stiffness operator. If dimension == 2, shearmodulus and lambda are used as Lame parameters in the Hookian stiffness operator.\n\nBoundary and right-hand side data or other modifications have to be added afterwards.\n\n\n\n\n\n","category":"function"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Example-Scripts: 2D Linear Elasticity","category":"page"},{"location":"pdeprototypes/#L2-Bestapproximation","page":"PDE Prototypes","title":"L2-Bestapproximation","text":"","category":"section"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"This PDEDescription can be used to setup an L2-Bestapproximation very fast. The weak formulation simply seeks some function u such that, for some given function u_textexact, it holds u = u_textexact along the (specified) boundary and","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"(uv) = (u_textexactv) quad textfor all  vin L^2(Omega)","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Of course, on the continuous level, it holds u = u_textexact, but if the weak formulation is assembled for a finite element space one obtains a discrete L2-bestapproximation for this space.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"L2BestapproximationProblem","category":"page"},{"location":"pdeprototypes/#GradientRobustMultiPhysics.L2BestapproximationProblem","page":"PDE Prototypes","title":"GradientRobustMultiPhysics.L2BestapproximationProblem","text":"function L2BestapproximationProblem(\n    uexact::UserData{AbstractDataFunction};\n    bonus_quadorder::Int = 0,\n    bestapprox_boundary_regions = [])\n\nCreates an PDEDescription for an L2-Bestapproximation problem for the given exact function. Since this prototype already includes boundary and right-hand side data also a bonus quadrature order can be specified to steer the accuracy.\n\n\n\n\n\n","category":"function"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Example-Scripts: 3D Divergence-Preserving L2-Bestapproximation","category":"page"},{"location":"pdeprototypes/#H1-Bestapproximation","page":"PDE Prototypes","title":"H1-Bestapproximation","text":"","category":"section"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"This PDEDescription can be used to setup an H1-Bestapproximation very fast. The weak formulation simply seeks some function u such that, for some given function u_textexact, it holds u = u_textexact along the (specified) boundary and","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"(nabla unabla v) = (nabla u_textexact nabla v) quad textfor all  vin H^1_0(Omega)","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"H1BestapproximationProblem","category":"page"},{"location":"pdeprototypes/#GradientRobustMultiPhysics.H1BestapproximationProblem","page":"PDE Prototypes","title":"GradientRobustMultiPhysics.H1BestapproximationProblem","text":"function H1BestapproximationProblem(\n    exact_function_gradient::UserData{AbstractDataFunction},\n    exact_function_boundary::UserData{AbstractDataFunction};\n    bonus_quadorder::Int = 0,\n    bonus_quadorder_boundary::Int = 0,\n    bestapprox_boundary_regions = [])\n\nCreates an PDEDescription for an H1-Bestapproximation problem for the given exact function (only used on the boundary) and its exact gradient (used in the right-hand side). Since this prototype already includes boundary and right-hand side data also a bonus quadrature order can be specified to steer the accuracy.\n\n\n\n\n\n","category":"function"},{"location":"examples/doc_2d_nonlin_poisson/#D-Nonlinear-Poisson-Problem","page":"2D Nonlinear Poisson-Problem","title":"2D Nonlinear Poisson-Problem","text":"","category":"section"},{"location":"examples/doc_2d_nonlin_poisson/","page":"2D Nonlinear Poisson-Problem","title":"2D Nonlinear Poisson-Problem","text":"(source code)","category":"page"},{"location":"examples/doc_2d_nonlin_poisson/","page":"2D Nonlinear Poisson-Problem","title":"2D Nonlinear Poisson-Problem","text":"This example computes the solution u of the nonlinear Poisson problem","category":"page"},{"location":"examples/doc_2d_nonlin_poisson/","page":"2D Nonlinear Poisson-Problem","title":"2D Nonlinear Poisson-Problem","text":"beginaligned\n-mathrmdiv((1+u^2) nabla u)  = f quad textin  Omega\nendaligned","category":"page"},{"location":"examples/doc_2d_nonlin_poisson/","page":"2D Nonlinear Poisson-Problem","title":"2D Nonlinear Poisson-Problem","text":"with some right-hand side f on a series of uniform refinements of the unit square Omega.","category":"page"},{"location":"examples/doc_2d_nonlin_poisson/","page":"2D Nonlinear Poisson-Problem","title":"2D Nonlinear Poisson-Problem","text":"This example demonstrates the automatic differentation feature and explains how to setup a nonlinear expression and how to assign it to the problem description. The setup is tested with some manufactured quadratic solution.","category":"page"},{"location":"examples/doc_2d_nonlin_poisson/","page":"2D Nonlinear Poisson-Problem","title":"2D Nonlinear Poisson-Problem","text":"module Example_2DNonlinearPoisson\n\nusing GradientRobustMultiPhysics\nusing Printf\n\n# problem data\nfunction exact_function!(result,x::Array{<:Real,1})\n    result[1] = x[1]*x[2]\n    return nothing\nend\nfunction exact_gradient!(result,x::Array{<:Real,1})\n    result[1] = x[2]\n    result[2] = x[1]\n    return nothing\nend\nfunction rhs!(result,x::Array{<:Real,1})\n    result[1] = -2*(x[1]^3*x[2] + x[2]^3*x[1]) # = -div((1+u^2)*grad(u))\n    return nothing\nend\n\n# everything is wrapped in a main function\n# default argument trigger P1-FEM calculation, you might also want to try H1P2{1,2}\nfunction main(; Plotter = nothing, verbosity = 0, nlevels = 6, FEType = H1P1{1}, testmode = false)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # choose initial mesh\n    xgrid = grid_unitsquare(Triangle2D)\n\n    # negotiate data functions to the package\n    user_function = DataFunction(exact_function!, [1,2]; name = \"u_exact\", dependencies = \"X\", quadorder = 2)\n    user_function_gradient = DataFunction(exact_gradient!, [2,2]; name = \"grad(u_exact)\", dependencies = \"X\", quadorder = 1)\n    user_function_rhs = DataFunction(rhs!, [1,2]; dependencies = \"X\", name = \"f\", quadorder = 4)\n\n    # prepare nonlinear expression (1+u^2)*grad(u)\n    function nonlin_kernel(result::Array{<:Real,1}, input::Array{<:Real,1})\n        # input = [u, grad(u)]\n        result[1] = (1+input[1]^2)*input[2]\n        result[2] = (1+input[1]^2)*input[3]\n        return nothing\n    end\n    action_kernel = ActionKernel(nonlin_kernel, [2,3]; dependencies = \"\", quadorder = 2)\n    nonlin_diffusion = GenerateNonlinearForm(\"((1+u^2)*grad(u))*grad(v)\", [Identity, Gradient], [1,1], Gradient, action_kernel; ADnewton = true)\n\n    # generate problem description and assign nonlinear operator and data\n    Problem = PDEDescription(\"nonlinear Poisson problem\")\n    add_unknown!(Problem; unknown_name = \"u\", equation_name = \"nonlinear Poisson equation\")\n    add_operator!(Problem, [1,1], nonlin_diffusion)\n    add_boundarydata!(Problem, 1, [1,2,3,4], BestapproxDirichletBoundary; data = user_function)\n    add_rhsdata!(Problem, 1,  RhsOperator(Identity, [0], user_function_rhs; store = true))\n    @show Problem\n\n    # prepare error calculation\n    L2ErrorEvaluator = L2ErrorIntegrator(Float64, user_function, Identity)\n    H1ErrorEvaluator = L2ErrorIntegrator(Float64, user_function_gradient, Gradient)\n    L2error = []; H1error = []; NDofs = []\n\n    # loop over levels\n    Solution = nothing\n    for level = 1 : nlevels\n        # uniform mesh refinement\n        xgrid = uniform_refine(xgrid)\n\n        # create finite element space and solution vector\n        FES = FESpace{FEType}(xgrid)\n        Solution = FEVector{Float64}(\"u_h\",FES)\n        push!(NDofs,length(Solution.entries))\n\n        # solve\n        solve!(Solution, Problem)\n\n        # calculate L2 and H1 error\n        append!(L2error,sqrt(evaluate(L2ErrorEvaluator,Solution[1])))\n        append!(H1error,sqrt(evaluate(H1ErrorEvaluator,Solution[1])))\n    end\n\n    if testmode == true\n        return H1error[end]\n    else\n        # output errors in a nice table\n        println(\"\\n   NDOF  |   L2ERROR   |   H1ERROR\")\n        for j=1:nlevels\n            @printf(\"  %6d | %.5e | %.5e\\n\",NDofs[j],L2error[j],H1error[j]);\n        end\n\n        # plot\n        GradientRobustMultiPhysics.plot(xgrid, [Solution[1], Solution[1]], [Identity, Gradient]; Plotter = Plotter)\n    end\nend\n\n\n# test function that is called by test unit\n# tests if the above problem is solved exactly by P2-FEM\nfunction test()\n    return main(; FEType = H1P2{1,2}, nlevels = 1, testmode = true)\nend\n\nend","category":"page"},{"location":"examples/doc_2d_nonlin_poisson/","page":"2D Nonlinear Poisson-Problem","title":"2D Nonlinear Poisson-Problem","text":"Main.##266.Example_2DNonlinearPoisson","category":"page"},{"location":"examples/doc_2d_nonlin_poisson/#Output-of-default-main()-run","page":"2D Nonlinear Poisson-Problem","title":"Output of default main() run","text":"","category":"section"},{"location":"examples/doc_2d_nonlin_poisson/","page":"2D Nonlinear Poisson-Problem","title":"2D Nonlinear Poisson-Problem","text":"Example_2DNonlinearPoisson.main()","category":"page"},{"location":"examples/doc_2d_nonlin_poisson/","page":"2D Nonlinear Poisson-Problem","title":"2D Nonlinear Poisson-Problem","text":"\nPDE-DESCRIPTION\n===============\n  system name = nonlinear Poisson problem\n\n     id   | unknown name / equation name\n    [1]   | u / nonlinear Poisson equation \n\n  LHS block | PDEOperator(s)\n    [1,1]   | ((1+u^2)*grad(u))*grad(v) [AD-Newton] (regions = [0])\n\n  RHS block | PDEOperator(s)\n     [1]    | ((1+u^2)*grad(u))*grad(v) [AD-Newton] (regions = [0])\n            | f⋅id(v) (regions = [0])\n\n   BoundaryOperator[1] : BestapproxDirichletBoundary -> [1, 2, 3, 4]\n                         \n\nProblem = \n┌ Info: ----- Solving nonlinear Poisson problem -----\n│ \tEquation (1.1) nonlinear Poisson equation : u >> u_h (H1P1{1}, ndofs = 13)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 1.276908e-16 | 1.879348e-01\n\t      2   | 3.851086e-16 | 2.427676e-03\n\t      3   | 5.946535e-16 | 3.580510e-07\n\t      4   | 4.601466e-16 | 7.822889e-15\n\n┌ Info: ----- Solving nonlinear Poisson problem -----\n│ \tEquation (1.1) nonlinear Poisson equation : u >> u_h (H1P1{1}, ndofs = 41)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 5.090761e-16 | 1.552235e-01\n\t      2   | 1.574813e-15 | 1.898915e-03\n\t      3   | 7.804491e-16 | 4.461316e-07\n\t      4   | 9.757558e-16 | 2.427919e-14\n\n┌ Info: ----- Solving nonlinear Poisson problem -----\n│ \tEquation (1.1) nonlinear Poisson equation : u >> u_h (H1P1{1}, ndofs = 145)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 1.617567e-15 | 9.834582e-02\n\t      2   | 2.029907e-15 | 1.307935e-03\n\t      3   | 2.588613e-15 | 4.214647e-07\n\t      4   | 2.673392e-15 | 2.959779e-14\n\n┌ Info: ----- Solving nonlinear Poisson problem -----\n│ \tEquation (1.1) nonlinear Poisson equation : u >> u_h (H1P1{1}, ndofs = 545)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 2.551629e-15 | 5.522608e-02\n\t      2   | 4.309093e-15 | 8.487585e-04\n\t      3   | 4.691619e-15 | 2.555420e-07\n\t      4   | 4.473037e-15 | 2.204795e-14\n\n┌ Info: ----- Solving nonlinear Poisson problem -----\n│ \tEquation (1.1) nonlinear Poisson equation : u >> u_h (H1P1{1}, ndofs = 2113)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 4.859175e-15 | 2.924738e-02\n\t      2   | 9.307164e-15 | 4.905172e-04\n\t      3   | 9.396160e-15 | 1.346748e-07\n\t      4   | 9.212018e-15 | 1.924776e-14\n\n┌ Info: ----- Solving nonlinear Poisson problem -----\n│ \tEquation (1.1) nonlinear Poisson equation : u >> u_h (H1P1{1}, ndofs = 8321)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 9.805278e-15 | 1.504798e-02\n\t      2   | 1.835402e-14 | 2.640269e-04\n\t      3   | 1.910704e-14 | 6.824838e-08\n\t      4   | 1.890690e-14 | 3.171000e-14\n\n\n   NDOF  |   L2ERROR   |   H1ERROR\n      13 | 6.62330e-03 | 1.44378e-01\n      41 | 1.65803e-03 | 7.21744e-02\n     145 | 4.14699e-04 | 3.60851e-02\n     545 | 1.03688e-04 | 1.80423e-02\n    2113 | 2.59229e-05 | 9.02111e-03\n    8321 | 6.48078e-06 | 4.51055e-03\n","category":"page"},{"location":"examples/doc_2d_nonlin_poisson/","page":"2D Nonlinear Poisson-Problem","title":"2D Nonlinear Poisson-Problem","text":"","category":"page"},{"location":"examples/doc_2d_nonlin_poisson/","page":"2D Nonlinear Poisson-Problem","title":"2D Nonlinear Poisson-Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"quadrature/#Quadrature","page":"Quadrature","title":"Quadrature","text":"","category":"section"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"Quadrature rules consist of points (coordinates of evauation points with respect to reference geometry) and weights. There are constructors for several AbstractElementGeometries (from ExtendableGrids) and different order (some have generic formulas for abitrary order), see below for a detailed list.","category":"page"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"quadrature.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"abstract type QuadratureRule{T<:Real, ET<:AbstractElementGeometry}\n\nA struct that contains the name of the quadrature rule, the reference points and the weights for the parameter-determined element geometry.\n\n\n\n\n\n","category":"type"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:AbstractElementGeometry0D}","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: AbstractElementGeometry0D}\n\nConstructs 0D quadrature rule of specified order (always point evaluation).\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:AbstractElementGeometry1D}","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: AbstractElementGeometry1D}\n\nConstructs 1D quadrature rule of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:Parallelepiped3D}","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Parallelepiped3D}\n\nConstructs quadrature rule on Parallelepiped3D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:Parallelogram2D}","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Parallelogram2D}\n\nConstructs quadrature rule on Parallelogram2D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:Tetrahedron3D}","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Tetrahedron3D}\n\nConstructs quadrature rule on Tetrahedron3D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:Triangle2D}","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Triangle2D}\n\nConstructs quadrature rule on Triangle2D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#Base.eltype-Union{Tuple{QuadratureRule{T, ET}}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:AbstractElementGeometry}","page":"Quadrature","title":"Base.eltype","text":"eltype(_::QuadratureRule{T<:Real, ET<:AbstractElementGeometry}) -> Vector{_A} where _A\n\n\nCustom eltype function for QuadratureRule{T,ET}.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#Base.show-Tuple{IO, QuadratureRule}","page":"Quadrature","title":"Base.show","text":"show(io::IO, Q::QuadratureRule)\n\n\nCustom show function for QuadratureRule{T,ET} that prints some information.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.integrate!-Tuple{AbstractArray, ExtendableGrid, Type{var\"#s114\"} where var\"#s114\"<:AbstractAssemblyType, UserData{var\"#s113\", ndim} where {var\"#s113\"<:AbstractDataFunction, ndim}}","page":"Quadrature","title":"GradientRobustMultiPhysics.integrate!","text":"integrate!(integral4items::AbstractArray, grid::ExtendableGrid, AT::Type{var\"#s114\"} where var\"#s114\"<:AbstractAssemblyType, integrand::UserData{var\"#s113\", ndim} where {var\"#s113\"<:AbstractDataFunction, ndim}; index_offset, time, items, force_quadrature_rule)\n\n\nIntegration that writes result on every item into integral4items.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.integrate-Tuple{ExtendableGrid, Type{var\"#s181\"} where var\"#s181\"<:AbstractAssemblyType, UserData{var\"#s180\", ndim} where {var\"#s180\"<:AbstractDataFunction, ndim}, Int64}","page":"Quadrature","title":"GradientRobustMultiPhysics.integrate","text":"integrate(grid::ExtendableGrid, AT::Type{var\"#s181\"} where var\"#s181\"<:AbstractAssemblyType, integrand!::UserData{var\"#s180\", ndim} where {var\"#s180\"<:AbstractDataFunction, ndim}, resultdim::Int64; items, force_quadrature_rule) -> Union{Float64, Vector{Float64}}\n\n\nIntegration that returns total integral.\n\n\n\n\n\n","category":"method"},{"location":"examples/doc_2d_commutinginterpolators/#Commuting-Interpolators-(2D)","page":"Commuting Interpolators (2D)","title":"Commuting Interpolators (2D)","text":"","category":"section"},{"location":"examples/doc_2d_commutinginterpolators/","page":"Commuting Interpolators (2D)","title":"Commuting Interpolators (2D)","text":"(source code) (execute)","category":"page"},{"location":"examples/doc_2d_commutinginterpolators/","page":"Commuting Interpolators (2D)","title":"Commuting Interpolators (2D)","text":"This example verifies a structural property of the H1 and Hdiv finite element spaces and their interpolators which is","category":"page"},{"location":"examples/doc_2d_commutinginterpolators/","page":"Commuting Interpolators (2D)","title":"Commuting Interpolators (2D)","text":"mathrmCurl(I_mathrmP_kpsi) = I_mathrmRT_k-1(mathrmCurl(psi))","category":"page"},{"location":"examples/doc_2d_commutinginterpolators/","page":"Commuting Interpolators (2D)","title":"Commuting Interpolators (2D)","text":"for the H_1 interpolator I_mathrmP_k and the standard Raviart-Thomas interpolator I_mathrmRT_k-1 for k  0. In this example we verify this identity for k=1 and k=2. Note, that the H_1 interpolator only does nodal interpolations at the vertices but not in the additional degrees of freedom. For k=2, the interpolator also preserves the moments along the edges.","category":"page"},{"location":"examples/doc_2d_commutinginterpolators/","page":"Commuting Interpolators (2D)","title":"Commuting Interpolators (2D)","text":"module Example_2DCommutingInterpolators\n\nusing GradientRobustMultiPhysics\n\n# define some function\nfunction exact_function!(result,x::Array{<:Real,1})\n    result[1] = x[1]^2-x[2]^4 + 1\nend\n# and its CurlScalar = (-dy,dx)\nfunction exact_curl!(result,x::Array{<:Real,1})\n    result[1] = 4*x[2]^3\n    result[2] = 2*x[1]\nend\n\n# everything is wrapped in a main function\nfunction main(;order::Int = 2, testmode = false)\n\n    # choose some grid\n    xgrid = uniform_refine(reference_domain(Triangle2D),2)\n\n    # negotiate exact_function! and exact_curl! to the package\n    user_function = DataFunction(exact_function!, [1,2]; name = \"u_exact\", dependencies = \"X\", quadorder = 4)\n    user_function_curl = DataFunction(exact_curl!, [2,2]; name = \"Curl(u_exact)\", dependencies = \"X\", quadorder = 3)\n\n    # choose commuting interpolators pair\n    if order == 1\n        FE = [H1P1{1},HDIVRT0{2}]; testFE = H1P0{2}\n    elseif order == 2\n        FE = [H1P2{1,2},HDIVRT1{2}]; testFE = H1P1{2}\n    end\n\n    # do the H1 interpolation of the function\n    FESH1 = FESpace{FE[1]}(xgrid)\n    H1Interpolation = FEVector{Float64}(\"H1-Interpolation\",FESH1)\n    interpolate!(H1Interpolation[1], user_function)\n\n    # do the Hdiv interpolation of the Curl of the function\n    # since integrals over faces have to be computed exactly we need to tune the quadrature order\n    FESHdiv = FESpace{FE[2]}(xgrid)\n    HdivCurlInterpolation = FEVector{Float64}(\"Hdiv-Interpolation\",FESHdiv)\n    interpolate!(HdivCurlInterpolation[1], user_function_curl)\n\n    # Checking the identity:\n    # Both sides of the identity are finite element function of FEtype testFE\n    # Hence, we evaluate the error by testing the identity by all basisfunctions of this type\n\n    # first: generate the test space and some matching FEVector\n    FEStest = FESpace{testFE}(xgrid; broken = true)\n    error = FEVector{Float64}(\"ErrorVector\",FEStest)\n\n    # Define bilinear forms that represents testing each side of the identity with the testspace functions\n    BLF1 = BilinearForm(Float64, ON_CELLS, [FEStest, FESHdiv], [Identity, Identity])\n    BLF2 = BilinearForm(Float64, ON_CELLS, [FEStest, FESH1], [Identity, CurlScalar])\n\n    # evaluate the bilinear forms in the respective interpolations and subtract them from each other\n    # note that in these calls always the second argument of the bilinearform is fixed by the given FEVectorBlock\n    assemble!(error[1], BLF1, HdivCurlInterpolation[1]; fixed_arguments = [2])\n    assemble!(error[1], BLF2, H1Interpolation[1]; factor = -1, fixed_arguments = [2])\n\n    # do some norm that recognizes a nonzero in the vector\n    error = sqrt(sum(error[1][:].^2, dims = 1)[1])\n    if testmode == true\n        return error\n    else\n        println(\"error(Curl(I_$(FE[1])(psi) - I_$(FE[2])(Curl(psi))) = $error\")\n    end\nend\n\n# test function that is called by test unit\nfunction test()\n    error = []\n    for order in [1,2]\n        push!(error, max(main(order = order, testmode = true)))\n    end\n    return maximum(error)\nend\n\nend","category":"page"},{"location":"examples/doc_2d_commutinginterpolators/","page":"Commuting Interpolators (2D)","title":"Commuting Interpolators (2D)","text":"Main.##259.Example_2DCommutingInterpolators","category":"page"},{"location":"examples/doc_2d_commutinginterpolators/#Output-of-default-main()-run","page":"Commuting Interpolators (2D)","title":"Output of default main() run","text":"","category":"section"},{"location":"examples/doc_2d_commutinginterpolators/","page":"Commuting Interpolators (2D)","title":"Commuting Interpolators (2D)","text":"Example_2DCommutingInterpolators.main()","category":"page"},{"location":"examples/doc_2d_commutinginterpolators/","page":"Commuting Interpolators (2D)","title":"Commuting Interpolators (2D)","text":"error(Curl(I_H1P2{1,2}(psi) - I_HDIVRT1{2}(Curl(psi))) = 1.6883384559505932e-16\n","category":"page"},{"location":"examples/doc_2d_commutinginterpolators/","page":"Commuting Interpolators (2D)","title":"Commuting Interpolators (2D)","text":"","category":"page"},{"location":"examples/doc_2d_commutinginterpolators/","page":"Commuting Interpolators (2D)","title":"Commuting Interpolators (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"pdedescription/#PDE-Description","page":"PDE Description","title":"PDE Description","text":"","category":"section"},{"location":"pdedescription/#Purpose","page":"PDE Description","title":"Purpose","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Although a more manually low-level assembly of your problem is possible, it is advised to describe it in the form of a PDEDescription to get access to certain automated mechanisms (in particular concerning fixpoint solvers).","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"The PDEDescription has similarities with the weak form of your problem (without time derivatives that are added separately by TimeControlSolver) and in general does not need any information on the discretisation at this point.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"The following flow chart summarises the assemble process that is run during the solve process. The green parts can be modified/specified by the user, the rest is handled automatically. For details on steering the solver see PDE Solvers","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"(Image: Assembly Flowchart) ","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"PDEDescription\nBase.show(io::IO, PDE::PDEDescription)","category":"page"},{"location":"pdedescription/#GradientRobustMultiPhysics.PDEDescription","page":"PDE Description","title":"GradientRobustMultiPhysics.PDEDescription","text":"mutable struct PDEDescription\n    name::String\n    equation_names::Array{String,1}\n    unknown_names::Array{String,1}\n    LHS::Array{Array{AbstractPDEOperator,1},2}\n    RHS::Array{Array{AbstractPDEOperator,1},1}\n    BoundaryOperators::Array{BoundaryOperator,1}\n    GlobalConstraints::Array{AbstractGlobalConstraint,1}\nend\n\nstruct that describes a PDE system with n equations and n unknowns\n\nA PDE system is described by\n\nits name\nthe names of its equations\nthe names of its unknowns\na size n x n array of Array{AbstractPDEOperator,1} LHS that describes the left-hand sides\na length n array of Array{AbstractPDEOperator,1} RHS that describes the right-hand sides\na length n array of BoundaryOperators that describes the boundary conditions for each unknown\nan array of GlobalConstraints that describes additional global constraints\n\nA PDEDescription mainly is a set of PDEOperators arranged in a quadratic n by n matrix. Every matrix row refers to one equation and the positioning of the PDEOperators (e.g. a bilinearform) immediately sets the information which unknowns have to be used to evaluate the operator. Also  nonlinear PDEOperators are possible where extra information on the further involved uknowns have to be specified. UserData is also assigned to the PDEDescription depending on their type. Operator coefficients are assigned directly to the PDEOperators (in form of AbstractActions), right-hand side data is assigned to the right-hand side array of PDEOperators and boundary data is assigned to the BoundaryOperators of the PDEDescription. Additionaly global constraints (like a global zero integral mean) can be assigned as a GlobalConstraint.\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/#Base.show-Tuple{IO, PDEDescription}","page":"PDE Description","title":"Base.show","text":"show(io::IO, PDE::PDEDescription)\n\n\nCustom show function for PDEDescription that prints the PDE systems and all assigned operators\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#Creating/Extending-a-PDEDescription","page":"PDE Description","title":"Creating/Extending a PDEDescription","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Several add...! functions allow to extend the problems at any stage. There are several prototype PDEs documented on the PDE Prototypes page that can be used as a point of departure. Below is a list of functions that allows to initialise and extend a PDEDescription.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"pdedescription.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"pdedescription/#GradientRobustMultiPhysics.PDEDescription-Tuple{String, Int64}","page":"PDE Description","title":"GradientRobustMultiPhysics.PDEDescription","text":"PDEDescription(name::String, nunknowns::Int64; unknown_names, equation_names) -> PDEDescription\n\n\nCreate empty PDEDescription for a specified number of unknowns.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.PDEDescription-Tuple{String}","page":"PDE Description","title":"GradientRobustMultiPhysics.PDEDescription","text":"PDEDescription(name::String) -> PDEDescription\n\n\nCreate empty PDEDescription with no unknowns.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_boundarydata!-Tuple{PDEDescription, Int64, Any, Type{var\"#s600\"} where var\"#s600\"<:AbstractBoundaryType}","page":"PDE Description","title":"GradientRobustMultiPhysics.add_boundarydata!","text":"add_boundarydata!(PDE::PDEDescription, position::Int64, regions::Any, btype::Type{var\"#s600\"} where var\"#s600\"<:AbstractBoundaryType; data)\n\n\nAdds the given boundary data with the specified AbstractBoundaryType at the specified position in the BoundaryOperator of the PDEDescription.\n\nIf timedependent == true, that data function depends also on time t and is reassembled in any advance! step of a TimeControlSolver.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_constraint!-Tuple{PDEDescription, AbstractGlobalConstraint}","page":"PDE Description","title":"GradientRobustMultiPhysics.add_constraint!","text":"add_constraint!(PDE::PDEDescription, GC::AbstractGlobalConstraint)\n\n\nAdds the given global constraint to the PDEDescription.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_operator!-Tuple{PDEDescription, Vector{Int64}, AbstractPDEOperator}","page":"PDE Description","title":"GradientRobustMultiPhysics.add_operator!","text":"add_operator!(PDE::PDEDescription, position::Vector{Int64}, O::AbstractPDEOperator; equation_name)\n\n\nAdds the given abstract PDEOperator to the left-hand side of the PDEDescription at the specified position.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_operator!-Tuple{PDEDescription, Vector{Int64}, GradientRobustMultiPhysics.PDEOperator}","page":"PDE Description","title":"GradientRobustMultiPhysics.add_operator!","text":"add_operator!(PDE::PDEDescription, position::Vector{Int64}, O::GradientRobustMultiPhysics.PDEOperator; equation_name)\n\n\nAdds the given PDEOperator to the left-hand side of the PDEDescription at the specified position. Optionally, the name of the equation can be changed.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_rhsdata!-Tuple{PDEDescription, Int64, AbstractPDEOperator}","page":"PDE Description","title":"GradientRobustMultiPhysics.add_rhsdata!","text":"add_rhsdata!(PDE::PDEDescription, position::Int64, O::AbstractPDEOperator)\n\n\nAdds the given PDEOperator to the right-hand side of the PDEDescription at the specified position.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_unknown!-Tuple{PDEDescription}","page":"PDE Description","title":"GradientRobustMultiPhysics.add_unknown!","text":"add_unknown!(PDE::PDEDescription; equation_name, unknown_name)\n\n\nAdds another unknown to the PDEDescription.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#PDE-Operators","page":"PDE Description","title":"PDE Operators","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"The PDE consists of PDEOperators characterising some feature of the model (like friction, convection, exterior forces etc.), they describe the continuous weak form of the PDE. ","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"GradientRobustMultiPhysics.PDEOperator","category":"page"},{"location":"pdedescription/#GradientRobustMultiPhysics.PDEOperator","page":"PDE Description","title":"GradientRobustMultiPhysics.PDEOperator","text":"mutable struct PDEOperator{T<:Real, APT<:AssemblyPatternType, AT<:AbstractAssemblyType} <: AbstractPDEOperator\n\ncommon structures for all finite element operators that are assembled with GradientRobustMultiPhysics; better look at the AssemblyPatternType and the constructors\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"The following table lists all available operators and physics-motivated constructors for them. Click on them or scroll down to find out more details.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Main constructors Special constructors Mathematically\nAbstractBilinearForm  (mathrmA(mathrmFO_1(u))mathrmFO_2(v)) or (mathrmFO_1(u)mathrmA(mathrmFO_2(v)))\n LaplaceOperator (kappa nabla unabla v)\n ReactionOperator (alpha u v)\n LagrangeMultiplier (mathrmFO_1(u) v) (automatically assembles 2nd transposed block)\n ConvectionOperator (beta cdot nabla u v) (beta is function)\n HookStiffnessOperator2D (mathbbC epsilon(u)epsilon(v)) (also 1D or 3D variants exist)\nAbstractTrilinearForm  (mathrmA(mathrmFO_1(a)mathrmFO_2(u))mathrmFO_3(v))\n ConvectionOperator ((a cdot nabla) u v) (a is registered unknown)\n ConvectionRotationFormOperator ((a times nabla) uv) (a is registered unknown, only 2D for now)\nGenerateNonlinearForm  (mathrmNA(mathrmFO_1(u)mathrmFO_N-1(u))mathrmFO_N(v))\nRhsOperator  (f cdot mathrmFO(v))","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Legend: mathrmFO  are placeholders for Function Operators, and mathrmA stands for a (linear) Actions (that only expects the operator value of the finite element function as an input) and mathrmNA stands for a (nonlinear) Actions (see GenerateNonlinearForm for details).","category":"page"},{"location":"pdedescription/#Common-Operators","page":"PDE Description","title":"Common Operators","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Below you find the special constructors of available common linear, bilinear and trilinear forms.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"AbstractBilinearForm\nAbstractTrilinearForm\nLaplaceOperator\nReactionOperator\nConvectionOperator\nConvectionRotationFormOperator\nHookStiffnessOperator1D\nHookStiffnessOperator2D\nHookStiffnessOperator3D\nRhsOperator","category":"page"},{"location":"pdedescription/#GradientRobustMultiPhysics.AbstractBilinearForm","page":"PDE Description","title":"GradientRobustMultiPhysics.AbstractBilinearForm","text":"function AbstractBilinearForm(\n    operators::Array{AbstractFunctionOperator,1},\n    action::AbstractAction;\n    name = \"auto\",\n    AT::Type{<:AbstractAssemblyType} = ON_CELLS,\n    apply_action_to = 1,\n    regions::Array{Int,1} = [0],\n    transposed_assembly::Bool = false,\n    store::Bool = false)\n\nabstract bilinearform constructor that assembles\n\nb(u,v) = intregions action(operator1(u)) * operator2(v) if applyaction_to = 1\nb(u,v) = intregions operator1(u) * action(operator2(v)) if applyaction_to = 2\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#GradientRobustMultiPhysics.AbstractTrilinearForm","page":"PDE Description","title":"GradientRobustMultiPhysics.AbstractTrilinearForm","text":"function AbstractTrilinearForm(\n    operators::Array{AbstractFunctionOperator,1},\n    a_from::Int,\n    a_to::Int,\n    action::AbstractAction;\n    name = \"auto\",\n    AT::Type{<:AbstractAssemblyType} = ON_CELLS,\n    regions::Array{Int,1} = [0],\n    transposed_assembly::Bool = false)\n\nabstract trilinearform constructor that assembles\n\nc(a,u,v) = int_regions action(operator1(a),operator2(u)) * operator3(v)\n\nwhere u and are the ansatz and test function coressponding to the PDE coordinates and a is an additional unknown of the PDE. The argument a can be moved to the other positions with ato and gets it data from unknown afrom of the full PDEdescription.\n\n(Note that this operator is always marked as nonlinear by the Solver configuration.)\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#GradientRobustMultiPhysics.LaplaceOperator","page":"PDE Description","title":"GradientRobustMultiPhysics.LaplaceOperator","text":"LaplaceOperator() -> GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, on cells}\nLaplaceOperator(diffusion::Any; name, AT, gradient_operator, regions, store) -> Union{Nothing, GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, on cells}}\n\n\nconstructor for a bilinearform that describes a(u,v) = (kappa * nabla u, nabla v) where kappa is some constant diffusion coefficient\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#GradientRobustMultiPhysics.ReactionOperator","page":"PDE Description","title":"GradientRobustMultiPhysics.ReactionOperator","text":"ReactionOperator() -> GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, on cells}\nReactionOperator(coefficient::Any; name, AT, identity_operator, regions, store) -> Union{Nothing, GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, on cells}}\n\n\nconstructor for a bilinearform that describes a(u,v) = (A(u),v) or (u,A(v)) with some user-specified action A\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#GradientRobustMultiPhysics.ConvectionOperator","page":"PDE Description","title":"GradientRobustMultiPhysics.ConvectionOperator","text":"function ConvectionOperator(\n    a_from::Int, \n    beta_operator::Type{<:AbstractFunctionOperator},\n    xdim::Int,\n    ncomponents::Int;\n    name = \"auto\",\n    AT::Type{<:AbstractAssemblyType} = ON_CELLS,\n    fixed_argument::Int = 1,\n    factor = 1,\n    ansatzfunction_operator::Type{<:AbstractFunctionOperator} = Gradient,\n    testfunction_operator::Type{<:AbstractFunctionOperator} = Identity,\n    regions::Array{Int,1} = [0],\n    auto_newton::Bool = false,\n    quadorder = 0)\n\nconstructs a trilinearform for a convection term of the form c(a,u,v) = (betaoperator(a)*grad(u),v) where afrom is the id of some unknown of the PDEDescription. xdim is the space dimension (= number of components of betaoperato(a)) and ncomponents is the number of components of u. With fixedargument = 2 a and u can switch their places, i.e.  c(u,a,v) = (betaoperator(u)*grad(a),v), With autonewton = true a Newton scheme for a(u,v) = (u*grad(u),v) is automatically derived (and fixed_argument is ignored).\n\n\n\n\n\nConvectionOperator(beta::UserData{AbstractDataFunction, ndim} where ndim, ncomponents::Int64; name, store, AT, ansatzfunction_operator, testfunction_operator, regions) -> GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, on cells}\n\n\nconstructor for a bilinearform that describes a(u,v) = (beta*grad(u),v) with some user-specified DataFunction beta that writes into an result array of length ncomponents\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#GradientRobustMultiPhysics.ConvectionRotationFormOperator","page":"PDE Description","title":"GradientRobustMultiPhysics.ConvectionRotationFormOperator","text":"ConvectionRotationFormOperator(beta::Int64, beta_operator::Type{var\"#s182\"} where var\"#s182\"<:??, xdim::Int64, ncomponents::Int64; name, AT, factor, ansatzfunction_operator, testfunction_operator, regions) -> Union{Nothing, GradientRobustMultiPhysics.PDEOperator{Float64, TrilinearForm, on cells}}\n\n\nconstructor for a trilinearform that describes a(u,v) = (beta x curl(u),v) where beta is the id of some unknown vector field of the PDEDescription, u and v are also vector-fields and x is the cross product (so far this is only implemented in 2D)\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#GradientRobustMultiPhysics.HookStiffnessOperator1D","page":"PDE Description","title":"GradientRobustMultiPhysics.HookStiffnessOperator1D","text":"HookStiffnessOperator1D(mu::Any; name, regions, gradient_operator, store) -> GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, on cells}\n\n\nconstructor for a bilinearform that describes a(u,v) = (C grad(u), grad(v)) where C is the 1D stiffness tensor C grad(u) = mu grad(u)\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#GradientRobustMultiPhysics.HookStiffnessOperator2D","page":"PDE Description","title":"GradientRobustMultiPhysics.HookStiffnessOperator2D","text":"HookStiffnessOperator2D(mu::Any, lambda::Any; name, AT, regions, gradient_operator, store) -> GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, on cells}\n\n\nconstructor for a bilinearform that describes a(u,v) = (C eps(u), eps(v)) where C is the 3D stiffness tensor for isotropic media in Voigt notation, i.e. C eps(u) = 2 mu eps(u) + lambda tr(eps(u)) for Lame parameters mu and lambda\n\nIn Voigt notation C is a 3 x 3 matrix\nC = [c11,c12,  0\n     c12,c11,  0\n       0,  0,c33]\n\nwhere c33 = shear_modulus, c12 = lambda and c11 = 2*c33 + c12\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#GradientRobustMultiPhysics.HookStiffnessOperator3D","page":"PDE Description","title":"GradientRobustMultiPhysics.HookStiffnessOperator3D","text":"HookStiffnessOperator3D(mu::Any, lambda::Any; name, AT, regions, gradient_operator, store) -> GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, on cells}\n\n\nconstructor for a bilinearform that describes a(u,v) = (C eps(u), eps(v)) where C is the 3D stiffness tensor for isotropic media in Voigt notation, i.e. C eps(u) = 2 mu eps(u) + lambda tr(eps(u)) for Lame parameters mu and lambda\n\nIn Voigt notation C is a 6 x 6 matrix\nC = [c11,c12,c12,  0,  0,  0\n     c12,c11,c12,  0,  0,  0\n     c12,c12,c11,  0,  0,  0\n       0,  0,  0,c44,  0,  0\n       0,  0,  0,  0,c44,  0\n       0,  0,  0,  0,  0,c44]   \n\nwhere c44 = shear_modulus, c12 = lambda and c11 = 2*c44 + c12\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#GradientRobustMultiPhysics.RhsOperator","page":"PDE Description","title":"GradientRobustMultiPhysics.RhsOperator","text":"RhsOperator(operator::Type{var\"#s206\"} where var\"#s206\"<:??, action::AbstractAction; name, AT, regions, factor, store) -> GradientRobustMultiPhysics.PDEOperator{Float64, LinearForm, on cells}\n\n\ngenerates a linearform from an action\n\n\n\n\n\nRhsOperator(operator::Type{var\"#s180\"} where var\"#s180\"<:??, regions::Vector{Int64}, data::UserData{var\"#s179\", ndim} where {var\"#s179\"<:AbstractDataFunction, ndim}; name, AT, factor, store) -> GradientRobustMultiPhysics.PDEOperator{Float64, LinearForm, on cells}\n\n\ngenerates a linearform from a given UserData{<:DataFunction} (whose result dimension has to be 1)\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#Lagrange-Multipliers","page":"PDE Description","title":"Lagrange Multipliers","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"There is a special bilinearform intended to use for the assembly of Lagrange multipliers that automatically copies itself to the transposed block of the PDEdescription.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"LagrangeMultiplier","category":"page"},{"location":"pdedescription/#GradientRobustMultiPhysics.LagrangeMultiplier","page":"PDE Description","title":"GradientRobustMultiPhysics.LagrangeMultiplier","text":"LagrangeMultiplier(operator::Type{var\"#s206\"} where var\"#s206\"<:??; name, AT, action, regions, store, factor) -> GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, on cells}\n\n\nconstructor for a bilinearform that describes a(u,v) = (A(operator(u)), id(v)) and assembles a second transposed block at the block of the transposed PDE coordinates. It is intended to use to render one unknown of the PDE the Lagrange multiplier for another unknown by putting this operator on the coressponding subdiagonal block of the PDE description.\n\nExample: LagrangeMultiplier(Divergence) is used to render the pressure the LagrangeMultiplier for the velocity divergence constraint in the Stokes prototype.\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#Nonlinear-Operators","page":"PDE Description","title":"Nonlinear Operators","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Nonlinear Operators can be setup in two ways. The manual way requires the user to define an action with a nonlinear action kernel (see Action Kernels) that specifies the linearisation of the nonlinearity. The is also an automatic way where the user specifies a norml action kernel (where the input can be used nonlinearly) which is then automatically differentiated to generate the linearised action kernel, see below for details.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"GenerateNonlinearForm","category":"page"},{"location":"pdedescription/#GradientRobustMultiPhysics.GenerateNonlinearForm","page":"PDE Description","title":"GradientRobustMultiPhysics.GenerateNonlinearForm","text":"function GenerateNonlinearForm(\n    name::String,\n    operator1::Array{DataType,1},\n    coeff_from::Array{Int,1},\n    operator2::Type{<:AbstractFunctionOperator},\n    action_kernel::Function,\n    argsizes::Array{Int,1},\n    dim::Int;\n    AT::Type{<:AbstractAssemblyType} = ON_CELLS,\n    ADnewton::Bool = false,\n    action_kernel_rhs = nothing,\n    regions = [0])\n\ngenerates an abstract nonlinearform operator G.  The array coeff_from stores the ids of the unknowns that should be used to evaluate the operators. The array argsizes is a vector with two entries where the first one is the length of the expected result vector and the second one is the length of the input vector.\n\nIf ADnewton == true, the specified actionkernel is automatically differentiated to assemble the Jacobian DG and setup a Newton iteration. The actionkernel has to be a function of the interface \n\nfunction name(result,input)\n\nwhere input is a vector of the operators of the solution and result is what then is multiplied with operator2 of the testfunction. Given some operator G(u), the Newton iteration reads DG u_next = DG u - G(u) which is added to the rest of the (linear) operators in the PDEDescription.\n\nIf ADnewton == false, the user is epected to prescribe a linearisation of the nonlinear operator. In this case the action_kernel has to satisfy the interface\n\nfunction name(result, input_current, input_ansatz)\n\nwhere inputcurrent is a vector of the operators of the solution and inputansatz is a vecor with the operators evaluated at one of the basis functions. If necessary, also a right-hand side action in the same format can be prescribed in actionkernelrhs.\n\nNote: this is a highly experimental feature at the moment and will possibly only work when all operators are associated with the same unknown.\n\ncan only be applied in PDE LHS\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#Other-Operators","page":"PDE Description","title":"Other Operators","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"There are some more operators that do not fit into the structures above. Also, in the future, the goal is to open up the operator level for exterior code to setup operators that are assembled elsewhere.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"FVConvectionDiffusionOperator\nDiagonalOperator\nCopyOperator","category":"page"},{"location":"pdedescription/#GradientRobustMultiPhysics.FVConvectionDiffusionOperator","page":"PDE Description","title":"GradientRobustMultiPhysics.FVConvectionDiffusionOperator","text":"FVConvectionDiffusionOperator(beta_from::Int64; diffusion) -> FVConvectionDiffusionOperator\n\n\nfinite-volume convection diffusion operator (for cell-wise P0 rho)\n\ndiv(diffusion * grad(rho) + beta rho)\n\nFor diffusion = 0, the upwind divergence: div_upw(beta*rho) is generated  For diffusion > 0, TODO\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/#GradientRobustMultiPhysics.DiagonalOperator","page":"PDE Description","title":"GradientRobustMultiPhysics.DiagonalOperator","text":"DiagonalOperator() -> DiagonalOperator\nDiagonalOperator(value::Real) -> DiagonalOperator\nDiagonalOperator(value::Real, onlynz::Bool; regions) -> DiagonalOperator\n\n\nputs value on the diagonal entries of the cell dofs within given regions\n\nif onlyz == true only values that are zero are changed\n\ncan only be applied in PDE LHS\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/#GradientRobustMultiPhysics.CopyOperator","page":"PDE Description","title":"GradientRobustMultiPhysics.CopyOperator","text":"CopyOperator(copy_from::Any, factor::Any) -> CopyOperator\n\n\ncopies entries from TargetVector to rhs block\n\ncan only be applied in PDE RHS\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/#Global-Constraints","page":"PDE Description","title":"Global Constraints","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"GlobalConstraints are additional constraints that the user does not wish to implement as a global Lagrange multiplier because it e.g. causes a dense row in the system matrix and therefore may destroy the performance of the sparse matrix routines. Such a constraint may be a fixed integral mean. Another application are periodic boundary conditions or glued-together quantities in different regions of the grid. Here a CombineDofs constraint may help.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"globalconstraints.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"pdedescription/#GradientRobustMultiPhysics.CombineDofs","page":"PDE Description","title":"GradientRobustMultiPhysics.CombineDofs","text":"struct CombineDofs <: AbstractGlobalConstraint\n\ncombines specified degrees of freedom of two unknown (can be the same), which allows to glue together different unknowns in different regions or periodic boundary conditions\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/#GradientRobustMultiPhysics.FixedIntegralMean","page":"PDE Description","title":"GradientRobustMultiPhysics.FixedIntegralMean","text":"struct FixedIntegralMean <: AbstractGlobalConstraint\n\nfixes integral mean of the unknown to the specified value\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"add_constraint!","category":"page"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_constraint!","page":"PDE Description","title":"GradientRobustMultiPhysics.add_constraint!","text":"add_constraint!(PDE::PDEDescription, GC::AbstractGlobalConstraint)\n\n\nAdds the given global constraint to the PDEDescription.\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#Dirichlet-Boundary-Data","page":"PDE Description","title":"Dirichlet Boundary Data","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"BoundaryOperators carry the boundary data for each unknown. Each regions can have a different AbstractBoundaryType and an associated data function that satisfies the interface function data!(result,x::Array{<:Real,1}) or function data!(result,x::Array{<:Real,1},t::Real) if it is also time-dependent.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"AbstractBoundaryType Subtypes causes\nDirichletBoundary  \n BestapproxDirichletBoundary computation of Dirichlet data by bestapproximation along boundary faces\n InterpolateDirichletBoundary computation of Dirichlet data by interpolation along boundary faces\n HomogeneousDirichletBoundary zero Dirichlet data on all dofs","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"BoundaryOperator\nadd_boundarydata!","category":"page"},{"location":"pdedescription/#GradientRobustMultiPhysics.BoundaryOperator","page":"PDE Description","title":"GradientRobustMultiPhysics.BoundaryOperator","text":"struct BoundaryOperator <: AbstractPDEOperator\n\ncollects boundary data for a component of the system and allows to specify a AbstractBoundaryType for each boundary region so far only DirichletBoundary types (see above)\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_boundarydata!","page":"PDE Description","title":"GradientRobustMultiPhysics.add_boundarydata!","text":"add_boundarydata!(PDE::PDEDescription, position::Int64, regions::Any, btype::Type{var\"#s600\"} where var\"#s600\"<:AbstractBoundaryType; data)\n\n\nAdds the given boundary data with the specified AbstractBoundaryType at the specified position in the BoundaryOperator of the PDEDescription.\n\nIf timedependent == true, that data function depends also on time t and is reassembled in any advance! step of a TimeControlSolver.\n\n\n\n\n\n","category":"function"},{"location":"pdedescription/#Other-Boundary-Data","page":"PDE Description","title":"Other Boundary Data","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"NeumannBoundary can be implemented as a RhsOperator with AT = ON_BFACES","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"PeriodicBoundary can be implemented as a CombineDofs <: AbstractGlobalConstraint","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"SymmetryBoundary can be implemented by penalisation as a AbstractBilinearForm on BFaces and specified boundary regions with operator NormalFlux + MultiplyScalarAction(penalty).","category":"page"},{"location":"examples_advanced/doc_2d_compressiblestokes/#D-Compressible-Stokes","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"","category":"section"},{"location":"examples_advanced/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"(source code)","category":"page"},{"location":"examples_advanced/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"This example solves the compressible Stokes equations where one seeks a (vector-valued) velocity mathbfu, a density varrho and a pressure p such that","category":"page"},{"location":"examples_advanced/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"beginaligned\n- mu Delta mathbfu + lambda nabla(mathrmdiv(mathbfu)) + nabla p  = mathbff + varrho mathbfg\nmathrmdiv(varrho mathbfu)  = 0\n        p  = eos(varrho)\n        int_Omega varrho  dx  = M\n        varrho  geq 0\nendaligned","category":"page"},{"location":"examples_advanced/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"Here eos eos is some equation of state function that describes the dependence of the pressure on the density (and further physical quantities like temperature in a more general setting). Moreover, mu and lambda are Lame parameters and mathbff and mathbfg are given right-hand side data.","category":"page"},{"location":"examples_advanced/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"In this example we solve a analytical toy problem with the prescribed solution","category":"page"},{"location":"examples_advanced/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"beginaligned\nmathbfu(mathbfx)  =0\nvarrho(mathbfx)  = 1 - (x_2 - 05)c\np = eos(varrho) = c varrho^gamma\nendaligned","category":"page"},{"location":"examples_advanced/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"such that mathbff = 0 and mathbfg nonzero to match the prescribed solution. This example is designed to study the well-balanced property of a discretisation. Note that a gradient-robust discretisation (set reconstruct = true below) has a much smaller L2 velocity error (i.e. approximatse the well-balanced state much better). For larger c the problem gets more incompressible which reduces the error further as then the right-hand side is a perfect gradient also when evaluated with the (now closer to a constant) discrete density. See reference below for more details.","category":"page"},{"location":"examples_advanced/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"reference: Reference\n\"A gradient-robust well-balanced scheme for the compressible isothermal Stokes problem\",\nM. Akbas, T. Gallouet, A. Gassmann, A. Linke and C. Merdon,\nComputer Methods in Applied Mechanics and Engineering 367 (2020),\n>Journal-Link< >Preprint-Link<","category":"page"},{"location":"examples_advanced/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"module Example_2DCompressibleStokes\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing Printf\n\n\n# the equation of state\nfunction equation_of_state!(c,gamma)\n    function closure(pressure,density)\n        for j = 1 : length(density)\n            pressure[j] = c*density[j]^gamma\n        end\n    end\nend\n\n# the exact density (used for initial value of density if configured so)\nfunction exact_density!(M,c)\n    function closure(result,x::Array{<:Real,1})\n        result[1] = M*(1.0 - (x[2] - 0.5)/c)\n    end\nend\n\n# gravity right-hand side (just gravity but with opposite sign!)\nfunction rhs_gravity!(gamma,c)\n    function closure(result,x::Array{<:Real,1})\n        result[1] = 1.0 - (x[2] - 0.5)/c # = density\n        result[2] = - result[1]^(gamma-2) * gamma\n        result[1] = 0.0\n    end\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, Plotter = nothing, reconstruct::Bool = true, c = 10, gamma = 1.4, M = 1, shear_modulus = 1e-3, lambda = -1e-3/3)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # load mesh and refine\n    xgrid = uniform_refine(simplexgrid(\"assets/2d_grid_mountainrange.sg\"),1)\n\n    # solve without and with reconstruction and plot\n    Solution = setup_and_solve(xgrid; reconstruct = false, c = c, M = M, lambda = lambda, shear_modulus = shear_modulus, gamma = gamma)\n    Solution2 = setup_and_solve(xgrid; reconstruct = true, c = c, M = M, lambda = lambda, shear_modulus = shear_modulus, gamma = gamma)","category":"page"},{"location":"examples_advanced/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"plot everything","category":"page"},{"location":"examples_advanced/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"    GradientRobustMultiPhysics.plot(xgrid, [Solution[1],Solution[2],Solution2[1],Solution2[2]], [Identity, Identity, Identity, Identity]; add_grid_plot = true, Plotter = Plotter)\n\n    # compare L2 error for velocity and density\n    user_velocity = DataFunction([0,0]; name = \"u\")\n    user_density = DataFunction(exact_density!(M,c), [1,2]; name = \"ϱ\", dependencies = \"X\", quadorder = 1)\n    L2VelocityErrorEvaluator = L2ErrorIntegrator(Float64, user_velocity, Identity)\n    L2DensityErrorEvaluator = L2ErrorIntegrator(Float64, user_density, Identity)\n    L2error = sqrt(evaluate(L2VelocityErrorEvaluator,Solution[1]))\n    L2error2 = sqrt(evaluate(L2VelocityErrorEvaluator,Solution2[1]))\n    L2error3 = sqrt(evaluate(L2DensityErrorEvaluator,Solution[2]))\n    L2error4 = sqrt(evaluate(L2DensityErrorEvaluator,Solution2[2]))\n    @printf(\"\\n        reconstruct     false    |    true\\n\")\n    @printf(\"================================================\\n\")\n    @printf(\"L2error(Velocity) | %.5e  | %.5e \\n\",L2error,L2error2)\n    @printf(\"L2error(Density)  | %.5e  | %.5e \\n\",L2error3,L2error4)\n\nend\n\nfunction setup_and_solve(xgrid; reconstruct = true, c = 1, gamma = 1, M = 1, shear_modulus = 1, lambda = 0, verbosity = 0)\n\n    # negotiate edata functions to the package\n    user_density = DataFunction(exact_density!(M,c), [1,2]; name = \"ϱ\", dependencies = \"X\", quadorder = 1)\n    user_gravity = DataFunction(rhs_gravity!(gamma,c), [2,2]; name = \"g\", dependencies = \"X\", quadorder = 1)\n\n    # solver parameters\n    timestep = 2 * shear_modulus / c\n    initial_density_bestapprox = true # otherwise we start with a constant density which also works but takes longer\n    maxTimeSteps = 1000  # termination criterion 1\n    stationarity_threshold = 1e-12/shear_modulus # stop when change is below this treshold\n\n    # set finite element type [velocity, density,  pressure]\n    FETypes = [H1BR{2}, H1P0{1}, H1P0{1}] # Bernardi--Raugel\n\n    # set function operators depending on reconstruct\n    if reconstruct\n        VeloIdentity = ReconstructionIdentity{HDIVBDM1{2}} # identity operator for gradient-robust scheme\n        VeloDivergence = ReconstructionDivergence{HDIVBDM1{2}} # divergence operator for gradient-robust scheme\n    else # classical choices\n        VeloIdentity = Identity\n        VeloDivergence = Divergence\n    end\n\n    # generate empty PDEDescription for three unknowns\n    # unknown 1 : velocity v (vector-valued)\n    # unknown 2 : density ϱ\n    # unknown 3 : pressure p\n    Problem = PDEDescription(\"compressible Stokes problem\")\n    add_unknown!(Problem; unknown_name = \"v\", equation_name = \"momentum equation\")\n    add_unknown!(Problem; unknown_name = \"ϱ\", equation_name = \"continuity equation\")\n    add_unknown!(Problem; unknown_name = \"p\", equation_name = \"equation of state\")\n    add_boundarydata!(Problem, 1,  [1,2,3,4], HomogeneousDirichletBoundary)\n\n    # momentum equation\n    add_operator!(Problem, [1,1], LaplaceOperator(2*shear_modulus; store = true))\n    if lambda != 0\n        add_operator!(Problem, [1,1], AbstractBilinearForm([VeloDivergence,VeloDivergence]; name = \"λ (div(u),div(v))\", factor = lambda, store = true))\n    end\n    add_operator!(Problem, [1,3], AbstractBilinearForm([Divergence,Identity]; name = \"(div(v),p)\", factor = -1, store = true))\n\n    function gravity_action()\n        temp = zeros(Float64,2)\n        function closure(result,input,x, t)\n            eval!(temp, user_gravity, x, t)\n            result[1] = - temp[1] * input[1] - temp[2] * input[2]\n        end\n        gravity_action = Action(Float64, closure, [1,2]; name = \"gravity action\", dependencies = \"XT\", quadorder = user_gravity.quadorder)\n    end\n    add_operator!(Problem, [1,2], AbstractBilinearForm([VeloIdentity,Identity],gravity_action(); name = \"ϱ(g ⋅ v)\", store = true))\n\n    # continuity equation (by FV upwind on triangles)\n    add_operator!(Problem, [2,2], FVConvectionDiffusionOperator(1))\n\n    # equation of state (by best-approximation, P0 mass matrix is diagonal)\n    eos_action_kernel = ActionKernel(equation_of_state!(c,gamma),[1,1]; dependencies = \"\", quadorder = 0)\n    eos_action = Action(Float64, eos_action_kernel)\n    add_operator!(Problem, [3,2], AbstractBilinearForm([Identity,Identity],eos_action; name = \"(p,eos(ϱ))\", apply_action_to = [2]))\n    add_operator!(Problem, [3,3], AbstractBilinearForm([Identity,Identity]; name = \"(p,q)\", factor = -1, store = true))\n\n    # generate FESpaces and solution vector\n    FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid), FESpace{FETypes[3]}(xgrid)]\n    Solution = FEVector{Float64}([\"v_h (reconst=$reconstruct)\", \"ϱ_h (reconst=$reconstruct)\", \"p_h (reconst=$reconstruct)\"],FES)\n\n    # initial values for density (bestapproximation or constant)\n    if initial_density_bestapprox\n        L2DensityBestapproximationProblem = L2BestapproximationProblem(user_density; bestapprox_boundary_regions = [])\n        InitialDensity = FEVector{Float64}(\"ϱ_best\",FES[2])\n        solve!(InitialDensity, L2DensityBestapproximationProblem)\n        Solution[2][:] = InitialDensity[1][:]\n    else\n        for j = 1 : FESpacePD.ndofs\n            Solution[2][j] = M\n        end\n    end\n\n    # initial values for pressure obtained from equation of state\n    equation_of_state!(c,gamma)(Solution[3],Solution[2])\n    Minit = M * sum(Solution[2][:] .* xgrid[CellVolumes])\n\n    # generate time-dependent solver\n    # we have three equations [1] for velocity, [2] for density, [3] for pressure\n    # that are set to be iterated one after another via the subiterations argument\n    # only the density equation is made time-dependent via the timedependent_equations argument\n    # so we can reuse the other subiteration matrices in each timestep\n    TCS = TimeControlSolver(Problem, Solution, BackwardEuler;\n                                        subiterations = [[1],[2],[3]],\n                                        skip_update = [-1,1,-1],\n                                        timedependent_equations = [2],\n                                        maxiterations = 1,\n                                        show_solver_config = true,\n                                        check_nonlinear_residual = false)\n    advance_until_stationarity!(TCS, timestep; maxTimeSteps = maxTimeSteps, stationarity_threshold = stationarity_threshold)\n\n    # compute error in mass constraint\n    Md = sum(Solution[2][:] .* xgrid[CellVolumes])\n    @printf(\"  mass_error = %.4e - %.4e = %.4e \\n\",Minit, Md, abs(Minit-Md))\n\n    return Solution\nend\n\nend","category":"page"},{"location":"examples_advanced/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"","category":"page"},{"location":"examples_advanced/doc_2d_compressiblestokes/","page":"2D Compressible Stokes","title":"2D Compressible Stokes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_loceq/#D-Equilibration-Error-Estimation-(Local)","page":"2D Equilibration Error Estimation (Local)","title":"2D Equilibration Error Estimation (Local)","text":"","category":"section"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_loceq/","page":"2D Equilibration Error Estimation (Local)","title":"2D Equilibration Error Estimation (Local)","text":"(source code)","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_loceq/","page":"2D Equilibration Error Estimation (Local)","title":"2D Equilibration Error Estimation (Local)","text":"This example computes a local equilibration error estimator for the H^1 error of some H^1-conforming approximation u_h to the solution u of some Poisson problem -Delta u = f on an L-shaped domain, i.e.","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_loceq/","page":"2D Equilibration Error Estimation (Local)","title":"2D Equilibration Error Estimation (Local)","text":"eta^2(sigma_h) =  sigma_h - nabla u_h ^2_L^2(T)","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_loceq/","page":"2D Equilibration Error Estimation (Local)","title":"2D Equilibration Error Estimation (Local)","text":"where sigma_h discretisates the exact sigma in the dual mixed problem","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_loceq/","page":"2D Equilibration Error Estimation (Local)","title":"2D Equilibration Error Estimation (Local)","text":"sigma - nabla u = 0\nquad textand quad\nmathrmdiv(sigma) + f = 0","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_loceq/","page":"2D Equilibration Error Estimation (Local)","title":"2D Equilibration Error Estimation (Local)","text":"by some local equilibration strategy, see reference below for details.","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_loceq/","page":"2D Equilibration Error Estimation (Local)","title":"2D Equilibration Error Estimation (Local)","text":"This examples demonstrates the use of low-level structures to assemble individual problems and a strategy solve several small problems in parallel.","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_loceq/","page":"2D Equilibration Error Estimation (Local)","title":"2D Equilibration Error Estimation (Local)","text":"reference: Reference\n''A posteriori error estimates for efficiency and error control in numerical simulations'' Lecture Notes by M. Vohralik >Link<","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_loceq/","page":"2D Equilibration Error Estimation (Local)","title":"2D Equilibration Error Estimation (Local)","text":"module Example_LEQLshape\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing ExtendableSparse\nusing Printf\n\n# exact solution u for the Poisson problem\nfunction exact_function!(result,x::Array{<:Real,1})\n    result[1] = atan(x[2],x[1])\n    if result[1] < 0\n        result[1] += 2*pi\n    end\n    result[1] = sin(2*result[1]/3)\n    result[1] *= (x[1]^2 + x[2]^2)^(1/3)\nend\n# ... and its gradient\nfunction exact_function_gradient!(result,x::Array{<:Real,1})\n    result[1] = atan(x[2],x[1])\n    if result[1] < 0\n        result[1] += 2*pi\n    end\n    # du/dy = du/dr * sin(phi) + (1/r) * du/dphi * cos(phi)\n    result[2] = sin(2*result[1]/3) * sin(result[1]) + cos(2*result[1]/3) * cos(result[1])\n    result[2] *= (x[1]^2 + x[2]^2)^(-1/6) * 2/3\n    # du/dx = du/dr * cos(phi) - (1/r) * du/dphi * sin(phi)\n    result[1] = sin(2*result[1]/3) * cos(result[1]) - cos(2*result[1]/3) * sin(result[1])\n    result[1] *= (x[1]^2 + x[2]^2)^(-1/6) * 2/3\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, nlevels = 15, theta = 1//2, Plotter = nothing)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # initial grid\n    xgrid = grid_lshape(Triangle2D)\n\n    # choose some finite elements for primal and dual problem (= for equilibrated fluxes)\n    # (local equilibration for Pk needs at least BDMk)\n    FEType = H1P1{1}\n    FETypeDual = HDIVBDM1{2}\n\n    # negotiate data functions to the package\n    user_function = DataFunction(exact_function!, [1,2]; name = \"u\", dependencies = \"X\", quadorder = 5)\n    user_function_gradient = DataFunction(exact_function_gradient!, [2,2]; name = \"∇(u)\", dependencies = \"X\", quadorder = 4)\n\n    # setup Poisson problem\n    Problem = PoissonProblem()\n    add_boundarydata!(Problem, 1, [2,3,4,5,6,7], BestapproxDirichletBoundary; data = user_function)\n    add_boundarydata!(Problem, 1, [1,8], HomogeneousDirichletBoundary)\n\n    # define error estimator : || sigma_h - nabla u_h ||^2_{L^2(T)}\n    # this can be realised via a kernel function\n    function eqestimator_kernel(result, input)\n        # input = [Identity(sigma_h), Divergence(sigma_h), Gradient(u_h)]\n        result[1] = (input[1] - input[4])^2 + (input[2] - input[5])^2\n        result[2] = input[3]^2\n        return nothing\n    end\n    estimator_action = Action(Float64,ActionKernel(eqestimator_kernel, [2,5]; name = \"estimator kernel\", dependencies = \"\", quadorder = 3))\n    EQIntegrator = ItemIntegrator(Float64,ON_CELLS,[Identity, Divergence, Gradient],estimator_action)\n\n    # setup exact error evaluations\n    L2ErrorEvaluator = L2ErrorIntegrator(Float64, user_function, Identity)\n    H1ErrorEvaluator = L2ErrorIntegrator(Float64, user_function_gradient, Gradient)\n    L2ErrorEvaluatorDual = L2ErrorIntegrator(Float64, user_function_gradient, Identity)\n\n    # refinement loop (only uniform for now)\n    NDofs = zeros(Int, nlevels)\n    NDofsDual = zeros(Int, nlevels)\n    Results = zeros(Float64, nlevels, 4)\n    Solution = nothing\n    for level = 1 : nlevels\n\n        # create a solution vector and solve the problem\n        FES = FESpace{FEType}(xgrid)\n        Solution = FEVector{Float64}(\"u_h\",FES)\n        solve!(Solution, Problem)\n        NDofs[level] = length(Solution[1])\n\n        # evaluate eqilibration error estimator adn append it to Solution vector (for plotting etc.)\n        DualSolution = get_local_equilibration_estimator(xgrid, Solution, FETypeDual)\n        NDofsDual[level] = length(DualSolution.entries)\n        FES_eta = FESpace{H1P0{1}}(xgrid)\n        append!(Solution, \"σ_h\",FES_eta)\n        error4cell = zeros(Float64,2,num_sources(xgrid[CellNodes]))\n        evaluate!(error4cell, EQIntegrator, [DualSolution[1], DualSolution[1], Solution[1]])\n        for j = 1 : num_sources(xgrid[CellNodes])\n            Solution[2][j] = error4cell[1,j] + error4cell[2,j]\n        end\n\n        if verbosity > 0\n            println(\"\\n  SOLVE LEVEL $level\")\n            println(\"    ndofs = $(NDofs[level])\")\n            println(\"    ndofsDual = $(NDofsDual[level])\")\n        end\n\n        # calculate L2 error, H1 error, estimator, dual L2 error and write to results\n        Results[level,1] = sqrt(evaluate(L2ErrorEvaluator,[Solution[1]]))\n        Results[level,2] = sqrt(evaluate(H1ErrorEvaluator,[Solution[1]]))\n        Results[level,3] = sqrt(sum(Solution[2][:]))\n        Results[level,4] = sqrt(evaluate(L2ErrorEvaluatorDual,[DualSolution[1]]))\n        if verbosity > 0\n            println(\"  ESTIMATE\")\n            println(\"    estim H1 error = $(Results[level,3])\")\n            println(\"    exact H1 error = $(Results[level,2])\")\n            println(\"     dual L2 error = $(Results[level,4])\")\n        end\n\n        if level == nlevels\n            break;\n        end\n\n        # mesh refinement\n        if theta >= 1\n            # uniform mesh refinement\n            xgrid = uniform_refine(xgrid)\n        else\n            # adaptive mesh refinement\n            # refine by red-green-blue refinement (incl. closuring)\n            facemarker = bulk_mark(xgrid, Solution[2], theta)\n            xgrid = RGB_refine(xgrid, facemarker)\n        end\n    end\n\n    # plot\n    GradientRobustMultiPhysics.plot(xgrid, [Solution[1]], [Identity]; add_grid_plot = true, Plotter = Plotter)\n\n    # print results\n    @printf(\"\\n  NDOFS  |   L2ERROR      order   |   H1ERROR      order   | H1-ESTIMATOR   order      efficiency   \")\n    @printf(\"\\n=========|========================|========================|========================================\\n\")\n    order = 0\n    for j=1:nlevels\n        @printf(\"  %6d |\",NDofs[j]);\n        for k = 1 : 3\n            if j > 1\n                order = log(Results[j-1,k]/Results[j,k]) / (log(NDofs[j]/NDofs[j-1])/2)\n            end\n            @printf(\" %.5e \",Results[j,k])\n            if k == 3\n                @printf(\"   %.3f       %.3f\",order,Results[j,k]/Results[j,k-1])\n            else\n                @printf(\"   %.3f   |\",order)\n            end\n        end\n        @printf(\"\\n\")\n    end\n\nend\n\n\n# this function computes the local equilibrated fluxes\n# by solving local problems on (disjunct group of) node patches\nfunction get_local_equilibration_estimator(xgrid, Solution, FETypeDual; verbosity::Int = 1)\n    # needed grid stuff\n    xCellNodes::Array{Int32,2} = xgrid[CellNodes]\n    xCellFaces::Array{Int32,2} = xgrid[CellFaces]\n    xFaceNodes::Array{Int32,2} = xgrid[FaceNodes]\n    xCellVolumes::Array{Float64,1} = xgrid[CellVolumes]\n    xNodeCells = atranspose(xCellNodes)\n    nnodes::Int = num_sources(xNodeCells)\n    nfaces::Int = num_sources(xFaceNodes)\n\n    # get node patch groups that can be solved in parallel\n    group4node = xgrid[NodePatchGroups]\n\n    # init equilibration space (and Lagrange multiplier space)\n    FEType = eltype(Solution[1].FES)\n    FESDual = FESpace{FETypeDual}(xgrid)\n    xItemDofs::Union{VariableTargetAdjacency{Int32},SerialVariableTargetAdjacency{Int32},Array{Int32,2}} = FESDual[CellDofs]\n    xFaceDofs::Union{VariableTargetAdjacency{Int32},SerialVariableTargetAdjacency{Int32},Array{Int32,2}} = FESDual[FaceDofs]\n    xItemDofs_uh::Union{VariableTargetAdjacency{Int32},SerialVariableTargetAdjacency{Int32},Array{Int32,2}} = Solution[1].FES[CellDofs]\n    DualSolution = FEVector{Float64}(\"σ_h\",FESDual)\n\n    # partition of unity and their gradients\n    POUFEType = H1P1{1}\n    POUFES = FESpace{POUFEType}(xgrid)\n    POUqf = QuadratureRule{Float64,Triangle2D}(0)\n\n    # quadrature formulas\n    qf = QuadratureRule{Float64,Triangle2D}(2*get_polynomialorder(FETypeDual, Triangle2D))\n    weights::Array{Float64,1} = qf.w\n\n    # some constants\n    dofs_on_face::Int = max_num_targets_per_source(xFaceDofs)\n    div_penalty::Float64 = 1e5\n    bnd_penalty::Float64 = 1e30\n    maxcells::Int = max_num_targets_per_source(xNodeCells)\n    maxdofs::Int = max_num_targets_per_source(xItemDofs)\n    maxdofs_uh::Int = max_num_targets_per_source(xItemDofs_uh)\n\n    # redistribute groups for more equilibrated thread load (first groups are larger)\n    maxgroups = maximum(group4node)\n    groups = Array{Int,1}(1 : maxgroups)\n    for j::Int = 1 : floor(maxgroups/2)\n        a = groups[j]\n        groups[j] = groups[2*j]\n        groups[2*j] = a\n    end\n    X = Array{Array{Float64,1},1}(undef,maxgroups)\n\n    Threads.@threads for group in groups\n        grouptime = @elapsed begin\n        @info \"  Starting equilibrating patch group $group on thread $(Threads.threadid())... \"\n        # temporary variables\n        localnode::Int = 0\n        graduh = zeros(Float64,2)\n        gradphi = zeros(Float64,2)\n        coeffs_uh = zeros(Float64, maxdofs_uh)\n        eval_i = zeros(Float64,2)\n        eval_j = zeros(Float64,2)\n        eval_phi = zeros(Float64,1)\n        cell::Int = 0\n        dofi::Int = 0\n        dofj::Int = 0\n        weight::Float64 = 0\n        temp::Float64 = 0\n        temp2::Float64 = 0\n        temp3::Float64 = 0\n        Alocal = zeros(Float64,maxdofs,maxdofs)\n        blocal = zeros(Float64,maxdofs)\n\n        # init FEBasiEvaluator\n        FEBasis_gradphi = FEBasisEvaluator{Float64,POUFEType,Triangle2D,Gradient,ON_CELLS}(POUFES, POUqf)\n        FEBasis_xref = FEBasisEvaluator{Float64,POUFEType,Triangle2D,Identity,ON_CELLS}(POUFES, qf)\n        FEBasis_graduh = FEBasisEvaluator{Float64,FEType,Triangle2D,Gradient,ON_CELLS}(Solution[1].FES, qf)\n        FEBasis_div = FEBasisEvaluator{Float64,FETypeDual,Triangle2D,Divergence,ON_CELLS}(FESDual, qf)\n        FEBasis_id = FEBasisEvaluator{Float64,FETypeDual,Triangle2D,Identity,ON_CELLS}(FESDual, qf)\n\n        # init system\n        A = ExtendableSparseMatrix{Float64,Int}(FESDual.ndofs,FESDual.ndofs)\n        b = zeros(Float64,FESDual.ndofs)\n        X[group] = zeros(Float64,FESDual.ndofs)\n        x = zeros(Float64,FESDual.ndofs)\n\n        # find dofs at boundary of node patches\n        is_boundarydof = zeros(Bool,FESDual.ndofs)\n        boundary_face::Bool = false\n        for face = 1 : nfaces\n            boundary_face = true\n            for k = 1 : 2\n                if group4node[xFaceNodes[k,face]] == group\n                    boundary_face = false\n                    break\n                end\n            end\n            if (boundary_face)\n                for j = 1 : dofs_on_face\n                    is_boundarydof[xFaceDofs[j,face]] = true\n                end\n            end\n        end\n\n        for node = 1 : nnodes\n        if group4node[node] == group\n            for c = 1 : num_targets(xNodeCells,node)\n                cell = xNodeCells[c,node]\n\n                # find local node number of global node z\n                # and evaluate (constatn) gradient of nodal basis function phi_z\n                localnode = 1\n                while xCellNodes[localnode,cell] != node\n                    localnode += 1\n                end\n                update!(FEBasis_gradphi,cell)\n                eval!(gradphi, FEBasis_gradphi, localnode, 1)\n\n                # read coefficients for discrete flux\n                for j=1:maxdofs_uh\n                    coeffs_uh[j] = Solution[1].entries[xItemDofs_uh[j,cell]]\n                end\n\n                # update other FE evaluators\n                update!(FEBasis_graduh,cell)\n                update!(FEBasis_div,cell)\n                update!(FEBasis_id,cell)\n\n                # assembly on this cell\n                for i in eachindex(weights)\n                    weight = weights[i] * xCellVolumes[cell]\n\n                    # evaluate grad(u_h) and nodal basis function at quadrature point\n                    fill!(graduh,0)\n                    eval!(graduh, FEBasis_graduh, coeffs_uh, i)\n                    eval!(eval_phi, FEBasis_xref, localnode, i)\n\n                    # compute residual -f*phi_z + grad(u_h) * grad(phi_z) at quadrature point i ( f = 0 in this example !!! )\n                    temp = div_penalty * sqrt(xCellVolumes[cell]) * ( graduh[1] * gradphi[1] + graduh[2] * gradphi[2] ) * weight\n                    temp2 = div_penalty * sqrt(xCellVolumes[cell]) *weight\n                    for dof_i = 1 : maxdofs\n                        eval!(eval_i, FEBasis_id, dof_i, i)\n                        eval_i .*= weight\n                        # right-hand side for best-approximation (grad(u_h)*phi)\n                        blocal[dof_i] += (graduh[1]*eval_i[1] + graduh[2]*eval_i[2]) * eval_phi[1]\n                        # mass matrix Hdiv\n                        for dof_j = 1 : maxdofs\n                            eval!(eval_j, FEBasis_id, dof_j, i)\n                            Alocal[dof_i,dof_j] += (eval_i[1]*eval_j[1] + eval_i[2]*eval_j[2])\n                        end\n                        # div-div matrix Hdiv * penalty (quick and dirty to avoid Lagrange multiplier)\n                        eval!(eval_i, FEBasis_div, dof_i, i)\n                        blocal[dof_i] += temp * eval_i[1]\n                        temp3 = temp2 * eval_i[1]\n                        for dof_j = 1 : maxdofs\n                            eval!(eval_j, FEBasis_div, dof_j, i)\n                            Alocal[dof_i,dof_j] += temp3*eval_j[1]\n                        end\n                    end\n                end\n\n                # write into global A and b\n                for dof_i = 1 : maxdofs\n                    dofi = xItemDofs[dof_i,cell]\n                    b[dofi] += blocal[dof_i]\n                    for dof_j = 1 : maxdofs\n                        dofj = xItemDofs[dof_j,cell]\n                        _addnz(A,dofi,dofj,Alocal[dof_i,dof_j],1)\n                    end\n                end\n\n                # reset local A and b\n                fill!(Alocal,0)\n                fill!(blocal,0)\n            end\n        end\n        end\n\n        # penalize dofs at boundary of node patches\n        for j = 1 : FESDual.ndofs\n            if is_boundarydof[j]\n                A[j,j] = bnd_penalty\n                b[j] = 0\n            end\n        end\n\n        # solve local problem\n        X[group] .= A\\b\n    end\n\n    @info \"Finished equilibration patch group $group on thread $(Threads.threadid()) in $(grouptime)s \"\n    end\n\n    # write local solutions to global vector\n    for group = 1 : maxgroups\n        DualSolution[1].entries .+= X[group]\n    end\n\n    return DualSolution\nend\n\nend","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_loceq/","page":"2D Equilibration Error Estimation (Local)","title":"2D Equilibration Error Estimation (Local)","text":"","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_loceq/","page":"2D Equilibration Error Estimation (Local)","title":"2D Equilibration Error Estimation (Local)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"fespace/#Finite-Element-Spaces-and-Arrays","page":"FE Spaces and Arrays","title":"Finite Element Spaces and Arrays","text":"","category":"section"},{"location":"fespace/","page":"FE Spaces and Arrays","title":"FE Spaces and Arrays","text":"This page describes the structure FESpace that acts as a finite element space on a given grid and the degree of freedom maps DofMaps. See Implemented Finite Elements for a list of available finite element types.","category":"page"},{"location":"fespace/","page":"FE Spaces and Arrays","title":"FE Spaces and Arrays","text":"Moreover, there are special arrays FEVector and FEMatrix that carry coefficients and discretised PDEOperators.","category":"page"},{"location":"fespace/#FESpace","page":"FE Spaces and Arrays","title":"FESpace","text":"","category":"section"},{"location":"fespace/","page":"FE Spaces and Arrays","title":"FE Spaces and Arrays","text":"To generate a finite element space only a finite element type and a grid is needed, dofmaps are generated automatically on demand.","category":"page"},{"location":"fespace/","page":"FE Spaces and Arrays","title":"FE Spaces and Arrays","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"finiteelements.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fespace/#GradientRobustMultiPhysics.FESpace","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FESpace","text":"mutable struct FESpace{FEType<:AbstractFiniteElement}\n    name::String                          # full name of finite element space (used in messages)\n    broken::Bool                          # if true, broken dofmaps are generated\n    ndofs::Int                            # total number of dofs\n    xgrid::ExtendableGrid                 # link to xgrid \n    dofmaps::Dict{Type{<:AbstractGridComponent},Any} # backpack with dofmaps\nend\n\nA struct that has a finite element type as parameter and carries dofmaps (CellDofs, FaceDofs, BFaceDofs) plus additional grid information and access to arrays holding coefficients if needed.\n\n\n\n\n\n","category":"type"},{"location":"fespace/#GradientRobustMultiPhysics.FESpace-Union{Tuple{ExtendableGrid}, Tuple{AT}, Tuple{FEType}} where {FEType<:AbstractFiniteElement, AT<:AbstractAssemblyType}","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FESpace","text":"function FESpace{FEType<:AbstractFiniteElement,AT<:AbstractAssemblyType}(\n    xgrid::ExtendableGrid;\n    name = \"\",\n    broken::Bool = false)\n\nConstructor for FESpace of the given FEType, AT = ONCELLS/ONFACES/ONEDGES generates a finite elements space on the cells/faces/edges of the provided xgrid (if omitted ONCELLS is used as default). The broken switch allows to generate a broken finite element space (that is piecewise H1/Hdiv/HCurl). If no name is provided it is generated automatically from FEType.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.eltype-Union{Tuple{FESpace{FEType, AT} where AT<:AbstractAssemblyType}, Tuple{FEType}} where FEType<:AbstractFiniteElement","page":"FE Spaces and Arrays","title":"Base.eltype","text":"eltype(_::FESpace{FEType<:AbstractFiniteElement, AT} where AT<:AbstractAssemblyType) -> Type{FEType} where FEType<:AbstractFiniteElement\n\n\nCustom eltype function for FESpace returns the finite element type of the finite element space.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.get!-Tuple{FESpace, Type{var\"#s206\"} where var\"#s206\"<:DofMap}","page":"FE Spaces and Arrays","title":"Base.get!","text":"get!(FES::FESpace, DM::Type{var\"#s206\"} where var\"#s206\"<:DofMap) -> Any\n\n\nTo be called by getindex. This triggers lazy creation of  non-existing dofmaps\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.getindex-Tuple{FESpace, Type{var\"#s206\"} where var\"#s206\"<:DofMap}","page":"FE Spaces and Arrays","title":"Base.getindex","text":"Base.getindex(FES::FESpace,DM::Type{<:DofMap})\n\nGeneric method for obtaining dofmap. This method is mutating in the sense that non-existing dofmaps are created on demand. Due to the fact that components are stored as Any the return value triggers type instability.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.setindex!-Tuple{FESpace, Any, Type{var\"#s206\"} where var\"#s206\"<:DofMap}","page":"FE Spaces and Arrays","title":"Base.setindex!","text":"setindex!(FES::FESpace, v::Any, DM::Type{var\"#s206\"} where var\"#s206\"<:DofMap) -> Any\n\n\nSet new dofmap\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.show-Union{Tuple{FEType}, Tuple{IO, FESpace{FEType, AT} where AT<:AbstractAssemblyType}} where FEType<:AbstractFiniteElement","page":"FE Spaces and Arrays","title":"Base.show","text":"show(io::IO, FES::FESpace{FEType<:AbstractFiniteElement, AT} where AT<:AbstractAssemblyType)\n\n\nCustom show function for FESpace that prints some information and all available dofmaps.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#DofMaps","page":"FE Spaces and Arrays","title":"DofMaps","text":"","category":"section"},{"location":"fespace/","page":"FE Spaces and Arrays","title":"FE Spaces and Arrays","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"dofmaps.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fespace/#GradientRobustMultiPhysics.DofMap","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.DofMap","text":"abstract type DofMap <: AbstractGridAdjacency\n\nDofmaps are stored as an ExtendableGrids.AbstractGridAdjacency in the finite element space and collect information with respect to different AssemblyTypes. They are generated automatically on demand and the dofmaps associated to each subtype can be accessed via FESpace[DofMap].\n\n\n\n\n\n","category":"type"},{"location":"fespace/","page":"FE Spaces and Arrays","title":"FE Spaces and Arrays","text":"The following DofMap subtypes are available and are used as keys to access the dofmap via FESpaceDofMap.","category":"page"},{"location":"fespace/","page":"FE Spaces and Arrays","title":"FE Spaces and Arrays","text":"DofMap Explanation\nCellDofs degrees of freedom for on each cell\nFaceDofs degrees of freedom for each face\nEdgeDofs degrees of freedom for each edge (in 3D)\nBFaceDofs degrees of freedom for each boundary face\nBEdgeDofs degrees of freedom for each boundary edge (in 3D)","category":"page"},{"location":"fespace/#FEVector","page":"FE Spaces and Arrays","title":"FEVector","text":"","category":"section"},{"location":"fespace/","page":"FE Spaces and Arrays","title":"FE Spaces and Arrays","text":"A FEVector consists of FEVectorBlocks that share a common one-dimensional arrays. Each block is associated to a FESpace and can only write into a region of the common array specified by offsets. It also acts as a one-dimensional AbstractArray itself.","category":"page"},{"location":"fespace/","page":"FE Spaces and Arrays","title":"FE Spaces and Arrays","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"fevector.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fespace/#GradientRobustMultiPhysics.FEVector","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FEVector","text":"struct FEVector{T} <: AbstractArray{T, 1}\n\na plain array but with an additional layer of several FEVectorBlock subdivisions each carrying coefficients for their associated FESpace\n\n\n\n\n\n","category":"type"},{"location":"fespace/#GradientRobustMultiPhysics.FEVector-Union{Tuple{T}, Tuple{String, FESpace}} where T<:Real","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FEVector","text":"FEVector{T}(name::String, FES::FESpace) where T <: Real\n\nCreates FEVector that has one block.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.FEVector-Union{Tuple{T}, Tuple{Vector{String}, Vector{var\"#s204\"} where var\"#s204\"<:FESpace}} where T<:Real","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FEVector","text":"FEVector{T}(name::String, FES::Array{FESpace,1}) where T <: Real\n\nCreates FEVector that has one block for each FESpace in FES.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.FEVectorBlock","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FEVectorBlock","text":"struct FEVectorBlock{T} <: AbstractArray{T, 1}\n\nblock of an FEVector that carries coefficients for an associated FESpace and can be assigned as an AbstractArray (getindex, setindex, size, length)\n\n\n\n\n\n","category":"type"},{"location":"fespace/#Base.append!-Union{Tuple{T}, Tuple{FEVector{T}, String, FESpace}} where T<:Real","page":"FE Spaces and Arrays","title":"Base.append!","text":"append!(FEF::FEVector{T<:Real}, name::String, FES::FESpace)\n\n\nCustom append function for FEVector that adds a FEVectorBlock at the end.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.fill!-Tuple{FEVectorBlock, Any}","page":"FE Spaces and Arrays","title":"Base.fill!","text":"fill!(b::FEVectorBlock, value::Any)\n\n\nCustom fill function for FEVectorBlock (only fills the block, not the complete FEVector).\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.length-Tuple{FEVectorBlock}","page":"FE Spaces and Arrays","title":"Base.length","text":"length(FEB::FEVectorBlock) -> Int64\n\n\nCustom length function for FEVectorBlock that gives the coressponding number of degrees of freedoms of the associated FESpace\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.length-Tuple{FEVector}","page":"FE Spaces and Arrays","title":"Base.length","text":"length(FEF::FEVector) -> Int64\n\n\nCustom length function for FEVector that gives the number of defined FEMatrixBlocks in it\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.show-Tuple{IO, FEVector}","page":"FE Spaces and Arrays","title":"Base.show","text":"show(io::IO, FEF::FEVector)\n\n\nCustom show function for FEVector that prints some information on its blocks.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.addblock!-Tuple{FEVectorBlock, AbstractVector{T} where T}","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.addblock!","text":"addblock!(a::FEVectorBlock, b::AbstractVector{T} where T; factor)\n\n\nAdds Array b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.addblock!-Tuple{FEVectorBlock, FEVectorBlock}","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.addblock!","text":"addblock!(a::FEVectorBlock, b::FEVectorBlock; factor)\n\n\nAdds FEVectorBlock b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#FEMatrix","page":"FE Spaces and Arrays","title":"FEMatrix","text":"","category":"section"},{"location":"fespace/","page":"FE Spaces and Arrays","title":"FE Spaces and Arrays","text":"A FEMatrix consists of FEMatrixBlocks that share a common ExtendableSparseMatrix. Each block is associated to two FESpaces and can only write into a submatrix of the common sparse matrix specified by offsets. It also acts as a two-dimensional AbstractArray itself.","category":"page"},{"location":"fespace/","page":"FE Spaces and Arrays","title":"FE Spaces and Arrays","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"fematrix.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fespace/#GradientRobustMultiPhysics.FEMatrix","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FEMatrix","text":"struct FEMatrix{T, nbrow, nbcol, nbtotal} <: AbstractArray{T, 1}\n\nan AbstractMatrix (e.g. an ExtendableSparseMatrix) with an additional layer of several FEMatrixBlock subdivisions each carrying coefficients for their associated pair of FESpaces\n\n\n\n\n\n","category":"type"},{"location":"fespace/#GradientRobustMultiPhysics.FEMatrix-Union{Tuple{T}, Tuple{String, FESpace, FESpace}} where T<:Real","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FEMatrix","text":"FEMatrix{T}(name::String, FESX::FESpace, FESY::FESpace) where T <: Real\n\nCreates FEMatrix with one rectangular block (FESX,FESY).\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.FEMatrix-Union{Tuple{T}, Tuple{String, FESpace}} where T<:Real","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FEMatrix","text":"FEMatrix{T}(name::String, FES::FESpace) where T <: Real\n\nCreates FEMatrix with one square block (FES,FES).\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.FEMatrix-Union{Tuple{T}, Tuple{String, Vector{FESpace}}} where T<:Real","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FEMatrix","text":"FEMatrix{T}(name::String, FES::Array{FESpace,1}) where T <: Real\n\nCreates FEMatrix with blocks (FESX[i],FESY[j]) (enumerated row-wise).\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.FEMatrixBlock","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.FEMatrixBlock","text":"struct FEMatrixBlock{T} <: AbstractArray{T, 2}\n\nblock of an FEMatrix that carries coefficients for an associated pair of FESpaces and can be assigned as an two-dimensional AbstractArray (getindex, setindex, size)\n\n\n\n\n\n","category":"type"},{"location":"fespace/#Base.fill!-Tuple{FEMatrixBlock, Any}","page":"FE Spaces and Arrays","title":"Base.fill!","text":"fill!(B::FEMatrixBlock, value::Any)\n\n\nCustom fill function for FEMatrixBlock (only fills the block, not the complete FEMatrix).\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.length-Tuple{FEMatrix}","page":"FE Spaces and Arrays","title":"Base.length","text":"length(FEF::FEMatrix) -> Any\n\n\nCustom length function for FEMatrix that gives the total number of defined FEMatrixBlocks in it\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.show-Tuple{IO, FEMatrix}","page":"FE Spaces and Arrays","title":"Base.show","text":"show(io::IO, FEM::FEMatrix)\n\n\nCustom show function for FEMatrix that prints some information on its blocks.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.size-Tuple{FEMatrixBlock}","page":"FE Spaces and Arrays","title":"Base.size","text":"size(FEB::FEMatrixBlock) -> Vector{Int64}\n\n\nCustom size function for FEMatrixBlock that gives the size of the block (that coressponds to the number of degrees of freedoms in X and Y)\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.size-Tuple{FEMatrix}","page":"FE Spaces and Arrays","title":"Base.size","text":"size(FEF::FEMatrix) -> Vector{_A} where _A\n\n\nCustom size function for FEMatrix that gives the number of rows and columns of the FEBlock overlay\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.addblock!-Tuple{FEMatrixBlock, FEMatrixBlock}","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.addblock!","text":"addblock!(A::FEMatrixBlock, B::FEMatrixBlock; factor, transpose)\n\n\nAdds FEMatrixBlock B to FEMatrixBlock A.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.addblock!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock, ExtendableSparseMatrix{Tv, Ti}}} where {Tv, Ti<:Integer}","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.addblock!","text":"addblock!(A::FEMatrixBlock, B::ExtendableSparseMatrix{Tv, Ti<:Integer}; factor, transpose)\n\n\nAdds ExtendableSparseMatrix B to FEMatrixBlock A.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.addblock_matmul!-Tuple{FEVectorBlock, FEMatrixBlock, FEVectorBlock}","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.addblock_matmul!","text":"addblock_matmul!(a::FEVectorBlock, B::FEMatrixBlock, b::FEVectorBlock; factor)\n\n\nAdds matrix-vector product B times b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.addblock_matmul!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEVectorBlock, ExtendableSparseMatrix{Tv, Ti}, FEVectorBlock}} where {Tv, Ti<:Integer}","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.addblock_matmul!","text":"addblock_matmul!(a::FEVectorBlock, B::ExtendableSparseMatrix{Tv, Ti<:Integer}, b::FEVectorBlock; factor)\n\n\nAdds matrix-vector product B times b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.ldrdmatmul-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractVector{Tv}, AbstractVector{Tv}, ExtendableSparseMatrix{Tv, Ti}, AbstractVector{Tv}, AbstractVector{Tv}}} where {Tv, Ti<:Integer}","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.ldrdmatmul","text":"ldrdmatmul(a1::AbstractArray{Tv, 1}, a2::AbstractArray{Tv, 1}, B::ExtendableSparseMatrix{Tv, Ti<:Integer}, b1::AbstractArray{Tv, 1}, b2::AbstractArray{Tv, 1}; factor) -> Any\n\n\nComputes vector'-matrix-vector product (a1-a2)'B(b1-b2).\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.lrmatmul-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractVector{Tv}, ExtendableSparseMatrix{Tv, Ti}, AbstractVector{Tv}}} where {Tv, Ti<:Integer}","page":"FE Spaces and Arrays","title":"GradientRobustMultiPhysics.lrmatmul","text":"lrmatmul(a::AbstractArray{Tv, 1}, B::ExtendableSparseMatrix{Tv, Ti<:Integer}, b::AbstractArray{Tv, 1}; factor) -> Any\n\n\nComputes vector'-matrix-vector product a'Bb.\n\n\n\n\n\n","category":"method"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_eq/#D-Equilibration-Error-Estimation-(Global)","page":"2D Equilibration Error Estimation (Global)","title":"2D Equilibration Error Estimation (Global)","text":"","category":"section"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_eq/","page":"2D Equilibration Error Estimation (Global)","title":"2D Equilibration Error Estimation (Global)","text":"(source code)","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_eq/","page":"2D Equilibration Error Estimation (Global)","title":"2D Equilibration Error Estimation (Global)","text":"This example computes a global equilibration error estimator for the H^1 error of some H^1-conforming approximation u_h to the solution u of some Poisson problem -Delta u = f on an L-shaped domain, i.e.","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_eq/","page":"2D Equilibration Error Estimation (Global)","title":"2D Equilibration Error Estimation (Global)","text":"eta^2(sigma_h) =  sigma_h - nabla u_h ^2_L^2(T)","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_eq/","page":"2D Equilibration Error Estimation (Global)","title":"2D Equilibration Error Estimation (Global)","text":"where sigma_h is an Hdiv-conforming approximation of the exact sigma in the dual mixed problem","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_eq/","page":"2D Equilibration Error Estimation (Global)","title":"2D Equilibration Error Estimation (Global)","text":"sigma - nabla u = 0\nquad textand quad\nmathrmdiv(sigma) + f = 0","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_eq/","page":"2D Equilibration Error Estimation (Global)","title":"2D Equilibration Error Estimation (Global)","text":"by solving the problem globally.","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_eq/","page":"2D Equilibration Error Estimation (Global)","title":"2D Equilibration Error Estimation (Global)","text":"note: Note\nEquilibration error estimators yield guaranteed upper bounds (efficiency index above 1) for the H1 error possibly with some additional term that weighs in the oscillations of f, which are zero in this example, and some additional terms that quantifies the Dirichlet boundary error, which is neglected here.See the local equilibrated version for a less costly alternative.","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_eq/","page":"2D Equilibration Error Estimation (Global)","title":"2D Equilibration Error Estimation (Global)","text":"module Example_EQLshape\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing Printf\n\n# exact solution u for the Poisson problem\nfunction exact_function!(result,x::Array{<:Real,1})\n    result[1] = atan(x[2],x[1])\n    if result[1] < 0\n        result[1] += 2*pi\n    end\n    result[1] = sin(2*result[1]/3)\n    result[1] *= (x[1]^2 + x[2]^2)^(1/3)\nend\n# ... and its gradient\nfunction exact_function_gradient!(result,x::Array{<:Real,1})\n    result[1] = atan(x[2],x[1])\n    if result[1] < 0\n        result[1] += 2*pi\n    end\n    # du/dy = du/dr * sin(phi) + (1/r) * du/dphi * cos(phi)\n    result[2] = sin(2*result[1]/3) * sin(result[1]) + cos(2*result[1]/3) * cos(result[1])\n    result[2] *= (x[1]^2 + x[2]^2)^(-1/6) * 2/3\n    # du/dx = du/dr * cos(phi) - (1/r) * du/dphi * sin(phi)\n    result[1] = sin(2*result[1]/3) * cos(result[1]) - cos(2*result[1]/3) * sin(result[1])\n    result[1] *= (x[1]^2 + x[2]^2)^(-1/6) * 2/3\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, nlevels = 12, theta = 1//2, Plotter = nothing)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # initial grid\n    xgrid = grid_lshape(Triangle2D)\n\n    # choose some finite elements for primal and dual problem\n    FEType = H1P1{1}\n    FETypeDual = [HDIVBDM1{2},H1P0{1}]\n\n    # negotiate data functions to the package\n    user_function = DataFunction(exact_function!, [1,2]; name = \"u\", dependencies = \"X\", quadorder = 5)\n    user_function_gradient = DataFunction(exact_function_gradient!, [2,2]; name = \"∇(u)\", dependencies = \"X\", quadorder = 4)\n\n    # setup Poisson problem\n    Problem = PoissonProblem()\n    add_boundarydata!(Problem, 1, [2,3,4,5,6,7], BestapproxDirichletBoundary; data = user_function)\n    add_boundarydata!(Problem, 1, [1,8], HomogeneousDirichletBoundary)\n\n    # setup dual mixed Poisson problem\n    DualProblem = PDEDescription(\"dual mixed formulation\")\n    add_unknown!(DualProblem; unknown_name = \"σ\", equation_name = \"stress equation\")\n    add_operator!(DualProblem, [1,1], ReactionOperator())\n    add_rhsdata!(DualProblem, 1, RhsOperator(NormalFlux, [2,3,4,5,6,7], user_function; AT = ON_BFACES))\n    add_unknown!(DualProblem; unknown_name = \"Lagrange multiplier for divergence\", equation_name = \"divergence constraint\")\n    add_operator!(DualProblem, [1,2], LagrangeMultiplier(Divergence))\n\n    # setup exact error evaluations\n    L2ErrorEvaluator = L2ErrorIntegrator(Float64, user_function, Identity)\n    H1ErrorEvaluator = L2ErrorIntegrator(Float64, user_function_gradient, Gradient)\n    L2ErrorEvaluatorDual = L2ErrorIntegrator(Float64, user_function_gradient, Identity)\n\n    # define error estimator : || sigma_h - nabla u_h ||^2_{L^2(T)}\n    # this can be realised via a kernel function\n    function eqestimator_kernel(result, input)\n        # input = [Identity(sigma_h), Gradient(u_h)]\n        result[1] = (input[1] - input[3])^2 + (input[2] - input[4])^2\n        return nothing\n    end\n    estimator_action_kernel = ActionKernel(eqestimator_kernel, [1,4]; name = \"estimator kernel\", dependencies = \"\", quadorder = 2)\n    # ... which generates an action...\n    estimator_action = Action(Float64,estimator_action_kernel)\n    # ... which is used inside an ItemIntegrator\n    EQIntegrator = ItemIntegrator(Float64,ON_CELLS,[Identity, Gradient],estimator_action)\n\n    # refinement loop (only uniform for now)\n    NDofs = zeros(Int, nlevels)\n    NDofsDual = zeros(Int, nlevels)\n    Results = zeros(Float64, nlevels, 4)\n    Solution = nothing\n    DualSolution = nothing\n    for level = 1 : nlevels\n\n        # create a solution vector and solve the problem\n        FES = FESpace{FEType}(xgrid)\n        Solution = FEVector{Float64}(\"u_h\",FES)\n        solve!(Solution, Problem)\n        NDofs[level] = length(Solution[1])\n\n        # solve the dual problem\n        FESDual = [FESpace{FETypeDual[1]}(xgrid),FESpace{FETypeDual[2]}(xgrid)]\n        DualSolution = FEVector{Float64}(\"σ_h\",FESDual)\n        NDofsDual[level] = length(DualSolution.entries)\n        solve!(DualSolution, DualProblem)\n\n        if verbosity > 0\n            println(\"\\n  SOLVE LEVEL $level\")\n            println(\"    ndofs = $(NDofs[level])\")\n            println(\"    ndofsDual = $(NDofsDual[level])\")\n        end\n\n        # evaluate eqilibration error estimator\n        error4cell = zeros(Float64,1,num_sources(xgrid[CellNodes]))\n        evaluate!(error4cell, EQIntegrator, [DualSolution[1], Solution[1]])\n\n        # calculate L2 error, H1 error, estimator, dual L2 error and write to results\n        Results[level,1] = sqrt(evaluate(L2ErrorEvaluator,[Solution[1]]))\n        Results[level,2] = sqrt(evaluate(H1ErrorEvaluator,[Solution[1]]))\n        Results[level,3] = sqrt(sum(error4cell))\n        Results[level,4] = sqrt(evaluate(L2ErrorEvaluatorDual,[DualSolution[1]]))\n        if verbosity > 0\n            println(\"  ESTIMATE\")\n            println(\"    estim H1 error = $(Results[level,3])\")\n            println(\"    exact H1 error = $(Results[level,2])\")\n            println(\"     dual L2 error = $(Results[level,4])\")\n        end\n\n        if level == nlevels\n            break;\n        end\n\n        # mesh refinement\n        if theta >= 1\n            # uniform mesh refinement\n            xgrid = uniform_refine(xgrid)\n        else\n            # adaptive mesh refinement\n            # refine by red-green-blue refinement (incl. closuring)\n            facemarker = bulk_mark(xgrid, view(error4cell,1,:), theta)\n            xgrid = RGB_refine(xgrid, facemarker)\n        end\n    end\n\n    # plot\n    GradientRobustMultiPhysics.plot(xgrid, [Solution[1]], [Identity]; add_grid_plot = true, Plotter = Plotter)\n\n    # print results\n    @printf(\"\\n  NDOFS  |   L2ERROR      order   |   H1ERROR      order   | H1-ESTIMATOR   order      efficiency   \")\n    @printf(\"\\n=========|========================|========================|========================================\\n\")\n    order = 0\n    for j=1:nlevels\n        @printf(\"  %6d |\",NDofs[j]);\n        for k = 1 : 3\n            if j > 1\n                order = log(Results[j-1,k]/Results[j,k]) / (log(NDofs[j]/NDofs[j-1])/2)\n            end\n            @printf(\" %.5e \",Results[j,k])\n            if k == 3\n                @printf(\"   %.3f       %.3f\",order,Results[j,k]/Results[j,k-1])\n            else\n                @printf(\"   %.3f   |\",order)\n            end\n        end\n        @printf(\"\\n\")\n    end\n\nend\n\nend","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_eq/","page":"2D Equilibration Error Estimation (Global)","title":"2D Equilibration Error Estimation (Global)","text":"","category":"page"},{"location":"examples_advanced/doc_2d_lshape_adaptivity_eq/","page":"2D Equilibration Error Estimation (Global)","title":"2D Equilibration Error Estimation (Global)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_2d_stokes_probust/#D-Pressure-robustness","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"","category":"section"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"(source code)","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"This example studies two benchmarks for pressure-robust discretisations of the stationary     Navier-Stokes equations that seek a velocity mathbfu and pressure mathbfp such that","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"beginaligned\n- mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = mathbff\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"with (possibly time-dependent) exterior force mathbff and some viscosity parameter mu.","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"Pressure-robustness is concerned with gradient forces that may appear in the right-hand side or the material derivative and should be balanced by the pressure (as divergence-free vector fields are orthogonal on gradient fields). Here, two test problems are considered:","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"HydrostaticTestProblem() : Stokes (without convection term) and mathbff = nabla p such that  mathbfu = 0\nPotentialFlowTestProblem() : Navier-Stokes with mathbff = 0 and mathbfu = nabla h for some harmonic function","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"In both test problems the errors of non-pressure-robust discretisations scale with  1mu, while the pressure-robust discretisation solves mathbfu = 0 exactly in test problem 1 and gives much better results in test problem 2.","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"module Example_2DPressureRobustness\n\nusing GradientRobustMultiPhysics\nusing Printf\n\n# problem data\nfunction HydrostaticTestProblem()\n    # Stokes problem with f = grad(p)\n    # u = 0\n    # p = x^3+y^3 - 1//2\n    function P1_pressure!(result,x::Array{<:Real,1})\n        result[1] = x[1]^3 + x[2]^3 - 1//2\n    end\n    function P1_rhs!(result,x::Array{<:Real,1})\n        result[1] = 3*x[1]^2\n        result[2] = 3*x[2]^2\n    end\n    user_function_velocity = DataFunction([0,0]; name = \"u_exact\")\n    user_function_pressure = DataFunction(P1_pressure!, [1,2]; name = \"p_exact\", dependencies = \"X\", quadorder = 3)\n    user_function_velocity_gradient = DataFunction([0,0,0,0]; name = \"grad(u_exact)\")\n    user_function_rhs = DataFunction(P1_rhs!, [2,2]; name = \"f\", dependencies = \"X\", quadorder = 2)\n\n    return user_function_pressure,user_function_velocity,user_function_velocity_gradient,user_function_rhs, false\nend\n\nfunction PotentialFlowTestProblem()\n    # NavierStokes with f = 0\n    # u = grad(h) with h = x^3 - 3xy^2\n    # p = - |grad(h)|^2 + 14//5\n    function P2_pressure!(result,x::Array{<:Real,1})\n        result[1] = - 1//2 * (9*(x[1]^4 + x[2]^4) + 18*x[1]^2*x[2]^2) + 14//5\n    end\n    function P2_velo!(result,x::Array{<:Real,1})\n        result[1] = 3*x[1]^2 - 3*x[2]^2;\n        result[2] = -6*x[1]*x[2];\n    end\n    function P2_velogradient!(result,x::Array{<:Real,1})\n        result[1] = 6*x[1]\n        result[2] = -6*x[2];\n        result[3] = -6*x[2];\n        result[4] = -6*x[1];\n    end\n    user_function_velocity = DataFunction(P2_velo!, [2,2]; name = \"u_exact\", dependencies = \"X\", quadorder = 2)\n    user_function_pressure = DataFunction(P2_pressure!, [1,2]; name = \"p_exact\", dependencies = \"X\", quadorder = 4)\n    user_function_velocity_gradient = DataFunction(P2_velogradient!, [4,2]; name = \"grad(u_exact)\", dependencies = \"X\", quadorder = 1)\n    user_function_rhs = DataFunction([0,0]; name = \"f\")\n\n    return user_function_pressure,user_function_velocity,user_function_velocity_gradient,user_function_rhs, true\nend\n\n\nfunction solve(Problem, xgrid, FETypes, viscosity = 1e-2; nlevels = 3, print_results = true, verbosity = 1, target_residual = 1e-10, maxiterations = 20)\n\n    # load problem data and set solver parameters\n    ReconstructionOperator = FETypes[3]\n    exact_pressure!, exact_velocity!, exact_velocity_gradient!, rhs!, nonlinear = Problem()\n\n    # setup classical (Problem) and pressure-robust scheme (Problem2)\n    Problem = IncompressibleNavierStokesProblem(2; viscosity = viscosity, nonlinear = false)\n    add_boundarydata!(Problem, 1, [1,2,3,4], BestapproxDirichletBoundary; data = exact_velocity!)\n    Problem2 = deepcopy(Problem)\n    Problem.name = \"Stokes problem (classical)\"\n    Problem2.name = \"Stokes problem (p-robust)\"\n\n    # assign right-hand side\n    add_rhsdata!(Problem, 1, RhsOperator(Identity, [0], rhs!))\n    add_rhsdata!(Problem2, 1, RhsOperator(ReconstructionOperator, [0], rhs!))\n\n    # assign convection term\n    if nonlinear\n        add_operator!(Problem,[1,1], ConvectionOperator(1, Identity, 2, 2))\n        add_operator!(Problem2,[1,1], ConvectionOperator(1, ReconstructionOperator, 2, 2; testfunction_operator = ReconstructionOperator))\n    end\n\n    # define bestapproximation problems\n    L2VelocityBestapproximationProblem = L2BestapproximationProblem(exact_velocity!; bestapprox_boundary_regions = [1,2,3,4])\n    L2PressureBestapproximationProblem = L2BestapproximationProblem(exact_pressure!; bestapprox_boundary_regions = [])\n    H1VelocityBestapproximationProblem = H1BestapproximationProblem(exact_velocity_gradient!, exact_velocity!; bestapprox_boundary_regions = [1,2,3,4])\n\n    # define ItemIntegrators for L2/H1 error computation\n    L2VelocityErrorEvaluator = L2ErrorIntegrator(Float64, exact_velocity!, Identity)\n    L2PressureErrorEvaluator = L2ErrorIntegrator(Float64, exact_pressure!, Identity)\n    H1VelocityErrorEvaluator = L2ErrorIntegrator(Float64, exact_velocity_gradient!, Gradient)\n    L2error_velocity = []; L2error_pressure = []; L2error_velocity2 = []; L2error_pressure2 = []\n    L2errorInterpolation_velocity = []; L2errorInterpolation_pressure = []; L2errorBestApproximation_velocity = []; L2errorBestApproximation_pressure = []\n    H1error_velocity = []; H1error_velocity2 = []; H1errorBestApproximation_velocity = []; NDofs = []\n\n    # loop over refinement levels\n    for level = 1 : nlevels\n\n        # uniform mesh refinement\n        xgrid = uniform_refine(xgrid)\n        xFaceVolumes = xgrid[FaceVolumes]\n\n        # get FESpaces\n        FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid; broken = true)]\n        Solution2 = FEVector{Float64}([\"u_h (p-robust)\", \"p_h (p-robust)\"],FES)\n        Solution = FEVector{Float64}([\"u_h (classic)\", \"p_h (classic)\"],FES)\n        push!(NDofs,length(Solution.entries))\n\n        # solve both problems\n        solve!(Solution, Problem; maxiterations = maxiterations, target_residual = target_residual, anderson_iterations = 5)\n        solve!(Solution2, Problem2; maxiterations = maxiterations, target_residual = target_residual, anderson_iterations = 5)\n\n        # solve bestapproximation problems\n        L2VelocityBestapproximation = FEVector{Float64}(\"L2-Bestapproximation velocity\",FES[1])\n        L2PressureBestapproximation = FEVector{Float64}(\"L2-Bestapproximation pressure\",FES[2])\n        H1VelocityBestapproximation = FEVector{Float64}(\"H1-Bestapproximation velocity\",FES[1])\n        solve!(L2VelocityBestapproximation, L2VelocityBestapproximationProblem)\n        solve!(L2PressureBestapproximation, L2PressureBestapproximationProblem)\n        solve!(H1VelocityBestapproximation, H1VelocityBestapproximationProblem)\n\n        # compute L2 and H1 error\n        append!(L2error_velocity,sqrt(evaluate(L2VelocityErrorEvaluator,Solution[1])))\n        append!(L2error_velocity2,sqrt(evaluate(L2VelocityErrorEvaluator,Solution2[1])))\n        append!(L2errorBestApproximation_velocity,sqrt(evaluate(L2VelocityErrorEvaluator,L2VelocityBestapproximation[1])))\n        append!(L2error_pressure,sqrt(evaluate(L2PressureErrorEvaluator,Solution[2])))\n        append!(L2error_pressure2,sqrt(evaluate(L2PressureErrorEvaluator,Solution2[2])))\n        append!(L2errorBestApproximation_pressure,sqrt(evaluate(L2PressureErrorEvaluator,L2PressureBestapproximation[1])))\n        append!(H1error_velocity,sqrt(evaluate(H1VelocityErrorEvaluator,Solution[1])))\n        append!(H1error_velocity2,sqrt(evaluate(H1VelocityErrorEvaluator,Solution2[1])))\n        append!(H1errorBestApproximation_velocity,sqrt(evaluate(H1VelocityErrorEvaluator,H1VelocityBestapproximation[1])))\n\n        # print results\n        if (level == nlevels) && (print_results)\n            println(\"\\n         |   L2ERROR    |   L2ERROR    |   L2ERROR\")\n            println(\"   NDOF  | VELO-CLASSIC | VELO-PROBUST | VELO-L2BEST\");\n            for j=1:nlevels\n                @printf(\"  %6d | %.6e | %.6e | %.6e\\n\",NDofs[j],L2error_velocity[j],L2error_velocity2[j],L2errorBestApproximation_velocity[j])\n            end\n            println(\"\\n         |   H1ERROR    |   H1ERROR    |   H1ERROR\")\n            println(\"   NDOF  | VELO-CLASSIC | VELO-PROBUST | VELO-H1BEST\");\n            for j=1:nlevels\n                @printf(\"  %6d | %.6e | %.6e | %.6e\\n\",NDofs[j],H1error_velocity[j],H1error_velocity2[j],H1errorBestApproximation_velocity[j])\n            end\n            println(\"\\n         |   L2ERROR    |   L2ERROR    |   L2ERROR\")\n            println(\"   NDOF  | PRES-CLASSIC | PRES-PROBUST | PRES-L2BEST\");\n            for j=1:nlevels\n                @printf(\"  %6d | %.6e | %.6e | %.6e\\n\",NDofs[j],L2error_pressure[j],L2error_pressure2[j],L2errorBestApproximation_pressure[j])\n            end\n            println(\"\\nLEGEND\\n======\")\n            println(\"VELO-CLASSIC : discrete Stokes velocity solution ($(FES[1].name)) with classical discretisation\")\n            println(\"VELO-PROBUST : discrete Stokes velocity solution ($(FES[1].name)) with p-robust discretisation\")\n            println(\"VELO-L2BEST : L2-Bestapproximation of exact velocity (with boundary data)\")\n            println(\"VELO-H1BEST : H1-Bestapproximation of exact velocity (with boudnary data)\")\n            println(\"PRES-CLASSIC : discrete Stokes pressure solution ($(FES[2].name)) with classical discretisation\")\n            println(\"PRES-PROBUST : discrete Stokes pressure solution ($(FES[1].name)) with p-robust discretisation\")\n            println(\"PRES-L2BEST : L2-Bestapproximation of exact pressure (without boundary data)\")\n        end\n    end\n\n    # return last error for testing\n    return L2error_velocity2[end]\nend\n\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, nlevels = 3, viscosity = 1e-2)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # set problem to solve\n    #Problem = HydrostaticTestProblem\n    Problem = PotentialFlowTestProblem\n\n    # set grid and problem parameters\n    xgrid = grid_unitsquare_mixedgeometries() # initial grid\n\n    # choose finite element discretisation\n    #FETypes = [H1BR{2}, H1P0{1}, ReconstructionIdentity{HDIVRT0{2}}] # Bernardi--Raugel with RT0 reconstruction\n    FETypes = [H1BR{2}, H1P0{1}, ReconstructionIdentity{HDIVBDM1{2}}] # Bernardi--Raugel with BDM1 reconstruction\n    #FETypes = [H1CR{2}, H1P0{1}, ReconstructionIdentity{HDIVRT0{2}}] # Crouzeix--Raviart with RT0 reconstruction\n\n    # run\n    solve(Problem, xgrid, FETypes, viscosity; nlevels = nlevels)\n\n    return nothing\nend\n\n\n# test function that is called by test unit\n# tests if hydrostatic problem is solved exactly by pressure-robust methods\nfunction test()\n    xgrid = uniform_refine(grid_unitsquare_mixedgeometries())\n\n    testspaces = [[H1CR{2}, H1P0{1}, ReconstructionIdentity{HDIVRT0{2}}],\n                  [H1BR{2}, H1P0{1}, ReconstructionIdentity{HDIVRT0{2}}],\n                  [H1BR{2}, H1P0{1}, ReconstructionIdentity{HDIVBDM1{2}}]]\n    error = []\n    for FETypes in testspaces\n        push!(error, solve(HydrostaticTestProblem, xgrid, FETypes, 1; nlevels = 1, print_results = false))\n        println(\"FETypes = $FETypes   error = $(error[end])\")\n    end\n    return maximum(error)\nend\n\nend","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"Main.##268.Example_2DPressureRobustness","category":"page"},{"location":"examples/doc_2d_stokes_probust/#Output-of-default-main()-run","page":"2D Pressure-robustness","title":"Output of default main() run","text":"","category":"section"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"Example_2DPressureRobustness.main()","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"┌ Info: ----- Solving Stokes problem (classical) -----\n│ \tEquation (1.1) momentum equation : velocity >> u_h (classic) (H1BR{2}, ndofs = 98)\n│ \tEquation (1.2) incompressibility constraint : pressure >> p_h (classic) (H1P0{1} (broken), ndofs = 24)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 2.236688e-16 | 2.895609e+00\n\t      2   | 1.406203e-15 | 1.339936e+00\n\t      3   | 1.470123e-15 | 5.449108e-01\n\t      4   | 1.154716e-15 | 4.187236e-01\n\t      5   | 1.131557e-15 | 3.581365e-01\n\t      6   | 1.108805e-15 | 2.487759e-01\n\t      7   | 1.375887e-15 | 1.126170e-01\n\t      8   | 1.372339e-15 | 1.160680e-01\n\t      9   | 1.155671e-15 | 5.821474e-02\n\t     10   | 1.106859e-15 | 1.677214e-02\n\t     11   | 1.756663e-15 | 1.120038e-02\n\t     12   | 1.387269e-15 | 8.025213e-03\n\t     13   | 9.578806e-16 | 3.535567e-03\n\t     14   | 1.211301e-15 | 4.227218e-03\n\t     15   | 1.496921e-15 | 1.489109e-03\n\t     16   | 1.640563e-15 | 1.173412e-03\n\t     17   | 1.003432e-15 | 3.414371e-04\n\t     18   | 1.135826e-15 | 8.826711e-05\n\t     19   | 1.344456e-15 | 6.230044e-05\n\t     20   | 1.459423e-15 | 8.662361e-06\n┌ Warning: maxiterations reached!\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:832\n\n┌ Warning: residual was larger than desired target_residual = 1.0e-10!\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1158\n┌ Info: ----- Solving Stokes problem (p-robust) -----\n│ \tEquation (1.1) momentum equation : velocity >> u_h (p-robust) (H1BR{2}, ndofs = 98)\n│ \tEquation (1.2) incompressibility constraint : pressure >> p_h (p-robust) (H1P0{1} (broken), ndofs = 24)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 2.236688e-16 | 3.534926e+00\n\t      2   | 1.188927e-15 | 5.435230e-02\n\t      3   | 1.322675e-15 | 3.054699e-02\n\t      4   | 1.236151e-15 | 3.059500e-02\n\t      5   | 1.367311e-15 | 6.895439e-03\n\t      6   | 1.238878e-15 | 4.410285e-03\n\t      7   | 1.350141e-15 | 1.791402e-03\n\t      8   | 1.416202e-15 | 7.588429e-04\n\t      9   | 1.846389e-15 | 1.307062e-04\n\t     10   | 1.521539e-15 | 2.445028e-05\n\t     11   | 1.256126e-15 | 1.159652e-05\n\t     12   | 8.784343e-16 | 2.445646e-06\n\t     13   | 1.479338e-15 | 1.143082e-06\n\t     14   | 1.349106e-15 | 1.031267e-07\n\t     15   | 1.121685e-15 | 2.687431e-08\n\t     16   | 1.475961e-15 | 9.406191e-09\n\t     17   | 1.248557e-15 | 4.387991e-09\n\t     18   | 1.067293e-15 | 5.760525e-10\n\t     19   | 1.361425e-15 | 1.089005e-10\n\t     20   | 1.532908e-15 | 4.340769e-11\n\n┌ Info: ----- Solving L2-Bestapproximation problem -----\n│ \tEquation (1.1) L2-bestapproximation equation : u_exact >> L2-Bestapproximation velocity (H1BR{2}, ndofs = 98)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 8.793101870809588e-17\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving L2-Bestapproximation problem -----\n│ \tEquation (1.1) L2-bestapproximation equation : p_exact >> L2-Bestapproximation pressure (H1P0{1} (broken), ndofs = 24)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 6.397344083151129e-17\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving H1-Bestapproximation problem -----\n│ \tEquation (1.1) H1-bestapproximation equation : u_exact >> H1-Bestapproximation velocity (H1BR{2}, ndofs = 98)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 4.0790180705249145e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving Stokes problem (classical) -----\n│ \tEquation (1.1) momentum equation : velocity >> u_h (classic) (H1BR{2}, ndofs = 338)\n│ \tEquation (1.2) incompressibility constraint : pressure >> p_h (classic) (H1P0{1} (broken), ndofs = 96)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 2.276542e-16 | 1.841178e+00\n\t      2   | 1.375485e-15 | 3.185853e-01\n\t      3   | 1.563978e-15 | 6.501545e-02\n\t      4   | 1.366699e-15 | 1.931097e-02\n\t      5   | 1.408674e-15 | 6.847968e-03\n\t      6   | 1.450240e-15 | 6.699510e-03\n\t      7   | 1.539588e-15 | 2.290010e-03\n\t      8   | 1.428069e-15 | 1.178035e-03\n\t      9   | 1.259090e-15 | 2.019969e-04\n\t     10   | 1.222971e-15 | 3.661873e-05\n\t     11   | 1.385393e-15 | 2.226621e-05\n\t     12   | 1.144956e-15 | 4.055847e-06\n\t     13   | 1.362287e-15 | 9.572098e-07\n\t     14   | 1.298056e-15 | 2.268293e-07\n\t     15   | 1.460703e-15 | 8.131273e-08\n\t     16   | 1.501211e-15 | 2.318637e-08\n\t     17   | 1.513053e-15 | 6.883499e-09\n\t     18   | 1.531744e-15 | 1.392542e-09\n\t     19   | 1.620489e-15 | 1.159120e-09\n\t     20   | 1.221942e-15 | 2.472836e-10\n┌ Warning: maxiterations reached!\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:832\n\n┌ Warning: residual was larger than desired target_residual = 1.0e-10!\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1158\n┌ Info: ----- Solving Stokes problem (p-robust) -----\n│ \tEquation (1.1) momentum equation : velocity >> u_h (p-robust) (H1BR{2}, ndofs = 338)\n│ \tEquation (1.2) incompressibility constraint : pressure >> p_h (p-robust) (H1P0{1} (broken), ndofs = 96)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 2.276542e-16 | 2.190743e+00\n\t      2   | 1.357890e-15 | 4.814096e-03\n\t      3   | 1.795018e-15 | 1.359334e-03\n\t      4   | 1.671335e-15 | 6.018365e-04\n\t      5   | 1.398513e-15 | 3.277272e-04\n\t      6   | 1.358698e-15 | 1.231593e-04\n\t      7   | 1.483829e-15 | 3.396347e-05\n\t      8   | 1.604454e-15 | 1.207964e-05\n\t      9   | 1.217958e-15 | 2.518529e-06\n\t     10   | 1.489488e-15 | 4.715978e-07\n\t     11   | 1.642164e-15 | 5.111220e-08\n\t     12   | 1.539655e-15 | 1.958835e-08\n\t     13   | 1.685683e-15 | 4.776487e-09\n\t     14   | 1.576938e-15 | 2.834607e-09\n\t     15   | 1.577950e-15 | 4.306005e-10\n\t     16   | 1.366062e-15 | 7.896022e-11\n\n┌ Info: ----- Solving L2-Bestapproximation problem -----\n│ \tEquation (1.1) L2-bestapproximation equation : u_exact >> L2-Bestapproximation velocity (H1BR{2}, ndofs = 338)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 5.674290057487142e-17\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving L2-Bestapproximation problem -----\n│ \tEquation (1.1) L2-bestapproximation equation : p_exact >> L2-Bestapproximation pressure (H1P0{1} (broken), ndofs = 96)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 2.9079327530521867e-17\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving H1-Bestapproximation problem -----\n│ \tEquation (1.1) H1-bestapproximation equation : u_exact >> H1-Bestapproximation velocity (H1BR{2}, ndofs = 338)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 7.645707624544993e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving Stokes problem (classical) -----\n│ \tEquation (1.1) momentum equation : velocity >> u_h (classic) (H1BR{2}, ndofs = 1250)\n│ \tEquation (1.2) incompressibility constraint : pressure >> p_h (classic) (H1P0{1} (broken), ndofs = 384)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 2.686069e-16 | 1.037693e+00\n\t      2   | 1.448536e-15 | 6.205070e-02\n\t      3   | 1.424340e-15 | 1.370371e-02\n\t      4   | 1.457456e-15 | 2.735524e-03\n\t      5   | 1.441272e-15 | 7.618342e-04\n\t      6   | 1.415357e-15 | 1.733140e-04\n\t      7   | 1.554767e-15 | 5.850901e-05\n\t      8   | 1.503966e-15 | 1.581379e-05\n\t      9   | 1.693408e-15 | 2.639635e-06\n\t     10   | 1.526648e-15 | 6.144868e-07\n\t     11   | 1.590250e-15 | 1.471499e-07\n\t     12   | 1.411224e-15 | 2.695707e-08\n\t     13   | 1.469065e-15 | 7.264071e-09\n\t     14   | 1.416326e-15 | 1.921211e-09\n\t     15   | 1.463785e-15 | 6.053306e-10\n\t     16   | 1.380188e-15 | 1.141194e-10\n\t     17   | 1.520177e-15 | 1.738955e-11\n\n┌ Info: ----- Solving Stokes problem (p-robust) -----\n│ \tEquation (1.1) momentum equation : velocity >> u_h (p-robust) (H1BR{2}, ndofs = 1250)\n│ \tEquation (1.2) incompressibility constraint : pressure >> p_h (p-robust) (H1P0{1} (broken), ndofs = 384)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 2.686069e-16 | 1.217573e+00\n\t      2   | 1.667153e-15 | 5.548380e-04\n\t      3   | 1.464032e-15 | 1.241344e-04\n\t      4   | 1.688014e-15 | 3.784206e-05\n\t      5   | 1.418778e-15 | 1.066551e-05\n\t      6   | 1.434077e-15 | 4.499323e-06\n\t      7   | 1.328256e-15 | 8.200007e-07\n\t      8   | 1.678580e-15 | 1.295708e-07\n\t      9   | 1.542875e-15 | 2.819667e-08\n\t     10   | 1.497246e-15 | 6.869162e-09\n\t     11   | 1.538070e-15 | 1.173502e-09\n\t     12   | 1.485170e-15 | 2.554460e-10\n\t     13   | 1.405945e-15 | 6.348800e-11\n\n┌ Info: ----- Solving L2-Bestapproximation problem -----\n│ \tEquation (1.1) L2-bestapproximation equation : u_exact >> L2-Bestapproximation velocity (H1BR{2}, ndofs = 1250)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 2.8473168302263085e-17\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving L2-Bestapproximation problem -----\n│ \tEquation (1.1) L2-bestapproximation equation : p_exact >> L2-Bestapproximation pressure (H1P0{1} (broken), ndofs = 384)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 1.452710330354492e-17\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving H1-Bestapproximation problem -----\n│ \tEquation (1.1) H1-bestapproximation equation : u_exact >> H1-Bestapproximation velocity (H1BR{2}, ndofs = 1250)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 1.879363551185322e-14\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\n         |   L2ERROR    |   L2ERROR    |   L2ERROR\n   NDOF  | VELO-CLASSIC | VELO-PROBUST | VELO-L2BEST\n     122 | 1.115427e+00 | 1.185048e-01 | 2.549211e-02\n     434 | 4.811121e-01 | 1.226291e-02 | 5.780660e-03\n    1634 | 1.594731e-01 | 2.651293e-03 | 1.354123e-03\n\n         |   H1ERROR    |   H1ERROR    |   H1ERROR\n   NDOF  | VELO-CLASSIC | VELO-PROBUST | VELO-H1BEST\n     122 | 2.013133e+01 | 1.986810e+00 | 6.761824e-01\n     434 | 1.342457e+01 | 4.181144e-01 | 3.345863e-01\n    1634 | 8.677229e+00 | 1.762244e-01 | 1.663414e-01\n\n         |   L2ERROR    |   L2ERROR    |   L2ERROR\n   NDOF  | PRES-CLASSIC | PRES-PROBUST | PRES-L2BEST\n     122 | 1.711193e+00 | 1.073721e+00 | 1.070511e+00\n     434 | 7.673590e-01 | 5.464474e-01 | 5.463668e-01\n    1634 | 3.507166e-01 | 2.746130e-01 | 2.745972e-01\n\nLEGEND\n======\nVELO-CLASSIC : discrete Stokes velocity solution (H1BR{2}) with classical discretisation\nVELO-PROBUST : discrete Stokes velocity solution (H1BR{2}) with p-robust discretisation\nVELO-L2BEST : L2-Bestapproximation of exact velocity (with boundary data)\nVELO-H1BEST : H1-Bestapproximation of exact velocity (with boudnary data)\nPRES-CLASSIC : discrete Stokes pressure solution (H1P0{1} (broken)) with classical discretisation\nPRES-PROBUST : discrete Stokes pressure solution (H1BR{2}) with p-robust discretisation\nPRES-L2BEST : L2-Bestapproximation of exact pressure (without boundary data)\n","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"","category":"page"},{"location":"examples/doc_2d_stokes_probust/","page":"2D Pressure-robustness","title":"2D Pressure-robustness","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples_intro/#How-to-run-the-examples","page":"How to run the examples","title":"How to run the examples","text":"","category":"section"},{"location":"examples_intro/","page":"How to run the examples","title":"How to run the examples","text":"Note that all examples are written inside their own modules. To start an example you usually have to include the file and then run the main() function from the example module. The default configuration of the introductory examples is started automatically after include. Some examples have optional argument, e.g. Plotter = PyPlot, to produce some plots with PyPlot (using PyPlot reuqired beforehand) or change other parameters.","category":"page"},{"location":"examples_intro/","page":"How to run the examples","title":"How to run the examples","text":"Here is an example how to start the example in \"examples/doc_2d_compressiblestokes.jl\":","category":"page"},{"location":"examples_intro/","page":"How to run the examples","title":"How to run the examples","text":"# include example file, e.g.:\ninclude(\"examples_advanced/doc_2d_compressiblestokes.jl\")\n# as a result some module is loaded, in this case Example_2DCompressibleStokes\n\n# run without graphics output\nExample_2DCompressibleStokes.main()\n\n# run with PyPlot graphics output\nusing PyPlot\nExample_2DCompressibleStokes.main(; Plotter = PyPlot)","category":"page"},{"location":"examples_intro/","page":"How to run the examples","title":"How to run the examples","text":"Also note, that if you make changes to the example files you have to include them again!","category":"page"},{"location":"meshing/#Meshing","page":"Meshing","title":"Meshing","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"Meshes are stored as an ExtendableGrid, see ExtendableGrids.jl for details and constructors. Grid generators for simplex grids can be found e.g. in the external module SimplexGridFactory.jl","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"Cells, faces and edges of the mesh are associated to AbstractElementGeometries (defined by ExtendableGrids.jl) that are used to dispatch functionality (local/global transformation, enumeration rules, set of basis functions, volume calculation, refinements etc.). See below for a list of recognized element geometries.","category":"page"},{"location":"meshing/#Available-Global-Mesh-Manipulations","page":"Meshing","title":"Available Global Mesh Manipulations","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"meshrefinements.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"meshing/#GradientRobustMultiPhysics.barycentric_refine-Union{Tuple{ExtendableGrid{T, K}}, Tuple{K}, Tuple{T}} where {T, K}","page":"Meshing","title":"GradientRobustMultiPhysics.barycentric_refine","text":"generates a new ExtendableGrid by barycentric refinement of each cell in the source grid\n\nbarycentric refinement is available for these ElementGeometries\n\nQuadrilateral2D (first split into Triangle2D)\nTriangle2D\n\n\n\n\n\n","category":"method"},{"location":"meshing/#GradientRobustMultiPhysics.split_grid_into-Union{Tuple{K}, Tuple{T}, Tuple{ExtendableGrid{T, K}, Type{var\"#s63\"} where var\"#s63\"<:AbstractElementGeometry}} where {T, K}","page":"Meshing","title":"GradientRobustMultiPhysics.split_grid_into","text":"split_grid_into(source_grid::ExtendableGrid{T, K}, targetgeometry::Type{var\"#s63\"} where var\"#s63\"<:AbstractElementGeometry) -> ExtendableGrid{_A, _B} where {_A, _B}\n\n\ngenerates a new ExtendableGrid by splitting each cell into subcells of the specified targetgeometry\n\nsplit rules exist for\n\nQuadrilateral2D into Triangle2D\nHexahedron3D into Tetrahedron3D\n\n\n\n\n\n","category":"method"},{"location":"meshing/#GradientRobustMultiPhysics.uniform_refine-Union{Tuple{ExtendableGrid{T, K}}, Tuple{K}, Tuple{T}} where {T, K}","page":"Meshing","title":"GradientRobustMultiPhysics.uniform_refine","text":"generates a new ExtendableGrid by uniform refinement of each cell in the given grid\n\nuniform refinement rules are available for these AbstractElementGeometries:\n\nLine1D (bisection into two subsegments)\nTriangle2D (red refinement into four subtriangles)\nQuadrilateral2D (into four subquadrilaterals)\nTetrahedron (into eight subtetrahedrons, but seems buggy)\nHexahedron (into eight subhexahedrons)\n\nif multiple geometries are in the mesh uniform refinement will only work if all refinement rules refine faces and edges (in 3D) equally (so no hanging nodes are created)\n\n\n\n\n\n","category":"method"},{"location":"meshing/#Recognized-Geometries-and-Reference-Domains","page":"Meshing","title":"Recognized Geometries and Reference Domains","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"The following list contains all recognized subtypes of ExtendableGrids.AbstractElementGeometries and their reference geometries. Moreover, each geometry has a number of rules that define the geometries and the local enumeration of its nodes, faces and edges, see source code of shape_specs.jl for details","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Edge1D-:-AbstractElementGeometry1D","page":"Meshing","title":"Edge1D <: AbstractElementGeometry1D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[1]-----[2]               [1] = [0]\n                          [2] = [1]","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Triangle2D","page":"Meshing","title":"Triangle2D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[3]                 \n | \\   \n |   \\                    [1] = [0,0]\n |     \\                  [2] = [1,0]\n |       \\                [3] = [0,1]\n |         \\ \n[1]--------[2]","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Parallelogram2D-:-Quadrilateral2D","page":"Meshing","title":"Parallelogram2D <: Quadrilateral2D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[4]--------[3]               \n |          |             [1] = [0,0]\n |          |             [2] = [1,0]\n |          |             [3] = [1,1]\n |          |             [4] = [0,1]\n[1]--------[2]\n\nNote: most finite elements only work as intended on Parallelogram2D\n      since the local<>global map stays affine in this case","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Tetrahedron3D","page":"Meshing","title":"Tetrahedron3D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[4]                 \n |\\\\   \n | \\ \\                    [1] = [0,0,0]\n |  \\  \\                  [2] = [1,0,0]\n |   \\   \\                [3] = [0,1,0]\n | _-[3]-_ \\              [4] = [0,0,1]\n[1]--------[2]","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Parallelepiped3D-:-Hexahedron3D","page":"Meshing","title":"Parallelepiped3D <: Hexahedron3D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"    [8]--------[7]        [1] = [0,0,0]\n   / |        / |         [2] = [1,0,0]\n[5]--------[6]  |         [3] = [1,1,0]\n |   |      |   |         [4] = [0,1,0]\n |   |      |   |         [5] = [0,0,1]\n |  [4]-----|--[3]        [6] = [1,0,1]\n | /        | /           [7] = [1,1,1]\n[1]--------[2]            [8] = [0,1,1]\n\nNote: most finite elements only work as intended on Parallelepiped3D\n      since the local<>global map stays affine in this case","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/#D-Convection-Diffusion-Problem","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"","category":"section"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"(source code)","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"This example computes the solution of some convection-diffusion problem","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"-nu Delta u + mathbfbeta cdot nabla u = f quad textin  Omega","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"with some diffusion coefficient  nu, some vector-valued function  mathbfbeta and inhomogeneous Dirichlet boundary data.","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"We prescribe an analytic solution and check the L2 and H1 error convergence of the method on a series of uniformly refined meshes. We also compare with the error of a simple nodal interpolation and plot the solution and the norm of its gradient.","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"For small nu, the convection term dominates and pollutes the accuracy of the method. For demonstration some simple gradient jump (interior penalty) stabilisation is added to improve things.","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"module Example_2DConvectionDiffusion\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing Printf\n\n# problem data and expected exact solution\nfunction exact_solution!(result,x::Array{<:Real,1})\n    result[1] = x[1]*x[2]*(x[1]-1)*(x[2]-1) + x[1]\nend\nfunction exact_solution_gradient!(result,x::Array{<:Real,1})\n    result[1] = x[2]*(2*x[1]-1)*(x[2]-1) + 1\n    result[2] = x[1]*(2*x[2]-1)*(x[1]-1)\nend\nfunction exact_solution_rhs!(diffusion)\n    function closure(result,x::Array{<:Real,1})\n        # diffusion part\n        result[1] = -diffusion*(2*x[2]*(x[2]-1) + 2*x[1]*(x[1]-1))\n        # convection part (beta * grad(u))\n        result[1] += x[2]*(2*x[1]-1)*(x[2]-1) + 1\n        return nothing\n    end\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, Plotter = nothing, diffusion = 1e-5, stabilisation = 2e-2, nlevels = 5)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # load a mesh of the unit square (this one has triangles and quads in it)\n    # it also has four boundary regions (1 = bottom, 2 = right, 3 = top, 4 = left)\n    # used below to prescribe the boundary data\n    xgrid = grid_unitsquare_mixedgeometries(); # initial grid\n\n    # negotiate data functions to the package\n    user_function = DataFunction(exact_solution!, [1,2]; name = \"u\", dependencies = \"X\", quadorder = 4)\n    user_function_gradient = DataFunction(exact_solution_gradient!, [2,2]; name = \"∇(u)\", dependencies = \"X\", quadorder = 3)\n    user_function_rhs = DataFunction(exact_solution_rhs!(diffusion), [1,2]; name = \"f\", dependencies = \"X\", quadorder = 3)\n    user_function_convection = DataFunction([1,0]; name = \"β\")\n\n    # choose a finite element type, here we choose a second order H1-conforming one\n    FEType = H1P2{1,2}\n\n    # create PDE description\n    Problem = PDEDescription(\"convection-diffusion problem\")\n    add_unknown!(Problem; unknown_name = \"u\", equation_name = \"convection-diffusion equation\")\n    add_operator!(Problem, [1,1], LaplaceOperator(diffusion))\n    add_operator!(Problem, [1,1], ConvectionOperator(user_function_convection,1))\n\n    # add right-hand side data to equation 1 (there is only one in this example)\n    add_rhsdata!(Problem, 1, RhsOperator(Identity, [0], user_function_rhs))\n\n    # add boundary data to unknown 1 (there is only one in this example)\n    # on boundary regions where the solution is linear the data only needs to be interpolated\n    # on boundary regions where the solution is zero homoegeneous boundary conditions can be used\n    add_boundarydata!(Problem, 1, [1,3], BestapproxDirichletBoundary; data = user_function)\n    add_boundarydata!(Problem, 1, [2], InterpolateDirichletBoundary; data = user_function)\n    add_boundarydata!(Problem, 1, [4], HomogeneousDirichletBoundary)\n\n    # add a gradient jump (interior penalty) stabilisation for dominant convection\n    if stabilisation > 0\n        # first we define an item-dependent action kernel...\n        xFaceVolumes::Array{Float64,1} = xgrid[FaceVolumes]\n        function stabilisation_kernel(result, input, item)\n            for j = 1 : length(input)\n                result[j] = input[j] * stabilisation * xFaceVolumes[item]^2\n            end\n            return nothing\n        end\n        # ... which generates an action\n        stab_action = Action(Float64,stabilisation_kernel, [2,2]; name = \"stabilisation action\", dependencies = \"I\", quadorder = 0 )\n        # ... which is given to a bilinear form constructor\n        JumpStabilisation = AbstractBilinearForm([Jump(Gradient), Jump(Gradient)], stab_action; AT = ON_IFACES, name = \"s |F|^2 [∇(u)]⋅[∇(v)]\")\n        add_operator!(Problem, [1,1], JumpStabilisation)\n    end\n\n    # finally we have a look at the defined problem\n    @show Problem\n\n    # define ItemIntegrators for L2/H1 error computation and some arrays to store the errors\n    L2ErrorEvaluator = L2ErrorIntegrator(Float64, user_function, Identity)\n    H1ErrorEvaluator = L2ErrorIntegrator(Float64, user_function_gradient, Gradient)\n    L2error = []; H1error = []; L2errorInterpolation = []; H1errorInterpolation = []; NDofs = []\n\n    # refinement loop over levels\n    for level = 1 : nlevels\n\n        # uniform mesh refinement\n        xgrid = uniform_refine(xgrid)\n        xFaceVolumes = xgrid[FaceVolumes] # update xFaceVolumes used in stabilisation definition\n\n        # generate FESpace and solution vector\n        FES = FESpace{FEType}(xgrid)\n        Solution = FEVector{Float64}(\"u_h\",FES)\n        push!(NDofs,length(Solution.entries))\n\n        # solve PDE\n        solve!(Solution, Problem)\n\n        # interpolate (just for comparison)\n        Interpolation = FEVector{Float64}(\"I(u)\",FES)\n        interpolate!(Interpolation[1], user_function)\n\n        # compute L2 and H1 error\n        append!(L2error,sqrt(evaluate(L2ErrorEvaluator,Solution[1])))\n        append!(L2errorInterpolation,sqrt(evaluate(L2ErrorEvaluator,Interpolation[1])))\n        append!(H1error,sqrt(evaluate(H1ErrorEvaluator,Solution[1])))\n        append!(H1errorInterpolation,sqrt(evaluate(H1ErrorEvaluator,Interpolation[1])))\n\n        # plot\n        GradientRobustMultiPhysics.plot(xgrid, [Solution[1], Solution[1]], [Identity, Gradient]; Plotter = Plotter)\n    end\n\n    # print error history\n    println(\"\\n         |   L2ERROR   |   L2ERROR\")\n    println(\"   NDOF  |   SOLUTION  |   INTERPOL\");\n    for j=1:nlevels\n        @printf(\"  %6d | %.5e | %.5e\\n\",NDofs[j],L2error[j],L2errorInterpolation[j]);\n    end\n    println(\"\\n         |   H1ERROR   |   H1ERROR\")\n    println(\"   NDOF  |   SOLUTION  |   INTERPOL\");\n    for j=1:nlevels\n        @printf(\"  %6d | %.5e | %.5e\\n\",NDofs[j],H1error[j],H1errorInterpolation[j]);\n    end\nend\n\nend","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"Main.##260.Example_2DConvectionDiffusion","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/#Output-of-default-main()-run","page":"2D Convection-Diffusion-Problem","title":"Output of default main() run","text":"","category":"section"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"Example_2DConvectionDiffusion.main()","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"\nPDE-DESCRIPTION\n===============\n  system name = convection-diffusion problem\n\n     id   | unknown name / equation name\n    [1]   | u / convection-diffusion equation \n\n  LHS block | PDEOperator(s)\n    [1,1]   | 1.0e-5 ∇(u):∇(v) (regions = [0])\n            | (β ⋅ ∇) u ⋅ id(v) (regions = [0])\n            | s |F|^2 [∇(u)]⋅[∇(v)] (regions = [0])\n\n  RHS block | PDEOperator(s)\n     [1]    | f⋅id(v) (regions = [0])\n\n   BoundaryOperator[1] : BestapproxDirichletBoundary -> [1, 3]\n                         InterpolateDirichletBoundary -> [2]\n                         HomogeneousDirichletBoundary -> [4]\n                          \n\nProblem = \n┌ Info: ----- Solving convection-diffusion problem -----\n│ \tEquation (1.1) convection-diffusion equation : u >> u_h (H1P2{1,2}, ndofs = 73)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 3.989064205000807e-16\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving convection-diffusion problem -----\n│ \tEquation (1.1) convection-diffusion equation : u >> u_h (H1P2{1,2}, ndofs = 257)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 5.042371537024805e-16\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving convection-diffusion problem -----\n│ \tEquation (1.1) convection-diffusion equation : u >> u_h (H1P2{1,2}, ndofs = 961)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 5.332898914828742e-16\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving convection-diffusion problem -----\n│ \tEquation (1.1) convection-diffusion equation : u >> u_h (H1P2{1,2}, ndofs = 3713)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 7.203827847393713e-16\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving convection-diffusion problem -----\n│ \tEquation (1.1) convection-diffusion equation : u >> u_h (H1P2{1,2}, ndofs = 14593)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 5.928956093502033e-16\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\n         |   L2ERROR   |   L2ERROR\n   NDOF  |   SOLUTION  |   INTERPOL\n      73 | 5.06404e-04 | 2.63439e-04\n     257 | 5.68101e-05 | 2.78520e-05\n     961 | 6.48860e-06 | 3.30383e-06\n    3713 | 7.73644e-07 | 4.07237e-07\n   14593 | 9.45091e-08 | 5.07235e-08\n\n         |   H1ERROR   |   H1ERROR\n   NDOF  |   SOLUTION  |   INTERPOL\n      73 | 9.79278e-03 | 7.64421e-03\n     257 | 2.25428e-03 | 1.84899e-03\n     961 | 5.29959e-04 | 4.58288e-04\n    3713 | 1.27610e-04 | 1.14323e-04\n   14593 | 3.12912e-05 | 2.85652e-05\n","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"","category":"page"},{"location":"examples/doc_2d_convectiondiffusion/","page":"2D Convection-Diffusion-Problem","title":"2D Convection-Diffusion-Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_2d_bestapprox_curlpreserve/#D-Curl-Preserving-L2-Bestapproximation","page":"2D Curl-Preserving L2-Bestapproximation","title":"2D Curl-Preserving L2-Bestapproximation","text":"","category":"section"},{"location":"examples/doc_2d_bestapprox_curlpreserve/","page":"2D Curl-Preserving L2-Bestapproximation","title":"2D Curl-Preserving L2-Bestapproximation","text":"(source code)","category":"page"},{"location":"examples/doc_2d_bestapprox_curlpreserve/","page":"2D Curl-Preserving L2-Bestapproximation","title":"2D Curl-Preserving L2-Bestapproximation","text":"This example computes the L2-bestapproximation of some given vector-valued function into the lowest-order Nedelec space. It also preserves the curl of the function in the sense that the curl of the approximation equals the piecewise integral mean of the exact curl. Afterwards the L2 error (also of the curl) is computed and the solution is plotted.","category":"page"},{"location":"examples/doc_2d_bestapprox_curlpreserve/","page":"2D Curl-Preserving L2-Bestapproximation","title":"2D Curl-Preserving L2-Bestapproximation","text":"module Example_2DBestapproxCurlpreserve\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\n\n# define some vector field that should be approximated\nfunction exact_function!(result,x::Array{<:Real,1})\n    result[1] = x[1]^3+x[2]^2\n    result[2] = -x[1]^2 + x[2] + 1\nend\n# define its curl = -du2/dx1 + du1/dx2\nfunction exact_curl!(result,x::Array{<:Real,1})\n    result[1] = 2 * x[2] + 2 * x[1]\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, Plotter = nothing)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # generate a unit square mesh and refine\n    xgrid = simplexgrid([0.0,1.0],[0.0,1.0])\n    xgrid = uniform_refine(xgrid,4)\n\n    # negotiate exact_function! and exact_curl! to the package\n    user_function = DataFunction(exact_function!, [2,2]; name = \"u\", dependencies = \"X\", quadorder = 3)\n    user_function_curl = DataFunction(exact_curl!, [1,2]; name = \"curl(u)\", dependencies = \"X\", quadorder = 1)\n\n    # setup a bestapproximation problem via a predefined prototype\n    Problem = L2BestapproximationProblem(user_function; bestapprox_boundary_regions = [1,2,3,4])\n\n    # add a new unknown (Lagrange multiplier that handles the curl constraint)\n    # here 1 is the number of components (it is scalar-valued) and 2 is the space dimension\n    add_unknown!(Problem; unknown_name = \"p\", equation_name = \"curl constraint\")\n    add_operator!(Problem, [1,2], LagrangeMultiplier(Curl2D))\n\n    # add the right-hand side data for the constraint and inspect the defined problem\n    add_rhsdata!(Problem, 2, RhsOperator(Identity, [0], user_function_curl))\n    @show Problem\n\n    # choose some (inf-sup stable) finite element types\n    FEType = [HCURLN0{2}, H1P0{1}]\n    FES = [FESpace{FEType[1]}(xgrid),FESpace{FEType[2]}(xgrid)]\n\n    # create a solution vector and solve the problem\n    Solution = FEVector{Float64}([\"u_h\",\"p_h\"],FES)\n    solve!(Solution, Problem)\n\n    # calculate L2 error and L2 curl error\n    L2ErrorEvaluator = L2ErrorIntegrator(Float64, user_function, Identity)\n    L2CurlErrorEvaluator = L2ErrorIntegrator(Float64, user_function_curl, Curl2D)\n    println(\"|| u - u_h || = $(sqrt(evaluate(L2ErrorEvaluator,Solution[1])))\")\n    println(\"|| curl(u - u_h) || = $(sqrt(evaluate(L2CurlErrorEvaluator,Solution[1])))\")\n\n    # plot\n    GradientRobustMultiPhysics.plot(xgrid, [Solution[1], Solution[1]], [Identity, Curl2D]; Plotter = Plotter)\nend\n\nend","category":"page"},{"location":"examples/doc_2d_bestapprox_curlpreserve/","page":"2D Curl-Preserving L2-Bestapproximation","title":"2D Curl-Preserving L2-Bestapproximation","text":"Main.##258.Example_2DBestapproxCurlpreserve","category":"page"},{"location":"examples/doc_2d_bestapprox_curlpreserve/#Output-of-default-main()-run","page":"2D Curl-Preserving L2-Bestapproximation","title":"Output of default main() run","text":"","category":"section"},{"location":"examples/doc_2d_bestapprox_curlpreserve/","page":"2D Curl-Preserving L2-Bestapproximation","title":"2D Curl-Preserving L2-Bestapproximation","text":"Example_2DBestapproxCurlpreserve.main()","category":"page"},{"location":"examples/doc_2d_bestapprox_curlpreserve/","page":"2D Curl-Preserving L2-Bestapproximation","title":"2D Curl-Preserving L2-Bestapproximation","text":"\nPDE-DESCRIPTION\n===============\n  system name = L2-Bestapproximation problem\n\n     id   | unknown name / equation name\n    [1]   | u / L2-bestapproximation equation \n    [2]   | p / curl constraint \n\n  LHS block | PDEOperator(s)\n    [1,1]   | u ⋅ v (regions = [0])\n    [1,2]   | Curl(v) ⋅ q (regions = [0])\n    [2,1]   | none\n    [2,2]   | none\n\n  RHS block | PDEOperator(s)\n     [1]    | u⋅id(v) (regions = [0])\n     [2]    | curl(u)⋅id(v) (regions = [0])\n\n   BoundaryOperator[1] : BestapproxDirichletBoundary -> [1, 2, 3, 4]\n                         \n   BoundaryOperator[2] : \n\nProblem = \n┌ Info: ----- Solving L2-Bestapproximation problem -----\n│ \tEquation (1.1) L2-bestapproximation equation : u >> u_h (HCURLN0{2}, ndofs = 800)\n│ \tEquation (1.2) curl constraint : p >> p_h (H1P0{1} (broken), ndofs = 512)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 1.496430412122555e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n|| u - u_h || = 0.031068414520129824\n|| curl(u - u_h) || = 0.051031036307982836\n","category":"page"},{"location":"examples/doc_2d_bestapprox_curlpreserve/","page":"2D Curl-Preserving L2-Bestapproximation","title":"2D Curl-Preserving L2-Bestapproximation","text":"","category":"page"},{"location":"examples/doc_2d_bestapprox_curlpreserve/","page":"2D Curl-Preserving L2-Bestapproximation","title":"2D Curl-Preserving L2-Bestapproximation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples_advanced/doc_2d_stokes_hdiv-dg/#D-DG-Hdiv-discretisation-for-Stokes","page":"2D DG-Hdiv discretisation for Stokes","title":"2D DG-Hdiv discretisation for Stokes","text":"","category":"section"},{"location":"examples_advanced/doc_2d_stokes_hdiv-dg/","page":"2D DG-Hdiv discretisation for Stokes","title":"2D DG-Hdiv discretisation for Stokes","text":"(source code)","category":"page"},{"location":"examples_advanced/doc_2d_stokes_hdiv-dg/","page":"2D DG-Hdiv discretisation for Stokes","title":"2D DG-Hdiv discretisation for Stokes","text":"This example computes a velocity mathbfu and pressure mathbfp of the incompressible Navier–Stokes problem","category":"page"},{"location":"examples_advanced/doc_2d_stokes_hdiv-dg/","page":"2D DG-Hdiv discretisation for Stokes","title":"2D DG-Hdiv discretisation for Stokes","text":"beginaligned\n- mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = mathbff\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"examples_advanced/doc_2d_stokes_hdiv-dg/","page":"2D DG-Hdiv discretisation for Stokes","title":"2D DG-Hdiv discretisation for Stokes","text":"with exterior force mathbff and some viscosity parameter mu and inhomogeneous Dirichlet boundary data.","category":"page"},{"location":"examples_advanced/doc_2d_stokes_hdiv-dg/","page":"2D DG-Hdiv discretisation for Stokes","title":"2D DG-Hdiv discretisation for Stokes","text":"The problem will be solved by a dicontinuous Galerkin method with Hdiv-conforming ansatz space (e.g. BDM1). The normal components of the velocity are fixed by the boundary data, while the tangential boundary fluxes are handled by the DG discretisation of the Laplacian that involves several discontinuous terms on faces mathcalF, i.e.","category":"page"},{"location":"examples_advanced/doc_2d_stokes_hdiv-dg/","page":"2D DG-Hdiv discretisation for Stokes","title":"2D DG-Hdiv discretisation for Stokes","text":"beginaligned\na_h(u_hv_h) = mu Bigl( int nabla_h u_h  nabla_h v_h dx +  sum_F in mathcalF fraclambdah_F int_F u_h cdot v_h ds - int_F nabla_h u_h n_F cdot v_h ds\n - int_F u_h cdot nabla_h v_h n_F ds Bigr)\nendaligned","category":"page"},{"location":"examples_advanced/doc_2d_stokes_hdiv-dg/","page":"2D DG-Hdiv discretisation for Stokes","title":"2D DG-Hdiv discretisation for Stokes","text":"and similar terms on the right-hand side for the inhomogeneous Dirichlet data. The qunatity lambda is the SIP parameter.","category":"page"},{"location":"examples_advanced/doc_2d_stokes_hdiv-dg/","page":"2D DG-Hdiv discretisation for Stokes","title":"2D DG-Hdiv discretisation for Stokes","text":"module Example_2DStokesHdivDG\n\nusing GradientRobustMultiPhysics\nusing Printf\n\n# functions that define the exact solution and the data\n    function exact_pressure!(result,x::Array{<:Real,1},t::Real)\n        result[1] = cos(t)*(sin(x[1])*cos(x[2]) + (cos(1) -1)*sin(1))\n    end\n    function user_function_velocity!(result,x::Array{<:Real,1},t::Real)\n        result[1] = cos(t)*(sin(pi*x[1]-0.7)*sin(pi*x[2]+0.2))\n        result[2] = cos(t)*(cos(pi*x[1]-0.7)*cos(pi*x[2]+0.2))\n    end\n    function exact_velogradient!(result,x::Array{<:Real,1},t::Real)\n        result[1] = pi*cos(t)*(cos(pi*x[1]-0.7)*sin(pi*x[2]+0.2))\n        result[2] = pi*cos(t)*(sin(pi*x[1]-0.7)*cos(pi*x[2]+0.2))\n        result[3] = -pi*cos(t)*(sin(pi*x[1]-0.7)*cos(pi*x[2]+0.2))\n        result[4] = -pi*cos(t)*(cos(pi*x[1]-0.7)*sin(pi*x[2]+0.2))\n    end\n    function rhs(nu)\n        function closure!(result,x::Array{<:Real,1},t::Real)\n            # exact Laplacian\n            result[1] = 2*pi*pi*nu*cos(t)*(sin(pi*x[1]-0.7)*sin(pi*x[2]+0.2))\n            result[2] = 2*pi*pi*nu*cos(t)*(cos(pi*x[1]-0.7)*cos(pi*x[2]+0.2))\n            # exact pressure gradient\n            result[1] += cos(t)*cos(x[1])*cos(x[2])\n            result[2] -= cos(t)*sin(x[1])*sin(x[2])\n        end\n    end\n\n# everything is wrapped in a main function\nfunction main(;viscosity = 1e-3, nlevels = 5, Plotter = nothing, verbosity = 0, T = 1, lambda = 4)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # FEType (Hdiv-conforming)\n    FETypes = [HDIVBDM1{2}, H1P0{1}]\n\n    # initial grid\n    xgrid = grid_unitsquare(Triangle2D)\n    xBFaces = xgrid[BFaces]\n    xFaceVolumes = xgrid[FaceVolumes]\n    xFaceNormals = xgrid[FaceNormals]\n\n    # load flow data\n    user_function_velocity = DataFunction(user_function_velocity!, [2,2]; dependencies = \"XT\", quadorder = 8)\n    user_function_pressure = DataFunction(exact_pressure!, [1,2]; dependencies = \"XT\", quadorder = 4)\n    user_function_velocity_gradient = DataFunction(exact_velogradient!, [4,2]; dependencies = \"XT\", quadorder = 4)\n    user_function_rhs = DataFunction(rhs(viscosity), [2,2]; dependencies = \"XT\", quadorder = 8)\n\n    # prepare error calculation\n    L2VelocityErrorEvaluator = L2ErrorIntegrator(Float64, user_function_velocity, Identity; time = T)\n    L2PressureErrorEvaluator = L2ErrorIntegrator(Float64, user_function_pressure, Identity; time = T)\n    H1VelocityErrorEvaluator = L2ErrorIntegrator(Float64, user_function_velocity_gradient, Gradient; time = T)\n    L2VelocityError = []; L2PressureError = []; H1VelocityError = []; NDofs = []\n\n    # load Stokes problem prototype and assign data\n    Problem = IncompressibleNavierStokesProblem(2; viscosity = viscosity, nonlinear = false)\n    add_rhsdata!(Problem, 1, RhsOperator(Identity, [1], user_function_rhs))\n\n    # add boundary data (fixes normal components of along boundary)\n    add_boundarydata!(Problem, 1, [1,2,3,4], BestapproxDirichletBoundary; data = user_function_velocity)\n\n    # define additional operators for DG terms for Laplacian and Dirichlet data\n    # (in order of there appearance in the documentation above)\n    function hdiv_laplace2_kernel(result, input, item)\n        result[1] = input[1]\n        result[2] = input[2]\n        result .*= lambda*viscosity / xFaceVolumes[item]\n        return nothing\n    end\n    function hdiv_laplace3_kernel(result, input, item)\n        result[1] = input[1] * xFaceNormals[1,item]\n        result[2] = input[1] * xFaceNormals[2,item]\n        result[3] = input[2] * xFaceNormals[1,item]\n        result[4] = input[2] * xFaceNormals[2,item]\n        result .*= -viscosity\n        return nothing\n    end\n    function hdiv_laplace4_kernel(result, input, item)\n        result[1] = input[1] * xFaceNormals[1,item] + input[2] * xFaceNormals[2,item]\n        result[2] = input[3] * xFaceNormals[1,item] + input[4] * xFaceNormals[2,item]\n        result .*= -viscosity\n        return nothing\n    end\n    HdivLaplace2 = AbstractBilinearForm([Jump(Identity), Jump(Identity)], Action(Float64, hdiv_laplace2_kernel, [2,2]; dependencies = \"I\", quadorder = 0); name = \"nu/h_F [u] [v]\", AT = ON_FACES)\n    HdivLaplace3 = AbstractBilinearForm([Jump(Identity), Average(Gradient)], Action(Float64, hdiv_laplace3_kernel, [4,2]; dependencies = \"I\", quadorder = 0); name = \"-nu [u] {grad(v)*n}\", AT = ON_FACES)\n    HdivLaplace4 = AbstractBilinearForm([Average(Gradient), Jump(Identity)], Action(Float64, hdiv_laplace4_kernel, [2,4]; dependencies = \"I\", quadorder = 0); name = \"-nu {grad(u)*n} [v] \", AT = ON_FACES)\n\n    # additional terms for tangential part at boundary\n    # note: we use average operators here to force evaluation of all basis functions and not only of the face basis functions\n    # (which in case of Hdiv would be only the ones with nonzero normal fluxes)\n    veloeval = zeros(Float64,2)\n    function hdiv_boundary_kernel(result, input, x, t, item)\n        eval!(veloeval, user_function_velocity, x, t)\n        result[1] = input[1] * veloeval[1] + input[2] * veloeval[2]\n        result[1] *= lambda*viscosity / xFaceVolumes[xBFaces[item]]\n        return nothing\n    end\n    function hdiv_boundary_kernel2(result, input, x, t, item)\n        eval!(veloeval, user_function_velocity, x, t)\n        result[1] = (input[1] * xFaceNormals[1,xBFaces[item]] + input[2] * xFaceNormals[2,xBFaces[item]]) * veloeval[1]\n        result[1] += (input[3] * xFaceNormals[1,xBFaces[item]] + input[4] * xFaceNormals[2,xBFaces[item]]) * veloeval[2]\n        result[1] *= -viscosity\n        return nothing\n    end\n    HdivBoundary1 = RhsOperator(Average(Identity), Action(Float64, hdiv_boundary_kernel, [1,2]; dependencies = \"XTI\", quadorder = user_function_velocity.quadorder); name = \"- nu lambda/h_F u_D v\", AT = ON_BFACES)\n    HdivBoundary2 = RhsOperator(Average(Gradient), Action(Float64, hdiv_boundary_kernel2, [1,4]; dependencies = \"XTI\", quadorder = user_function_velocity.quadorder); name = \"- nu u_D grad(v)*n\", AT = ON_BFACES)\n\n    # assign DG operators to problem descriptions\n    add_operator!(Problem, [1,1], HdivLaplace2)\n    add_operator!(Problem, [1,1], HdivLaplace3)\n    add_operator!(Problem, [1,1], HdivLaplace4)\n    add_rhsdata!(Problem, 1, HdivBoundary1)\n    add_rhsdata!(Problem, 1, HdivBoundary2)\n\n    # show final problem description\n    @show Problem\n\n    # loop over levels\n    for level = 1 : nlevels\n\n        # refine grid and update grid component references\n        xgrid = uniform_refine(xgrid)\n        xBFaces = xgrid[BFaces]\n        xFaceVolumes = xgrid[FaceVolumes]\n        xFaceNormals = xgrid[FaceNormals]\n\n        # generate FESpaces\n        FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid)]\n\n        # generate solution vector\n        Solution = FEVector{Float64}([\"v_h\", \"p_h\"],FES)\n        push!(NDofs, length(Solution.entries))\n\n        # solve\n        solve!(Solution, Problem; time = T)\n\n        # plot\n        GradientRobustMultiPhysics.plot(xgrid, [Solution[1], Solution[1], Solution[2]], [IdentityComponent{1}, IdentityComponent{2}, Identity]; Plotter = Plotter)\n\n        # compute L2 and H1 error of all solutions\n        push!(L2VelocityError, sqrt(evaluate(L2VelocityErrorEvaluator,Solution[1])))\n        push!(L2PressureError, sqrt(evaluate(L2PressureErrorEvaluator,Solution[2])))\n        push!(H1VelocityError, sqrt(evaluate(H1VelocityErrorEvaluator,Solution[1])))\n    end\n\n    # output errors in a nice table\n    println(\"\\n   NDOF  | L2ERROR(v_h) | H1ERROR(v_h) | L2ERROR(p_h)\")\n    for j=1:nlevels\n        @printf(\"  %6d |\",NDofs[j]);\n        @printf(\" %.6e |\",L2VelocityError[j])\n        @printf(\" %.6e |\",H1VelocityError[j])\n        @printf(\" %.6e\\n\",L2PressureError[j])\n    end\nend\nend","category":"page"},{"location":"examples_advanced/doc_2d_stokes_hdiv-dg/","page":"2D DG-Hdiv discretisation for Stokes","title":"2D DG-Hdiv discretisation for Stokes","text":"","category":"page"},{"location":"examples_advanced/doc_2d_stokes_hdiv-dg/","page":"2D DG-Hdiv discretisation for Stokes","title":"2D DG-Hdiv discretisation for Stokes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_3d_commutinginterpolators/#Commuting-Interpolators-(3D)","page":"Commuting Interpolators (3D)","title":"Commuting Interpolators (3D)","text":"","category":"section"},{"location":"examples/doc_3d_commutinginterpolators/","page":"Commuting Interpolators (3D)","title":"Commuting Interpolators (3D)","text":"(source code)","category":"page"},{"location":"examples/doc_3d_commutinginterpolators/","page":"Commuting Interpolators (3D)","title":"Commuting Interpolators (3D)","text":"This example verifies a structural property of the Hcurl and Hdiv finite element spaces and their interpolators which is","category":"page"},{"location":"examples/doc_3d_commutinginterpolators/","page":"Commuting Interpolators (3D)","title":"Commuting Interpolators (3D)","text":"mathrmCurl(I_mathrmN_k-1psi) = I_mathrmRT_k-1(mathrmCurl(psi))","category":"page"},{"location":"examples/doc_3d_commutinginterpolators/","page":"Commuting Interpolators (3D)","title":"Commuting Interpolators (3D)","text":"for the standard Nedelec interpolator I_mathrmN_k-1 and the standard Raviart-Thomas interpolator I_mathrmRT_k-1 for k  0. In this example we verify this identity for k=1 (higher order spaces are tested as well as soon as they are available).","category":"page"},{"location":"examples/doc_3d_commutinginterpolators/","page":"Commuting Interpolators (3D)","title":"Commuting Interpolators (3D)","text":"module Example_3DCommutingInterpolators\nusing GradientRobustMultiPhysics\n\n# define some function\nfunction exact_function!(result,x::Array{<:Real,1})\n    result[1] = x[2]^2 + x[3]\n    result[2] = x[1]^3\n    result[3] = 1 + x[3]^2\nend\n# and its Curl3D\nfunction exact_curl!(result,x::Array{<:Real,1})\n    result[1] = 0\n    result[2] = 1\n    result[3] = 3*x[1]^2 - 2*x[2]\nend\n\n# everything is wrapped in a main function\nfunction main(;order::Int = 1, testmode = false)\n\n    # choose some grid\n    xgrid = uniform_refine(reference_domain(Tetrahedron3D),2)\n\n    # negotiate exact_function! and exact_curl! to the package\n    user_function = DataFunction(exact_function!, [3,3]; name = \"u_exact\", dependencies = \"X\", quadorder = 3)\n    user_function_curl = DataFunction(exact_curl!, [3,3]; name = \"Curl(u_exact)\", dependencies = \"X\", quadorder = 2)\n\n    # choose commuting interpolators pair\n    if order == 1\n        FE = [HCURLN0{3},HDIVRT0{3}]; testFE = H1P0{3}\n    end\n\n    # do the Hcurl interpolation of the function\n    FESH1 = FESpace{FE[1]}(xgrid)\n    HcurlInterpolation = FEVector{Float64}(\"Hcurl-Interpolation\",FESH1)\n    interpolate!(HcurlInterpolation[1], user_function)\n\n    # do the Hdiv interpolation of the Curl of the function\n    # since integrals over faces have to be computed exactly we need to tune the quadrature order\n    FESHdiv = FESpace{FE[2]}(xgrid)\n    HdivCurlInterpolation = FEVector{Float64}(\"Hdiv-Interpolation\",FESHdiv)\n    interpolate!(HdivCurlInterpolation[1], user_function_curl)\n\n    # Checking the identity:\n    # Both sides of the identity are finite element function of FEtype testFE\n    # Hence, we evaluate the error by testing the identity by all basisfunctions of this type\n\n    # first: generate the test space and some matching FEVector\n    FEStest = FESpace{testFE}(xgrid; broken = true)\n    error = FEVector{Float64}(\"ErrorVector\",FEStest)\n\n    # Define bilinear forms that represents testing each side of the identity with the testspace functions\n    BLF1 = BilinearForm(Float64, ON_CELLS, [FEStest, FESHdiv], [Identity, Identity])\n    BLF2 = BilinearForm(Float64, ON_CELLS, [FEStest, FESH1], [Identity, Curl3D])\n\n    # evaluate the bilinear forms in the respective interpolations and subtract them from each other\n    # note that in these calls always the second argument of the bilinearform is fixed by the given FEVectorBlock\n    assemble!(error[1], BLF1, HdivCurlInterpolation[1]; fixed_arguments = [2])\n    assemble!(error[1], BLF2, HcurlInterpolation[1]; factor = -1, fixed_arguments = [2])\n\n    # do some norm that recognizes a nonzero in the vector\n    error = sqrt(sum(error[1][:].^2, dims = 1)[1])\n    if testmode == true\n        return error\n    else\n        println(\"error(Curl(I_$(FE[1])(psi) - I_$(FE[2])(Curl(psi))) = $error\")\n    end\nend\n\n# test function that is called by test unit\nfunction test()\n    error = []\n    for order in [1]\n        push!(error, max(main(order = order, testmode = true)))\n    end\n    return maximum(error)\nend\n\nend","category":"page"},{"location":"examples/doc_3d_commutinginterpolators/","page":"Commuting Interpolators (3D)","title":"Commuting Interpolators (3D)","text":"Main.##271.Example_3DCommutingInterpolators","category":"page"},{"location":"examples/doc_3d_commutinginterpolators/#Output-of-default-main()-run","page":"Commuting Interpolators (3D)","title":"Output of default main() run","text":"","category":"section"},{"location":"examples/doc_3d_commutinginterpolators/","page":"Commuting Interpolators (3D)","title":"Commuting Interpolators (3D)","text":"Example_3DCommutingInterpolators.main()","category":"page"},{"location":"examples/doc_3d_commutinginterpolators/","page":"Commuting Interpolators (3D)","title":"Commuting Interpolators (3D)","text":"error(Curl(I_HCURLN0{3}(psi) - I_HDIVRT0{3}(Curl(psi))) = 3.821945511051252e-17\n","category":"page"},{"location":"examples/doc_3d_commutinginterpolators/","page":"Commuting Interpolators (3D)","title":"Commuting Interpolators (3D)","text":"","category":"page"},{"location":"examples/doc_3d_commutinginterpolators/","page":"Commuting Interpolators (3D)","title":"Commuting Interpolators (3D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"fems/#Implemented-Finite-Elements","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"This page describes the finite element type-tree and lists all implemented finite elements.","category":"page"},{"location":"fems/#The-Finite-Element-Type-Tree","page":"Implemented Finite Elements","title":"The Finite Element Type-Tree","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"Finite elements are abstract type leaves in a type-tree. The complete tree looks like this:","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"AbstractFiniteElement\n├─ AbstractH1FiniteElement\n│  ├─ AbstractH1FiniteElementWithCoefficients\n│  │  └─ H1BR\n│  ├─ H1CR\n│  ├─ H1MINI\n│  ├─ H1P0\n│  ├─ H1P1\n│  ├─ H1P2\n│  └─ H1P2B\n├─ AbstractHcurlFiniteElement\n│  └─ HCURLN0\n└─ AbstractHdivFiniteElement\n   ├─ HDIVBDM1\n   ├─ HDIVRT0\n   └─ HDIVRT1","category":"page"},{"location":"fems/#Remarks","page":"Implemented Finite Elements","title":"Remarks","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"each type depends on one or two parameters, the first one is always the number of components (ncomponents) that determines of the finite element is scalar- or veector-valued; some elements additionaly require the parameter edim <: Int if they are structurally different in different space dimensions\neach finite elements mainly comes with a set of basis functions in reference coordinates for each applicable AbstractElementGeometry and degrees of freedom maps for the different Assembly Types (coded as a string)\nbroken finite elements are possible via the broken switch in the FESpace constructor\nthe type steers how the basis functions are transformed from local to global coordinates and how FunctionOperators are evaluated by FEBasisEvaluator.jl\ndepending on additional continuity properties of the element types more basis function sets are defined:\nAbstractH1FiniteElements additionally have evaluations of nonzero basisfunctions on faces/bfaces\nAbstractHdivFiniteElements additionally have evaluations of nonzero normalfluxes of basisfunctions on faces/bfaces\nAbstractHcurlFiniteElements additionally have evaluations of nonzero tangentfluxes of basisfunctions on edges/bedges\neach finite element has its own implemented standard interpolation interpolate! (see Finite Element Interpolations) that can be applied to Data Functions, below it is shortly described what this means for each finite element","category":"page"},{"location":"fems/#List-of-implemented-Finite-Elements","page":"Implemented Finite Elements","title":"List of implemented Finite Elements","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The following table lists all curently implemented finite elements. Click on them to find out more details.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1 finite elements Hdiv finite elements Hcurl finite elements\nH1P0 HDIVRT0 HCURLN0\nH1P1 HDIVBDM1 \nH1MINI HDIVRT1 \nH1CR  \nH1BR  \nH1P2  \nH1P2B  ","category":"page"},{"location":"fems/#H1-conforming-finite-elements","page":"Implemented Finite Elements","title":"H1-conforming finite elements","text":"","category":"section"},{"location":"fems/#P0-finite-element","page":"Implemented Finite Elements","title":"P0 finite element","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"Piecewise constant finite element that has one degree of freedom on each cell of the grid. (It is masked as a H1-conforming finite element, because it uses the same transformations.)","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The interpolation of a given function into this space preserves the cell integrals.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1P0","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.H1P0","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1P0","text":"abstract type H1P0{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nPiecewise constant polynomials on cells.\n\nallowed on every ElementGeometry\n\n\n\n\n\n","category":"type"},{"location":"fems/#P1-finite-element","page":"Implemented Finite Elements","title":"P1 finite element","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The lowest-order current finite element that has a degree of freedom on each vertex of the grid. On simplices the basis functions coincide with the linear barycentric coordinates, on parallelepiped bi-linear functions are used (also known as Q1 element).","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1P1","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.H1P1","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1P1","text":"abstract type H1P1{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nContinuous piecewise first-order polynomials.\n\nallowed ElementGeometries:\n\nEdge1D (linear polynomials)\nTriangle2D (linear polynomials)\nQuadrilateral2D (Q1 space)\nTetrahedron3D (linear polynomials)\nHexahedron3D (Q1 space)\n\n\n\n\n\n","category":"type"},{"location":"fems/#MINI-finite-element","page":"Implemented Finite Elements","title":"MINI finite element","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The mini finite element adds cell bubles to the P1 element that are e.g. beneficial to define inf-sup stable finite element pairs for the Stokes problem.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves its cell integral.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1MINI","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.H1MINI","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1MINI","text":"abstract type H1MINI{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nMini finite element.\n\nallowed element geometries:\n\nTriangle2D (linear polynomials + cubic cell bubble)\nQuadrilateral2D (Q1 space + quartic cell bubble)\nTetrahedron3D (linear polynomials + cubic cell bubble)\n\n\n\n\n\n","category":"type"},{"location":"fems/#Bernardi-Raugel-(BR)-finite-element","page":"Implemented Finite Elements","title":"Bernardi-Raugel (BR) finite element","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The Bernardi-Raugel adds normal-weighted face bubbles to the P1 finite element and therefore is only available as a vector-valued element.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves face integrals of its normal flux.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1BR","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.H1BR","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1BR","text":"abstract type H1BR{edim} <: AbstractH1FiniteElementWithCoefficients where {edim<:Int}\n\nvector-valued (ncomponents = edim) Bernardi–Raugel element (first-order polynomials + normal-weighted face bubbles)\n\nallowed ElementGeometries:\n\nTriangle2D (piecewise linear + normal-weighted face bubbles)\nQuadrilateral2D (Q1 space + normal-weighted face bubbles)\nTetrahedron3D (piecewise linear + normal-weighted face bubbles)\n\n\n\n\n\n","category":"type"},{"location":"fems/#P2-finite-element","page":"Implemented Finite Elements","title":"P2 finite element","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The P2 finite element method on simplices equals quadratic polynomials. On the Triangle2D shape the degrees of freedom are associated with the three vertices and the three faces of the triangle. On the Tetrahedron3D shape the degrees of freedom are associated with the four verties and the six edges. On Parallelogram2D cubic Q2 element functions are used.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves its face/edge integrals in 2D/3D.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1P2","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.H1P2","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1P2","text":"abstract type H1P2{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nContinuous piecewise second-order polynomials.\n\nallowed ElementGeometries:\n\nEdge1D (quadratic polynomials)\nTriangle2D (quadratic polynomials)\nQuadrilateral2D (Q2 space)\nTetrahedron3D (quadratic polynomials)\n\n\n\n\n\n","category":"type"},{"location":"fems/#P2B-finite-element","page":"Implemented Finite Elements","title":"P2B finite element","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The P2B finite element adds additional cell bubles (in 2D and 3D) and face bubbles (only in 3D) that are e.g. used to define inf-sup stable finite element pairs for the Stokes problem.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves its cell and face integrals in 2D and also edge integrals in 3D.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1P2B","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.H1P2B","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1P2B","text":"abstract type H1P2B{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nContinuous piecewise second-order polynomials.\n\nallowed ElementGeometries:\n\nTriangle2D (quadratic polynomials + cell bubble)\n\n\n\n\n\n","category":"type"},{"location":"fems/#Crouzeix-Raviart-(CR)-finite-element","page":"Implemented Finite Elements","title":"Crouzeix-Raviart (CR) finite element","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The Crouzeix-Raviart element associates one lowest-order function with each face. On the Triangle2D shape, the basis function of a face is one minus two times the nodal basis function of the opposite node. ","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The interpolation of a given function into this space preserves its face integrals.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1CR","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.H1CR","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1CR","text":"abstract type H1CR{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nCrouzeix-Raviart element (only continuous at face centers).\n\nallowed ElementGeometries:\n\nTriangle2D (piecewise linear, similar to P1)\nQuadrilateral2D (similar to Q1 space)\nTetrahedron3D (piecewise linear, similar to P1)\n\n\n\n\n\n","category":"type"},{"location":"fems/#Hdiv-conforming-finite-elements","page":"Implemented Finite Elements","title":"Hdiv-conforming finite elements","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"These Raviart-Thomas and Brezzi-Douglas-Marini finite elements of lower order and their standard interpolations are available:","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"HDIVRT0\nHDIVBDM1\nHDIVRT1","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.HDIVRT0","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.HDIVRT0","text":"abstract type HDIVRT0{edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) lowest-order Raviart-Thomas space.\n\nallowed ElementGeometries:\n\nTriangle2D\nQuadrilateral2D\nTetrahedron3D\nHexahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#GradientRobustMultiPhysics.HDIVBDM1","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.HDIVBDM1","text":"abstract type HDIVBDM1{edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) lowest-order Brezzi-Douglas-Marini space\n\nallowed ElementGeometries:\n\nTriangle2D\nQuadrilateral2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#GradientRobustMultiPhysics.HDIVRT1","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.HDIVRT1","text":"abstract type HDIVRT1{edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) Raviart-Thomas space of order 1.\n\nallowed ElementGeometries:\n\nTriangle2D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Hcurl-conforming-finite-elements","page":"Implemented Finite Elements","title":"Hcurl-conforming finite elements","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"So far only the lowest order Nedelec element is available in 2D and 3D. On Triangle2D it has one degree of freedom for each face (i.e. the rotated RT0 element), on Tetrahedron3D it has one degree of freedom associated to each of the six edges.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"Its standard interpolation of a given functions preserves its tangential face/edge integrals.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"HCURLN0","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.HCURLN0","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.HCURLN0","text":"abstract type HCURLN0{edim} <: AbstractHcurlFiniteElement where {edim<:Int}\n\nHcurl-conforming vector-valued (ncomponents = edim) lowest-order Nedelec space.\n\nallowed ElementGeometries:\n\nTriangle2D\nQuadrilateral2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"pdesolvers/#PDE-Solvers","page":"PDE Solvers","title":"PDE Solvers","text":"","category":"section"},{"location":"pdesolvers/#Fixed-Time-Solvers","page":"PDE Solvers","title":"Fixed-Time Solvers","text":"","category":"section"},{"location":"pdesolvers/","page":"PDE Solvers","title":"PDE Solvers","text":"If solve! is applied to a PDEDescription and a FEVector (that specifies the ansatz spaces for the unknowns) an investigation of the PDEDescription is performed that decides if the problem is nonlinear (and has to be solved by a fixed-point algorithm) or if it can be solved directly in one step. Additionally the user can manually trigger subiterations that splits the fixed-point algorithm into substeps where only subsets of the PDE equations are solved together.","category":"page"},{"location":"pdesolvers/","page":"PDE Solvers","title":"PDE Solvers","text":"solve!","category":"page"},{"location":"pdesolvers/#GradientRobustMultiPhysics.solve!","page":"PDE Solvers","title":"GradientRobustMultiPhysics.solve!","text":"function solve!(\n    Target::FEVector,       # contains initial guess and final solution after solve\n    PDE::PDEDescription;\n    kwargs)\n\nSolves a given PDE (provided as a PDEDescription) and writes the solution into the FEVector Target (which knows the discrete ansatz spaces).\n\nKeyword arguments:\n\nanderson_iterations: use Anderson acceleration with this many previous iterates (to hopefully speed up/enable convergence of fixpoint iterations). Default: 0\nsubiterations: an array of equation subsets (each an array) that should be solved together in each fixpoint iteration. Default: ''auto''\nshowiterationdetails: show details (residuals etc.) of each iteration. Default: true\nanderson_unknowns: an array of unknown numbers that should be included in the Anderson acceleration. Default: [1]\nshow_statistics: show some statistics like assembly times. Default: false\nanderson_metric: String that encodes the desired convergence metric for the Anderson acceleration (possible values: ''l2'' or ''L2'' or ''H1''). Default: ''l2''\nskipupdate: matrix update (for the j-th sub-iteration) will be performed each skipupdate[j] iteration; -1 means only in the first iteration. Default: [1]\nlinsolver: String that encodes the linear solver (or type name of self-defined solver, see corressponding example). Default: ''UMFPACK''\ndamping: damp the new iteration with this part of the old iteration (0 = undamped). Default: 0\ntime: time at which time-dependent data functions are evaluated or initial time for TimeControlSolver. Default: 0\nshowsolverconfig: show the complete solver configuration before starting to solve. Default: false\nanderson_damping: Damping factor in Anderson acceleration (1 = undamped). Default: 1\nchecknonlinearresidual: check the nonlinear residual in last nonlinear iteration (causes one more reassembly of nonlinear terms). Default: ''auto''\nfixed_penalty: penalty that is used for the values of fixed degrees of freedom (e.g. by Dirichlet boundary data or global constraints). Default: 1.0e60\ntarget_residual: stop fixpoint iterations if the (nonlinear) residual is smaller than this number. Default: 1.0e-10\nmaxiterations: maximal number of nonlinear iterations (TimeControlSolver runs that many in each time step). Default: ''auto''\n\nDepending on the subiterations and detected/configured nonlinearities the whole system is either solved directly in one step or via a fixed-point iteration.\n\n\n\n\n\n","category":"function"},{"location":"pdesolvers/#Anderson-acceleration","page":"PDE Solvers","title":"Anderson acceleration","text":"","category":"section"},{"location":"pdesolvers/","page":"PDE Solvers","title":"PDE Solvers","text":"Fixpoint iterations my be accelerated by Anderson acceleration. Concepts and some theoretical background can be found in the reference below. Within this package, Anderson acceleration can be triggered by optional solver arguments: the user can specify the depth of the Anderson acceleration (anderson_iterations), the damping withing the Anderson iteration (anderson_damping), the unknwons that should be included in the iteration (anderson_unknowns) and the convergence metric (anderson_metric); also see above for a full list of optional solver arguments. In case of subiterations, the Anderson iteration will be called as a postprocessing after the final subiteration.","category":"page"},{"location":"pdesolvers/","page":"PDE Solvers","title":"PDE Solvers","text":"Reference:","category":"page"},{"location":"pdesolvers/","page":"PDE Solvers","title":"PDE Solvers","text":"\"A Proof That Anderson Acceleration Improves the Convergence Rate in Linearly Converging Fixed-Point Methods (But Not in Those Converging Quadratically)\",\nC. Evans, S. Pollock, L. Rebholz, and M. Xiao,\nSIAM J. Numer. Anal., 58(1) (2020),\n>Journal-Link<","category":"page"},{"location":"pdesolvers/#Time-Dependent-Solvers","page":"PDE Solvers","title":"Time-Dependent Solvers","text":"","category":"section"},{"location":"pdesolvers/","page":"PDE Solvers","title":"PDE Solvers","text":"The structure TimeControlSolver can be used to setup a time-dependent solver that can be configured in a similar manner as the time-independent ones (subiterations, nonlinear iterations, linear solvers). As a TimeIntegrationRule so far only BackwardEuler is implemented.","category":"page"},{"location":"pdesolvers/","page":"PDE Solvers","title":"PDE Solvers","text":"Note that, the time-derivative is added by the TimeControlSolver and is in general not part of the PDEDescription (this is debatable and might change in the future).","category":"page"},{"location":"pdesolvers/","page":"PDE Solvers","title":"PDE Solvers","text":"TimeControlSolver\nadvance!","category":"page"},{"location":"pdesolvers/#GradientRobustMultiPhysics.TimeControlSolver","page":"PDE Solvers","title":"GradientRobustMultiPhysics.TimeControlSolver","text":"function TimeControlSolver(\n    PDE::PDEDescription,\n    Solution::FEVector,    # contains initial values and stores solution of advance method below\n    TIR::Type{<:AbstractTimeIntegrationRule} = BackwardEuler;\n    dt_testfunction_operator = [],\n    dt_action = [],\n    nonlinear_dt = [],\n    kwargs...)\n\nCreates a time-dependent solver that can be advanced in time with advance!. The FEVector Solution stores the initial state but also the solution at the current time. The argument TIR carries the time integration rule (currently there is only BackwardEuler).\n\nKeyword arguments:\n\nsubiterations: an array of equation subsets (each an array) that should be solved together in each fixpoint iteration. Default: ''auto''\nshowiterationdetails: show details (residuals etc.) of each iteration. Default: true\ntimedependent_equations: array of the equations that should get a time derivative (only for TimeControlSolver). Default: Any[]\nshow_statistics: show some statistics like assembly times. Default: false\nskipupdate: matrix update (for the j-th sub-iteration) will be performed each skipupdate[j] iteration; -1 means only in the first iteration. Default: [1]\nlinsolver: String that encodes the linear solver (or type name of self-defined solver, see corressponding example). Default: ''UMFPACK''\ntime: time at which time-dependent data functions are evaluated or initial time for TimeControlSolver. Default: 0\nshowsolverconfig: show the complete solver configuration before starting to solve. Default: false\nchecknonlinearresidual: check the nonlinear residual in last nonlinear iteration (causes one more reassembly of nonlinear terms). Default: ''auto''\nfixed_penalty: penalty that is used for the values of fixed degrees of freedom (e.g. by Dirichlet boundary data or global constraints). Default: 1.0e60\ntarget_residual: stop fixpoint iterations if the (nonlinear) residual is smaller than this number. Default: 1.0e-10\nmaxiterations: maximal number of nonlinear iterations (TimeControlSolver runs that many in each time step). Default: ''auto''\n\nFurther (very experimental) optional arguments for TimeControlSolver are:\n\ndttestfunction_operator : (array of) operators applied to testfunctions in time derivative (default: Identity)\ndt_action : (array of) actions that are applied to the ansatz function in the time derivative (to include parameters etc.)\nnonlinear_dt : (array of) booleans to decide which time derivatives should be recomputed in each iteration/timestep\n\n\n\n\n\n","category":"type"},{"location":"pdesolvers/#GradientRobustMultiPhysics.advance!","page":"PDE Solvers","title":"GradientRobustMultiPhysics.advance!","text":"function TimeControlSolver(\n    advance!(TCS::TimeControlSolver, timestep::Real = 1e-1)\n\nAdvances a TimeControlSolver one step in time with the given timestep.\n\n\n\n\n\n","category":"function"},{"location":"pdesolvers/","page":"PDE Solvers","title":"PDE Solvers","text":"Moreover there are two functions that advance the TimeControlSolver automatically until a given final time (advance_until_time!) is reached or until stationarity is reached (advance_until_stationarity!). As an experimental feature, one can add the module DifferentialEquations.jl as the first argument to these methods to let this module run the time integration.","category":"page"},{"location":"pdesolvers/","page":"PDE Solvers","title":"PDE Solvers","text":"advance_until_time!\nadvance_until_stationarity!","category":"page"},{"location":"pdesolvers/#GradientRobustMultiPhysics.advance_until_time!","page":"PDE Solvers","title":"GradientRobustMultiPhysics.advance_until_time!","text":"advance_until_time!(TCS::TimeControlSolver, timestep, finaltime; finaltime_tolerance = 1e-15, do_after_each_timestep = nothing)\n\nAdvances a TimeControlSolver in time with the given (initial) timestep until the specified finaltime is reached (up to the specified tolerance). The function doaftertimestep is called after each timestep and can be used to print/save data (and maybe timestep control in future).\n\n\n\n\n\nadvance_until_time!(DiffEQ::Module, TCS::TimeControlSolver, timestep, finaltime; solver = nothing, abstol = 1e-1, reltol = 1e-1, dtmin = 0, adaptive::Bool = true)\n\nAdvances a TimeControlSolver in time with the given (initial) timestep until the specified finaltime is reached (up to the specified tolerance) with the given exterior time integration module. The only valid Module here is DifferentialEquations.jl and the optional arguments are passed to it. If solver == nothing the solver Rosenbrock23(autodiff = false) will be chosen. For more choices please consult the documentation of DifferentialEquations.jl.\n\nAlso note that this is a highly experimental feature and will not work for general TimeControlSolvers configuration (e.g. in the case of several subiterations or, it seems, saddle point problems). Also have a look at corressponding the example in the advanced examples section.\n\n\n\n\n\n","category":"function"},{"location":"pdesolvers/#GradientRobustMultiPhysics.advance_until_stationarity!","page":"PDE Solvers","title":"GradientRobustMultiPhysics.advance_until_stationarity!","text":"advance_until_stationarity!(TCS::TimeControlSolver, timestep; stationarity_threshold = 1e-11, maxTimeSteps = 100, do_after_each_timestep = nothing)\n\nAdvances a TimeControlSolver in time with the given (initial) timestep until stationarity is detected (change of variables below threshold) or a maximal number of time steps is exceeded. The function doaftertimestep is called after each timestep and can be used to print/save data (and maybe timestep control in future).\n\n\n\n\n\n","category":"function"},{"location":"examples/doc_2d_fe_on_faces/#D-Finite-Elements-on-Faces","page":"2D Finite Elements on Faces","title":"2D Finite Elements on Faces","text":"","category":"section"},{"location":"examples/doc_2d_fe_on_faces/","page":"2D Finite Elements on Faces","title":"2D Finite Elements on Faces","text":"(source code)","category":"page"},{"location":"examples/doc_2d_fe_on_faces/","page":"2D Finite Elements on Faces","title":"2D Finite Elements on Faces","text":"This code demonstrates the novel feature of finite element spaces on faces by providing AT = ON_FACES in the finite element space constructor. It is used here to solve a bestapproximation into an Hdiv-conforming space by using a broken Hdiv space and setting the normal jumps on interior faces to zero by using a Lagrange multiplier on the faces of the grid (a broken H1-conforming space). Then the solution is compared to the solution of the same problem using the continuous Hdiv-conforming space.","category":"page"},{"location":"examples/doc_2d_fe_on_faces/","page":"2D Finite Elements on Faces","title":"2D Finite Elements on Faces","text":"module Example_2DFaceElements\n\nusing GradientRobustMultiPhysics\n\n# problem data\nfunction exact_function!(result,x::Array{<:Real,1})\n    result[1] = x[1]^3+x[2]\n    result[2] = x[2] + 1\n    return nothing\nend\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, verbosity = 0)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # choose initial mesh\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D),3)\n\n    # define bestapproximation problem\n    user_function = DataFunction(exact_function!, [2,2]; name = \"u_exact\", dependencies = \"X\", quadorder = 3)\n    Problem = L2BestapproximationProblem(user_function; name = \"constrained L2-bestapproximation problem\", bestapprox_boundary_regions = [])\n\n    # we want to use a broken space and give the constraint of no normal jumps on interior faces\n    # in form of a Lagrange multiplier, since there is no NormalFluxDisc{Jump} operator yet,\n    # we have to use the full identity and multiply the normal vector in an action\n    add_unknown!(Problem; unknown_name = \"LM face jumps\", equation_name = \"face jump constraint\")\n    add_operator!(Problem, [1,2], LagrangeMultiplier(NormalFluxDisc{Jump}; AT = ON_IFACES))\n    # the diagonal operator sets the Lagrange multiplier on all face boundary regions to zero\n    add_operator!(Problem, [2,2], DiagonalOperator(\"Diag(1)\", 1.0, true, [1,2,3,4]))\n\n    # choose some (inf-sup stable) finite element types\n    # first space is the Hdiv element\n    # second will be used for the Lagrange multiplier space on faces\n    FEType = [HDIVRT1{2}, H1P1{1}]\n    FES = [FESpace{FEType[1]}(xgrid; broken = true),FESpace{FEType[2], ON_FACES}(xgrid; broken = true)]\n\n    # solve\n    Solution = FEVector{Float64}([\"u_h (Hdiv-broken)\", \"LM face jumps\"],FES)\n    solve!(Solution, Problem)\n\n    # plot\n    GradientRobustMultiPhysics.plot(xgrid, [Solution[1]], [Identity]; Plotter = Plotter)\n\n    # solve again with Hdiv-continuous element\n    # to see that we get the same result\n    Problem = L2BestapproximationProblem(user_function; bestapprox_boundary_regions = [])\n    FES = FESpace{FEType[1]}(xgrid)\n\n    # solve\n    Solution2 = FEVector{Float64}(\"u_h (Hdiv-cont.)\",FES)\n    solve!(Solution2, Problem)\n\n    # calculate L2 error of both solutions and their difference\n    L2ErrorEvaluator = L2ErrorIntegrator(Float64, user_function, Identity)\n    L2DiffEvaluator = L2DifferenceIntegrator(Float64, 2, Identity)\n    println(\"\\tL2error(Hdiv-broken) = $(sqrt(evaluate(L2ErrorEvaluator,Solution[1])))\")\n    println(\"\\tL2error(Hdiv-cont.) = $(sqrt(evaluate(L2ErrorEvaluator,Solution2[1])))\")\n    println(\"\\tL2error(difference) = $(sqrt(evaluate(L2DiffEvaluator,[Solution[1], Solution2[1]])))\")\nend\n\nend","category":"page"},{"location":"examples/doc_2d_fe_on_faces/","page":"2D Finite Elements on Faces","title":"2D Finite Elements on Faces","text":"Main.##262.Example_2DFaceElements","category":"page"},{"location":"examples/doc_2d_fe_on_faces/#Output-of-default-main()-run","page":"2D Finite Elements on Faces","title":"Output of default main() run","text":"","category":"section"},{"location":"examples/doc_2d_fe_on_faces/","page":"2D Finite Elements on Faces","title":"2D Finite Elements on Faces","text":"Example_2DFaceElements.main()","category":"page"},{"location":"examples/doc_2d_fe_on_faces/","page":"2D Finite Elements on Faces","title":"2D Finite Elements on Faces","text":"┌ Info: ----- Solving constrained L2-bestapproximation problem -----\n│ \tEquation (1.1) L2-bestapproximation equation : u_exact >> u_h (Hdiv-broken) (HDIVRT1{2} (broken), ndofs = 2048)\n│ \tEquation (1.2) face jump constraint : LM face jumps >> LM face jumps (H1P1{1} (broken), ndofs = 800)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 4.884517645741208e-16\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving L2-Bestapproximation problem -----\n│ \tEquation (1.1) L2-bestapproximation equation : u_exact >> u_h (Hdiv-cont.) (HDIVRT1{2}, ndofs = 1312)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 4.3042323572289977e-16\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\tL2error(Hdiv-broken) = 0.0004715248381994809\n\tL2error(Hdiv-cont.) = 0.00047152483819947713\n\tL2error(difference) = 5.616912853180266e-16\n","category":"page"},{"location":"examples/doc_2d_fe_on_faces/","page":"2D Finite Elements on Faces","title":"2D Finite Elements on Faces","text":"","category":"page"},{"location":"examples/doc_2d_fe_on_faces/","page":"2D Finite Elements on Faces","title":"2D Finite Elements on Faces","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_2d_liddrivencavity_anderson/#D-Lid-driven-cavity-(Anderson-Acceleration)","page":"2D Lid-driven cavity (Anderson Acceleration)","title":"2D Lid-driven cavity (Anderson Acceleration)","text":"","category":"section"},{"location":"examples/doc_2d_liddrivencavity_anderson/","page":"2D Lid-driven cavity (Anderson Acceleration)","title":"2D Lid-driven cavity (Anderson Acceleration)","text":"(source code)","category":"page"},{"location":"examples/doc_2d_liddrivencavity_anderson/","page":"2D Lid-driven cavity (Anderson Acceleration)","title":"2D Lid-driven cavity (Anderson Acceleration)","text":"This example solves the lid-driven cavity problem where one seeks a velocity mathbfu and pressure mathbfp of the incompressible Navier–Stokes problem","category":"page"},{"location":"examples/doc_2d_liddrivencavity_anderson/","page":"2D Lid-driven cavity (Anderson Acceleration)","title":"2D Lid-driven cavity (Anderson Acceleration)","text":"beginaligned\n- mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = 0\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"examples/doc_2d_liddrivencavity_anderson/","page":"2D Lid-driven cavity (Anderson Acceleration)","title":"2D Lid-driven cavity (Anderson Acceleration)","text":"where mathbfu = (10) along the top boundary of a square domain.","category":"page"},{"location":"examples/doc_2d_liddrivencavity_anderson/","page":"2D Lid-driven cavity (Anderson Acceleration)","title":"2D Lid-driven cavity (Anderson Acceleration)","text":"For small viscosities (where a Newton and a classical Picard iteration do not converge anymore), Anderson acceleration might help which can be tested with this script. Here, we use Anderson acceleration until the residual is small enough for the Newton to take over.","category":"page"},{"location":"examples/doc_2d_liddrivencavity_anderson/","page":"2D Lid-driven cavity (Anderson Acceleration)","title":"2D Lid-driven cavity (Anderson Acceleration)","text":"module Example_2DLidDrivenCavityAnderson\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing Printf\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, Plotter = nothing, viscosity = 5e-4, anderson_iterations = 10, target_residual = 1e-14, maxiterations = 50, switch_to_newton_tolerance = 1e-4)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # grid\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D), 4);\n\n    # finite element type\n    FETypes = [H1P2{2,2}, H1P1{1}] # Taylor--Hood\n\n    #####################################################################################\n\n    # load Navier-Stokes problem prototype and assign data\n    Problem = IncompressibleNavierStokesProblem(2; viscosity = viscosity, nonlinear = true, auto_newton = false, store = false)\n    add_boundarydata!(Problem, 1, [1,2,4], HomogeneousDirichletBoundary)\n    add_boundarydata!(Problem, 1, [3], BestapproxDirichletBoundary; data = DataFunction([1,0]))\n\n    @show Problem\n\n    # generate FESpaces\n    FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid)]\n    Solution = FEVector{Float64}([\"u_h\", \"p_h\"],FES)\n\n    # solve with anderson iterations until 1e-4\n    solve!(Solution, Problem; anderson_iterations = anderson_iterations, anderson_metric = \"l2\", anderson_unknowns = [1], maxiterations = maxiterations, target_residual = switch_to_newton_tolerance)\n\n    # solve rest with Newton\n    Problem = IncompressibleNavierStokesProblem(2; viscosity = viscosity, nonlinear = true, auto_newton = true, store = true)\n    add_boundarydata!(Problem, 1, [1,2,4], HomogeneousDirichletBoundary)\n    add_boundarydata!(Problem, 1, [3], BestapproxDirichletBoundary; data = DataFunction([1,0]))\n    solve!(Solution, Problem; anderson_iterations = anderson_iterations, maxiterations = maxiterations, target_residual = target_residual)\n\n    # plot\n    GradientRobustMultiPhysics.plot(xgrid, [Solution[1],Solution[2]], [Identity, Identity]; Plotter = Plotter)\nend\n\nend","category":"page"},{"location":"examples/doc_2d_liddrivencavity_anderson/","page":"2D Lid-driven cavity (Anderson Acceleration)","title":"2D Lid-driven cavity (Anderson Acceleration)","text":"Main.##264.Example_2DLidDrivenCavityAnderson","category":"page"},{"location":"examples/doc_2d_liddrivencavity_anderson/#Output-of-default-main()-run","page":"2D Lid-driven cavity (Anderson Acceleration)","title":"Output of default main() run","text":"","category":"section"},{"location":"examples/doc_2d_liddrivencavity_anderson/","page":"2D Lid-driven cavity (Anderson Acceleration)","title":"2D Lid-driven cavity (Anderson Acceleration)","text":"Example_2DLidDrivenCavityAnderson.main()","category":"page"},{"location":"examples/doc_2d_liddrivencavity_anderson/","page":"2D Lid-driven cavity (Anderson Acceleration)","title":"2D Lid-driven cavity (Anderson Acceleration)","text":"\nPDE-DESCRIPTION\n===============\n  system name = incompressible Navier-Stokes-Problem\n\n     id   | unknown name / equation name\n    [1]   | velocity / momentum equation \n    [2]   | pressure / incompressibility constraint \n\n  LHS block | PDEOperator(s)\n    [1,1]   | 0.0005 ∇(u):∇(v) (regions = [0])\n            | (a ⋅ ∇) u ⋅ v (regions = [0])\n    [1,2]   | div(v) ⋅ q (regions = [0])\n    [2,1]   | none\n    [2,2]   | none\n\n  RHS block | PDEOperator(s)\n     [1]    | none\n     [2]    | none\n\n   BoundaryOperator[1] : BestapproxDirichletBoundary -> [3]\n                         HomogeneousDirichletBoundary -> [1, 2, 4]\n                          \n   BoundaryOperator[2] : \n\n  GlobalConstraints[1] : Mean[2] != 0 \nProblem = \n┌ Info: ----- Solving incompressible Navier-Stokes-Problem -----\n│ \tEquation (1.1) momentum equation : velocity >> u_h (H1P2{2,2}, ndofs = 4226)\n│ \tEquation (1.2) incompressibility constraint : pressure >> p_h (H1P1{1}, ndofs = 545)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 2.325706e-17 | 1.450425e-02\n\t      2   | 2.101188e-17 | 7.842210e-03\n\t      3   | 3.055005e-17 | 4.035692e-03\n\t      4   | 2.543754e-17 | 2.093571e-03\n\t      5   | 2.911623e-17 | 2.345986e-03\n\t      6   | 2.720563e-17 | 1.672003e-03\n\t      7   | 3.075142e-17 | 8.213932e-04\n\t      8   | 2.946150e-17 | 4.516999e-04\n\t      9   | 3.228021e-17 | 2.657460e-04\n\t     10   | 2.863182e-17 | 1.785569e-04\n\t     11   | 3.117787e-17 | 1.009835e-04\n\t     12   | 2.687397e-17 | 4.587511e-05\n\n┌ Info: ----- Solving incompressible Navier-Stokes-Problem -----\n│ \tEquation (1.1) momentum equation : velocity >> u_h (H1P2{2,2}, ndofs = 4226)\n│ \tEquation (1.2) incompressibility constraint : pressure >> p_h (H1P1{1}, ndofs = 545)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 2.868063e-17 | 3.869884e-07\n\t      2   | 3.041589e-17 | 9.772812e-11\n\t      3   | 2.904447e-17 | 1.231147e-16\n\n","category":"page"},{"location":"examples/doc_2d_liddrivencavity_anderson/","page":"2D Lid-driven cavity (Anderson Acceleration)","title":"2D Lid-driven cavity (Anderson Acceleration)","text":"","category":"page"},{"location":"examples/doc_2d_liddrivencavity_anderson/","page":"2D Lid-driven cavity (Anderson Acceleration)","title":"2D Lid-driven cavity (Anderson Acceleration)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_2d_flowtransport/#D-Flow-Transport","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"","category":"section"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"(source code)","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"This example solve the Stokes problem in a Omega-shaped pipe and then uses the velocity in a transport equation for a species with a certain inlet concentration. Altogether, we are looking for a velocity mathbfu, a pressure mathbfp and a species concentration mathbfc such that","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"beginaligned\n- mu Delta mathbfu + nabla p  = 0\nmathrmdiv(u)  = 0\n- kappa Delta mathbfc + mathbfu cdot nabla mathbfc  = 0\nendaligned","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"with some viscosity parameter  and diffusion parameter kappa.","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"The diffusion coefficient for the species is chosen (almost) zero such that the isolines of the concentration should stay parallel from inlet to outlet. For the discretisation of the convection term in the transport equation two three possibilities can be chosen:","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"Classical finite element discretisations mathbfu_h cdot nabla mathbfc_h\nPressure-robust finite element discretisation Pi_textreconst mathbfu_h cdot nabla mathbfc_h with some divergence-free reconstruction operator Pi_textreconst\nUpwind finite volume discretisation for kappa = 0 based on normal fluxes along the faces (also divergence-free in finite volume sense)","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"Observe that a pressure-robust Bernardi–Raugel discretisation preserves this much better than a classical Bernardi–Raugel method. For comparison also a Taylor–Hood method can be switched on which is comparable to the pressure-robust lowest-order method in this example.","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"Note, that the transport equation is very convection-dominated and no stabilisation in the finite element discretisations was used here (but instead a nonzero kappa). The results are very sensitive to kappa and may be different if a stabilisation is used (work in progress). Also note, that only the finite volume discretisation perfectly obeys the maximum principle for the concentration but the isolines do no stay parallel until the outlet is reached, possibly due to articifial diffusion.","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"module Example_2DFlowTransport\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing Printf\n\n\n# boundary data\nfunction inlet_velocity!(result,x::Array{<:Real,1})\n    result[1] = 4*x[2]*(1-x[2]);\n    result[2] = 0;\nend\nfunction inlet_concentration!(result,x::Array{<:Real,1})\n    result[1] = 1-x[2];\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, Plotter = nothing, FVtransport = true, viscosity = 1)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # load mesh and refine\n    xgrid = simplexgrid(\"assets/2d_grid_upipe.sg\")\n    xgrid = uniform_refine(xgrid,4)\n\n    # choose one of these (inf-sup stable) finite element type pairs for the flow\n    #FETypes = [H1P2{2,2}, H1P1{1}]; postprocess_operator = Identity # Taylor--Hood\n    #FETypes = [H1BR{2}, H1P0{1}]; postprocess_operator = Identity # Bernardi--Raugel\n    FETypes = [H1BR{2}, H1P0{1}]; postprocess_operator = ReconstructionIdentity{HDIVRT0{2}} # Bernardi--Raugel pressure-robust (RT0 reconstruction)\n    #FETypes = [H1BR{2}, H1P0{1}]; postprocess_operator = ReconstructionIdentity{HDIVBDM1{2}} # Bernardi--Raugel pressure-robust (BDM1 reconstruction)\n\n    #####################################################################################\n\n    # negotiate data functions to the package\n    user_function_inlet_velocity = DataFunction(inlet_velocity!, [2,2]; name = \"inflow\", dependencies = \"X\", quadorder = 2)\n    user_function_inlet_species = DataFunction(inlet_concentration!, [1,2]; name = \"inlet concentration\", dependencies = \"X\", quadorder = 1)\n\n    # load Stokes problem prototype and assign boundary data\n    # (inlet profile in bregion 2, zero Dirichlet at walls 1 and nothing at outlet region 2)\n    Problem = IncompressibleNavierStokesProblem(2; viscosity = viscosity, nonlinear = false, no_pressure_constraint = true)\n    Problem.name = \"Stokes + Transport\"\n    add_boundarydata!(Problem, 1, [1,3], HomogeneousDirichletBoundary)\n    add_boundarydata!(Problem, 1, [4], BestapproxDirichletBoundary; data = user_function_inlet_velocity)\n\n    # add transport equation of species\n    add_unknown!(Problem; unknown_name = \"concentration\", equation_name = \"transport equation\")\n    if FVtransport == true\n        # finite volume upwind discretisation\n        FETypeTransport = H1P0{1}\n        add_operator!(Problem, [3,3], FVConvectionDiffusionOperator(1))\n    else\n        # finite element convection and diffusion (very small) operators\n        FETypeTransport = H1P1{1}\n        diffusion_FE = 1e-7 # diffusion coefficient for transport equation\n        add_operator!(Problem, [3,3], LaplaceOperator(diffusion_FE,2,1))\n        add_operator!(Problem, [3,3], ConvectionOperator(1, postprocess_operator, 2, 1))\n    end\n    # with boundary data (i.e. inlet concentration)\n    add_boundarydata!(Problem, 3, [4], InterpolateDirichletBoundary; data = user_function_inlet_species)\n    @show Problem\n\n    # generate FESpaces and a solution vector for all 3 unknowns\n    FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid), FESpace{FETypeTransport}(xgrid)]\n    Solution = FEVector{Float64}([\"v_h\", \"p_h\", \"c_h\"],FES)\n\n    # first solve the decoupled flow problem equations [1,2]\n    solve!(Solution, Problem; subiterations = [[1,2]], maxiterations = 5, target_residual = 1e-12)\n\n    # then solve the transport equation [3] by finite volumes or finite elements\n    if FVtransport == true\n        # pseudo-timestepping until stationarity detected, the matrix stays the same in each iteration\n        TCS = TimeControlSolver(Problem, Solution, BackwardEuler; subiterations = [[3]], skip_update = [-1], timedependent_equations = [3])\n        advance_until_stationarity!(TCS, 10000; maxTimeSteps = 100, stationarity_threshold = 1e-12)\n    else\n        # solve directly\n        solve!(Solution, Problem; subiterations = [[3]], maxiterations = 5, target_residual = 1e-12)\n    end\n\n    # print minimal and maximal concentration to check max principle (shoule be in [0,1])\n    println(\"\\n[min(c),max(c)] = [$(minimum(Solution[3][:])),$(maximum(Solution[3][:]))]\")\n\n    # plot\n    GradientRobustMultiPhysics.plot(xgrid, [Solution[1], Solution[2], Solution[3]], [Identity, Identity, Identity]; add_grid_plot = true, Plotter = Plotter)\nend\n\nend","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"Main.##263.Example_2DFlowTransport","category":"page"},{"location":"examples/doc_2d_flowtransport/#Output-of-default-main()-run","page":"2D Flow + Transport","title":"Output of default main() run","text":"","category":"section"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"Example_2DFlowTransport.main()","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"\nPDE-DESCRIPTION\n===============\n  system name = Stokes + Transport\n\n     id   | unknown name / equation name\n    [1]   | velocity / momentum equation \n    [2]   | pressure / incompressibility constraint \n    [3]   | concentration / transport equation \n\n  LHS block | PDEOperator(s)\n    [1,1]   | ∇(u):∇(v) (regions = [0])\n    [1,2]   | div(v) ⋅ q (regions = [0])\n    [1,3]   | none\n    [2,1]   | none\n    [2,2]   | none\n    [2,3]   | none\n    [3,1]   | none\n    [3,2]   | none\n    [3,3]   | FVConvectionDiffusion (regions = [0])\n\n  RHS block | PDEOperator(s)\n     [1]    | none\n     [2]    | none\n     [3]    | none\n\n   BoundaryOperator[1] : BestapproxDirichletBoundary -> [4]\n                         HomogeneousDirichletBoundary -> [1, 3]\n                          \n   BoundaryOperator[2] : \n   BoundaryOperator[3] : InterpolateDirichletBoundary -> [4]\n                         \n\nProblem = \n┌ Info: ----- Solving Stokes + Transport -----\n│ \tEquation (1.1) momentum equation : velocity >> v_h (H1BR{2}, ndofs = 12666)\n│ \tEquation (1.2) incompressibility constraint : pressure >> p_h (H1P0{1} (broken), ndofs = 4864)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 7.897017e-14 | 7.897017e-14\n┌ Info: target residual reached after 1 iterations\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1063\n\n┌ Info: ----- Preparing time control solver for Stokes + Transport -----\n│ \tEquation (1.3) transport equation : concentration >> c_h (H1P0{1} (broken), ndofs = 4864), timedependent = yes\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1278\n┌ Info: Advancing in time until stationarity...\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1612\n\n\t  STEP  |    TIME    | LSRESIDUAL |   CHANGE                         \n\t        |            |  (total)   |  velocity    pressure   concentrat \n\t     1  | 1.0000e+04 | 1.9772e-16 | 0.0000e+00  0.0000e+00  3.9306e+01 \n\t     2  | 2.0000e+04 | 2.2326e-16 | 0.0000e+00  0.0000e+00  1.1471e-01 \n\t     3  | 3.0000e+04 | 2.2778e-16 | 0.0000e+00  0.0000e+00  1.4916e-03 \n\t     4  | 4.0000e+04 | 2.1869e-16 | 0.0000e+00  0.0000e+00  2.9985e-05 \n\t     5  | 5.0000e+04 | 2.2220e-16 | 0.0000e+00  0.0000e+00  5.9612e-07 \n\t     6  | 6.0000e+04 | 2.2135e-16 | 0.0000e+00  0.0000e+00  1.1638e-08 \n\t     7  | 7.0000e+04 | 2.2131e-16 | 0.0000e+00  0.0000e+00  2.2492e-10 \n\t     8  | 8.0000e+04 | 2.2233e-16 | 0.0000e+00  0.0000e+00  4.3249e-12 \n\t     9  | 9.0000e+04 | 2.2167e-16 | 0.0000e+00  0.0000e+00  8.3680e-14 \n┌ Info: stationarity detected after 9 timesteps\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1656\n\n\n[min(c),max(c)] = [0.04166666666666386,0.9791666666666667]\n","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"","category":"page"},{"location":"examples/doc_2d_flowtransport/","page":"2D Flow + Transport","title":"2D Flow + Transport","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_2d_transientstokes/#D-Transient-Stokes-Problem","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"","category":"section"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"(source code)","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"This example computes a velocity mathbfu and pressure mathbfp of the incompressible Navier–Stokes problem","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"beginaligned\nmathbfu_t - mu Delta mathbfu + nabla p  = mathbff\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"with (possibly time-dependent) exterior force mathbff and some viscosity parameter mu.","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"In this example we solve an analytical toy problem with prescribed solution","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"beginaligned\nmathbfu(mathbfxt)  = (1+t)(cos(x_2) sin(x_1))^T\np(mathbfx) = sin(x_1+x_2) - 2sin(1) + sin(2)\nendaligned","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"with time-dependent right-hand side and inhomogeneous Dirichlet boundary data. The example showcases the benefits of pressure-robustness in time-dependent linear Stokes problem in presence of complicated pressures and small viscosities. The problem is solved on series of finer and finer unstructured simplex meshes and compares the error of the discrete Stokes solution, an interpolation into the same space and the best-approximations into the same space. While a pressure-robust variant shows optimally converging errors close to the best-approximations, a non pressure-robust discretisations show suboptimal (or no) convergence! Compare e.g. Bernardi–Raugel and Bernardi–Raugel pressure-robust by (un)commenting the responsible lines in this example.","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"module Example_2DTransientStokes\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing Printf\n\n# problem data\nfunction exact_pressure!(result,x::Array{<:Real,1})\n    result[1] = sin(x[1]+x[2]) - 2*sin(1)+sin(2)\nend\nfunction exact_velocity!(result,x::Array{<:Real,1},t::Real)\n    result[1] = (1+t)*cos(x[2]);\n    result[2] = (1+t)*sin(x[1]);\nend\nfunction exact_velocity_gradient!(result,x::Array{<:Real,1},t::Real)\n    result[1] = 0.0\n    result[2] = -(1+t)*sin(x[2]);\n    result[3] = (1+t)*cos(x[1]);\n    result[4] = 0.0;\nend\nfunction exact_rhs!(viscosity)\n    function closure(result,x::Array{<:Real,1},t::Real)\n        result[1] = viscosity*(1+t)*cos(x[2]) + cos(x[1]+x[2]) + cos(x[2])\n        result[2] = viscosity*(1+t)*sin(x[1]) + cos(x[1]+x[2]) + sin(x[1])\n    end\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, Plotter = nothing, nlevels = 4, timestep = 1e-3, T = 1e-2, viscosity = 1e-6, graddiv = 0)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # initial grid\n    xgrid = grid_unitsquare(Triangle2D);\n\n    # choose one of these (inf-sup stable) finite element type pairs\n    reconstruct = false # do not change\n    broken_p = false # is pressure space broken ?\n    #FETypes = [H1P2{2,2}, H1P1{1}] # Taylor--Hood\n    #FETypes = [H1P2B{2,2}, H1P1{1}]; broken_p = true # P2-bubble\n    #FETypes = [H1CR{2}, H1P0{1}]; broken_p = true # Crouzeix--Raviart\n    #FETypes = [H1CR{2}, H1P0{1}]; broken_p = true; reconstruct = true # Crouzeix-Raviart gradient-robust\n    #FETypes = [H1MINI{2,2}, H1P1{1}] # MINI element on triangles only\n    #FETypes = [H1MINI{2,2}, H1CR{1}] # MINI element on triangles/quads\n    #FETypes = [H1BR{2}, H1P0{1}]; broken_p = true # Bernardi--Raugel\n    FETypes = [H1BR{2}, H1P0{1}]; broken_p = true; reconstruct = true # Bernardi--Raugel gradient-robust\n\n    #####################################################################################\n\n    # set testfunction operator for certain testfunctions\n    # (pressure-robustness chooses a reconstruction that can exploit the L2-orthogonality onto gradients)\n    testfunction_operator = reconstruct ? ReconstructionIdentity{HDIVBDM1{2}} : Identity\n\n    # negotiate data functions to the package\n    # note that dependencies \"XT\" marks the function to be x- and t-dependent\n    # that causes the solver to automatically reassemble associated operators in each time step\n    user_function_velocity = DataFunction(exact_velocity!, [2,2]; name = \"u_exact\", dependencies = \"XT\", quadorder = 5)\n    user_function_pressure = DataFunction(exact_pressure!, [1,2]; name = \"p_exact\", dependencies = \"X\", quadorder = 5)\n    user_function_velocity_gradient = DataFunction(exact_velocity_gradient!, [4,2]; name = \"grad(u_exact)\", dependencies = \"XT\", quadorder = 4)\n    user_function_rhs = DataFunction(exact_rhs!(viscosity), [2,2]; name = \"f\", dependencies = \"XT\", quadorder = 5)\n\n    # load Stokes problem prototype and assign data\n    Problem = IncompressibleNavierStokesProblem(2; viscosity = viscosity, nonlinear = false)\n    add_boundarydata!(Problem, 1, [1,2,3,4], BestapproxDirichletBoundary; data = user_function_velocity)\n    add_rhsdata!(Problem, 1, RhsOperator(testfunction_operator, [1], user_function_rhs))\n\n    # add grad-div stabilisation\n    if graddiv > 0\n        add_operator!(Problem, [1,1], AbstractBilinearForm(\"graddiv-stabilisation (div x div)\", Divergence, Divergence, MultiplyScalarAction(graddiv)))\n    end\n\n    # define bestapproximation problems\n    L2PressureBestapproximationProblem = L2BestapproximationProblem(user_function_pressure; bestapprox_boundary_regions = [])\n    L2VelocityBestapproximationProblem = L2BestapproximationProblem(user_function_velocity; bestapprox_boundary_regions = [1,2,3,4])\n    H1VelocityBestapproximationProblem = H1BestapproximationProblem(user_function_velocity_gradient, user_function_velocity; bestapprox_boundary_regions = [1,2,3,4])\n\n    # define ItemIntegrators for L2/H1 error computation and arrays to store them\n    L2VelocityErrorEvaluator = L2ErrorIntegrator(Float64, user_function_velocity, Identity; time = T)\n    L2PressureErrorEvaluator = L2ErrorIntegrator(Float64, user_function_pressure, Identity)\n    H1VelocityErrorEvaluator = L2ErrorIntegrator(Float64, user_function_velocity_gradient, Gradient; time = T)\n    L2error_velocity = []; L2error_pressure = []; NDofs = []\n    L2errorBestApproximation_velocity = []; L2errorBestApproximation_pressure = []\n    H1error_velocity = []; H1errorBestApproximation_velocity = []\n\n    # loop over levels\n    for level = 1 : nlevels\n\n        # refine grid\n        xgrid = uniform_refine(xgrid)\n\n        # generate FESpaces\n        FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid; broken = broken_p)]\n\n        # generate solution fector\n        Solution = FEVector{Float64}([\"velocity\", \"pressure\"],FES)\n        push!(NDofs,length(Solution.entries))\n\n        # set initial solution ( = bestapproximation at time 0)\n        L2VelocityBestapproximation = FEVector{Float64}(\"L2-Bestapproximation velocity\",FES[1])\n        solve!(L2VelocityBestapproximation, L2VelocityBestapproximationProblem; time = 0)\n        Solution[1][:] = L2VelocityBestapproximation[1][:]\n\n        # generate time-dependent solver and chance rhs data\n        TCS = TimeControlSolver(Problem, Solution, BackwardEuler; timedependent_equations = [1], skip_update = [-1], dt_testfunction_operator = [testfunction_operator])\n        advance_until_time!(TCS, timestep, T)\n\n        # solve bestapproximation problems at final time for comparison\n        L2PressureBestapproximation = FEVector{Float64}(\"L2-Bestapproximation pressure\",FES[2])\n        H1VelocityBestapproximation = FEVector{Float64}(\"H1-Bestapproximation velocity\",FES[1])\n        solve!(L2VelocityBestapproximation, L2VelocityBestapproximationProblem; time = T)\n        solve!(L2PressureBestapproximation, L2PressureBestapproximationProblem)\n        solve!(H1VelocityBestapproximation, H1VelocityBestapproximationProblem; time = T)\n\n        # compute L2 and H1 error of all solutions\n        append!(L2error_velocity,sqrt(evaluate(L2VelocityErrorEvaluator,Solution[1])))\n        append!(L2errorBestApproximation_velocity,sqrt(evaluate(L2VelocityErrorEvaluator,L2VelocityBestapproximation[1])))\n        append!(L2error_pressure,sqrt(evaluate(L2PressureErrorEvaluator,Solution[2])))\n        append!(L2errorBestApproximation_pressure,sqrt(evaluate(L2PressureErrorEvaluator,L2PressureBestapproximation[1])))\n        append!(H1error_velocity,sqrt(evaluate(H1VelocityErrorEvaluator,Solution[1])))\n        append!(H1errorBestApproximation_velocity,sqrt(evaluate(H1VelocityErrorEvaluator,H1VelocityBestapproximation[1])))\n\n        # ouput errors\n        if (level == nlevels)\n            println(\"\\n         |   L2ERROR      order   |   L2ERROR      order   \")\n            println(\"   NDOF  | VELO-STOKES            | VELO-L2BEST            \");\n            order = 0\n            for j=1:nlevels\n                if j > 1\n                    order = log(L2error_velocity[j-1]/L2error_velocity[j]) / (log(NDofs[j]/NDofs[j-1])/2)\n                end\n                @printf(\"  %6d | %.5e    %.3f   |\",NDofs[j], L2error_velocity[j], order);\n                if j > 1\n                    order = log(L2errorBestApproximation_velocity[j-1]/L2errorBestApproximation_velocity[j]) / (log(NDofs[j]/NDofs[j-1])/2)\n                end\n                @printf(\" %.5e    %.3f\\n\",L2errorBestApproximation_velocity[j], order)\n            end\n            println(\"\\n         |   H1ERROR      order   |   H1ERROR      order   \")\n            println(\"   NDOF  | VELO-STOKES            | VELO-H1BEST            \");\n            order = 0\n            for j=1:nlevels\n                if j > 1\n                    order = log(H1error_velocity[j-1]/H1error_velocity[j]) / (log(NDofs[j]/NDofs[j-1])/2)\n                end\n                @printf(\"  %6d | %.5e    %.3f   |\",NDofs[j], H1error_velocity[j], order);\n                if j > 1\n                    order = log(H1errorBestApproximation_velocity[j-1]/H1errorBestApproximation_velocity[j]) / (log(NDofs[j]/NDofs[j-1])/2)\n                end\n                @printf(\" %.5e    %.3f\\n\",H1errorBestApproximation_velocity[j], order)\n            end\n            println(\"\\n         |   L2ERROR      order   |   L2ERROR      order   \")\n            println(\"   NDOF  | PRES-STOKES            | PRES-L2BEST            \");\n            order = 0\n            for j=1:nlevels\n                if j > 1\n                    order = log(L2error_pressure[j-1]/L2error_pressure[j]) / (log(NDofs[j]/NDofs[j-1])/2)\n                end\n                @printf(\"  %6d | %.5e    %.3f   |\",NDofs[j], L2error_pressure[j], order);\n                if j > 1\n                    order = log(L2errorBestApproximation_pressure[j-1]/L2errorBestApproximation_pressure[j]) / (log(NDofs[j]/NDofs[j-1])/2)\n                end\n                @printf(\" %.5e    %.3f\\n\",L2errorBestApproximation_pressure[j], order)\n            end\n            println(\"\\nLEGEND\\n======\")\n            println(\"VELO-STOKES : discrete Stokes velocity solution ($(FES[1].name))\")\n            println(\"VELO-L2BEST : L2-Bestapproximation of exact velocity (with boundary data)\")\n            println(\"VELO-H1BEST : H1-Bestapproximation of exact velocity (with boudnary data)\")\n            println(\"PRES-STOKES : discrete Stokes pressure solution ($(FES[2].name))\")\n            println(\"PRES-L2BEST : L2-Bestapproximation of exact pressure (without boundary data)\")\n\n            GradientRobustMultiPhysics.plot(xgrid, [Solution[1], Solution[2]], [Identity, Identity]; add_grid_plot = true, Plotter = Plotter)\n        end\n    end\nend\n\nend","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"Main.##269.Example_2DTransientStokes","category":"page"},{"location":"examples/doc_2d_transientstokes/#Output-of-default-main()-run","page":"2D Transient Stokes-Problem","title":"Output of default main() run","text":"","category":"section"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"Example_2DTransientStokes.main()","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"┌ Info: ----- Solving L2-Bestapproximation problem (at fixed time time) -----\n│ \tEquation (1.1) L2-bestapproximation equation : u_exact >> L2-Bestapproximation velocity (H1BR{2}, ndofs = 54)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 7.61897186174398e-17\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Preparing time control solver for incompressible Stokes-Problem -----\n│ \tEquation (1.1) momentum equation : velocity >> velocity (H1BR{2}, ndofs = 54), timedependent = yes\n│ \tEquation (1.2) incompressibility constraint : pressure >> pressure (H1P0{1} (broken), ndofs = 16), timedependent = no\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1278\n┌ Info: Advancing in time from 0 until 0.01\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1690\n\n\t  STEP  |    TIME    | LSRESIDUAL |   CHANGE                 \n\t        |            |  (total)   |  velocity    pressure  \n\t     1  | 1.0000e-03 | 7.9287e-14 | 4.9651e-03  3.0773e+00 \n\t     2  | 2.0000e-03 | 6.8660e-14 | 3.6022e-03  2.3073e+00 \n\t     3  | 3.0000e-03 | 6.4342e-14 | 3.6022e-03  1.1207e-10 \n\t     4  | 4.0000e-03 | 8.1233e-14 | 3.6022e-03  1.1171e-10 \n\t     5  | 5.0000e-03 | 5.9534e-14 | 3.6022e-03  1.1202e-10 \n\t     6  | 6.0000e-03 | 7.0385e-14 | 3.6022e-03  1.1169e-10 \n\t     7  | 7.0000e-03 | 8.4582e-14 | 3.6022e-03  1.1220e-10 \n\t     8  | 8.0000e-03 | 6.5268e-14 | 3.6022e-03  1.1181e-10 \n\t     9  | 9.0000e-03 | 8.6987e-14 | 3.6022e-03  1.1210e-10 \n\t    10  | 1.0000e-02 | 6.9619e-14 | 3.6022e-03  1.1180e-10 \n\n┌ Info: ----- Solving L2-Bestapproximation problem (at fixed time time) -----\n│ \tEquation (1.1) L2-bestapproximation equation : u_exact >> L2-Bestapproximation velocity (H1BR{2}, ndofs = 54)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 6.847215279489668e-17\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving L2-Bestapproximation problem -----\n│ \tEquation (1.1) L2-bestapproximation equation : p_exact >> L2-Bestapproximation pressure (H1P0{1} (broken), ndofs = 16)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 0.0\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving H1-Bestapproximation problem (at fixed time time) -----\n│ \tEquation (1.1) H1-bestapproximation equation : u_exact >> H1-Bestapproximation velocity (H1BR{2}, ndofs = 54)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 1.242746260799772e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving L2-Bestapproximation problem (at fixed time time) -----\n│ \tEquation (1.1) L2-bestapproximation equation : u_exact >> L2-Bestapproximation velocity (H1BR{2}, ndofs = 186)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 3.491875884044018e-17\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Preparing time control solver for incompressible Stokes-Problem -----\n│ \tEquation (1.1) momentum equation : velocity >> velocity (H1BR{2}, ndofs = 186), timedependent = yes\n│ \tEquation (1.2) incompressibility constraint : pressure >> pressure (H1P0{1} (broken), ndofs = 64), timedependent = no\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1278\n┌ Info: Advancing in time from 0 until 0.01\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1690\n\n\t  STEP  |    TIME    | LSRESIDUAL |   CHANGE                 \n\t        |            |  (total)   |  velocity    pressure  \n\t     1  | 1.0000e-03 | 4.2420e-14 | 5.6702e-03  2.8195e+00 \n\t     2  | 2.0000e-03 | 3.9699e-14 | 6.4012e-03  1.1598e+00 \n\t     3  | 3.0000e-03 | 4.1321e-14 | 6.4012e-03  1.4695e-10 \n\t     4  | 4.0000e-03 | 4.0197e-14 | 6.4012e-03  1.4498e-10 \n\t     5  | 5.0000e-03 | 3.9602e-14 | 6.4012e-03  1.4613e-10 \n\t     6  | 6.0000e-03 | 3.8764e-14 | 6.4012e-03  1.4585e-10 \n\t     7  | 7.0000e-03 | 3.9580e-14 | 6.4012e-03  1.4587e-10 \n\t     8  | 8.0000e-03 | 4.4734e-14 | 6.4012e-03  1.4600e-10 \n\t     9  | 9.0000e-03 | 4.0968e-14 | 6.4012e-03  1.4607e-10 \n\t    10  | 1.0000e-02 | 4.2265e-14 | 6.4012e-03  1.4540e-10 \n\n┌ Info: ----- Solving L2-Bestapproximation problem (at fixed time time) -----\n│ \tEquation (1.1) L2-bestapproximation equation : u_exact >> L2-Bestapproximation velocity (H1BR{2}, ndofs = 186)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 3.0391619957323214e-17\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving L2-Bestapproximation problem -----\n│ \tEquation (1.1) L2-bestapproximation equation : p_exact >> L2-Bestapproximation pressure (H1P0{1} (broken), ndofs = 64)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 0.0\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving H1-Bestapproximation problem (at fixed time time) -----\n│ \tEquation (1.1) H1-bestapproximation equation : u_exact >> H1-Bestapproximation velocity (H1BR{2}, ndofs = 186)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 2.3048572313369617e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving L2-Bestapproximation problem (at fixed time time) -----\n│ \tEquation (1.1) L2-bestapproximation equation : u_exact >> L2-Bestapproximation velocity (H1BR{2}, ndofs = 690)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 1.514517705506503e-17\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Preparing time control solver for incompressible Stokes-Problem -----\n│ \tEquation (1.1) momentum equation : velocity >> velocity (H1BR{2}, ndofs = 690), timedependent = yes\n│ \tEquation (1.2) incompressibility constraint : pressure >> pressure (H1P0{1} (broken), ndofs = 256), timedependent = no\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1278\n┌ Info: Advancing in time from 0 until 0.01\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1690\n\n\t  STEP  |    TIME    | LSRESIDUAL |   CHANGE                 \n\t        |            |  (total)   |  velocity    pressure  \n\t     1  | 1.0000e-03 | 2.0974e-14 | 1.1430e-02  4.0417e+00 \n\t     2  | 2.0000e-03 | 2.1543e-14 | 1.2040e-02  5.7953e-01 \n\t     3  | 3.0000e-03 | 2.2778e-14 | 1.2040e-02  9.5561e-11 \n\t     4  | 4.0000e-03 | 2.1817e-14 | 1.2040e-02  9.4403e-11 \n\t     5  | 5.0000e-03 | 2.1931e-14 | 1.2040e-02  9.5659e-11 \n\t     6  | 6.0000e-03 | 2.0687e-14 | 1.2040e-02  9.4704e-11 \n\t     7  | 7.0000e-03 | 2.0931e-14 | 1.2040e-02  9.5582e-11 \n\t     8  | 8.0000e-03 | 2.1496e-14 | 1.2040e-02  9.4667e-11 \n\t     9  | 9.0000e-03 | 2.1339e-14 | 1.2040e-02  9.5814e-11 \n\t    10  | 1.0000e-02 | 2.0883e-14 | 1.2040e-02  9.4782e-11 \n\n┌ Info: ----- Solving L2-Bestapproximation problem (at fixed time time) -----\n│ \tEquation (1.1) L2-bestapproximation equation : u_exact >> L2-Bestapproximation velocity (H1BR{2}, ndofs = 690)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 1.569075043917697e-17\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving L2-Bestapproximation problem -----\n│ \tEquation (1.1) L2-bestapproximation equation : p_exact >> L2-Bestapproximation pressure (H1P0{1} (broken), ndofs = 256)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 0.0\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving H1-Bestapproximation problem (at fixed time time) -----\n│ \tEquation (1.1) H1-bestapproximation equation : u_exact >> H1-Bestapproximation velocity (H1BR{2}, ndofs = 690)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 4.541029325719007e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving L2-Bestapproximation problem (at fixed time time) -----\n│ \tEquation (1.1) L2-bestapproximation equation : u_exact >> L2-Bestapproximation velocity (H1BR{2}, ndofs = 2658)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 8.192328913652911e-18\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Preparing time control solver for incompressible Stokes-Problem -----\n│ \tEquation (1.1) momentum equation : velocity >> velocity (H1BR{2}, ndofs = 2658), timedependent = yes\n│ \tEquation (1.2) incompressibility constraint : pressure >> pressure (H1P0{1} (broken), ndofs = 1024), timedependent = no\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1278\n┌ Info: Advancing in time from 0 until 0.01\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1690\n\n\t  STEP  |    TIME    | LSRESIDUAL |   CHANGE                 \n\t        |            |  (total)   |  velocity    pressure  \n\t     1  | 1.0000e-03 | 1.1128e-14 | 2.2993e-02  7.3187e+00 \n\t     2  | 2.0000e-03 | 1.1125e-14 | 2.3341e-02  2.8899e-01 \n\t     3  | 3.0000e-03 | 1.0720e-14 | 2.3341e-02  6.5471e-09 \n\t     4  | 4.0000e-03 | 1.0848e-14 | 2.3341e-02  6.5268e-09 \n\t     5  | 5.0000e-03 | 1.1290e-14 | 2.3341e-02  6.4975e-09 \n\t     6  | 6.0000e-03 | 1.0965e-14 | 2.3341e-02  6.4758e-09 \n\t     7  | 7.0000e-03 | 1.1399e-14 | 2.3341e-02  6.4483e-09 \n\t     8  | 8.0000e-03 | 1.0808e-14 | 2.3341e-02  6.4273e-09 \n\t     9  | 9.0000e-03 | 1.0978e-14 | 2.3341e-02  6.3970e-09 \n\t    10  | 1.0000e-02 | 1.1124e-14 | 2.3341e-02  6.3797e-09 \n\n┌ Info: ----- Solving L2-Bestapproximation problem (at fixed time time) -----\n│ \tEquation (1.1) L2-bestapproximation equation : u_exact >> L2-Bestapproximation velocity (H1BR{2}, ndofs = 2658)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 8.732588284264897e-18\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving L2-Bestapproximation problem -----\n│ \tEquation (1.1) L2-bestapproximation equation : p_exact >> L2-Bestapproximation pressure (H1P0{1} (broken), ndofs = 1024)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 0.0\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving H1-Bestapproximation problem (at fixed time time) -----\n│ \tEquation (1.1) H1-bestapproximation equation : u_exact >> H1-Bestapproximation velocity (H1BR{2}, ndofs = 2658)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 9.944619447493298e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\n         |   L2ERROR      order   |   L2ERROR      order   \n   NDOF  | VELO-STOKES            | VELO-L2BEST            \n      70 | 2.83479e-03    0.000   | 2.16474e-03    0.000\n     250 | 6.94502e-04    2.210   | 5.11118e-04    2.268\n     946 | 1.70438e-04    2.111   | 1.21282e-04    2.162\n    3682 | 4.22301e-05    2.053   | 2.92850e-05    2.091\n\n         |   H1ERROR      order   |   H1ERROR      order   \n   NDOF  | VELO-STOKES            | VELO-H1BEST            \n      70 | 5.12836e-02    0.000   | 4.81476e-02    0.000\n     250 | 2.59216e-02    1.072   | 2.38875e-02    1.101\n     946 | 1.30868e-02    1.027   | 1.18665e-02    1.051\n    3682 | 6.52868e-03    1.023   | 5.90884e-03    1.026\n\n         |   L2ERROR      order   |   L2ERROR      order   \n   NDOF  | PRES-STOKES            | PRES-L2BEST            \n      70 | 6.98506e-02    0.000   | 6.98503e-02    0.000\n     250 | 3.49744e-02    1.087   | 3.49744e-02    1.087\n     946 | 1.74943e-02    1.041   | 1.74943e-02    1.041\n    3682 | 8.74806e-03    1.020   | 8.74806e-03    1.020\n\nLEGEND\n======\nVELO-STOKES : discrete Stokes velocity solution (H1BR{2})\nVELO-L2BEST : L2-Bestapproximation of exact velocity (with boundary data)\nVELO-H1BEST : H1-Bestapproximation of exact velocity (with boudnary data)\nPRES-STOKES : discrete Stokes pressure solution (H1P0{1} (broken))\nPRES-L2BEST : L2-Bestapproximation of exact pressure (without boundary data)\n","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"","category":"page"},{"location":"examples/doc_2d_transientstokes/","page":"2D Transient Stokes-Problem","title":"2D Transient Stokes-Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_3d_poisson/#D-Poisson-Problem","page":"3D Poisson-Problem","title":"3D Poisson-Problem","text":"","category":"section"},{"location":"examples/doc_3d_poisson/","page":"3D Poisson-Problem","title":"3D Poisson-Problem","text":"(source code)","category":"page"},{"location":"examples/doc_3d_poisson/","page":"3D Poisson-Problem","title":"3D Poisson-Problem","text":"This example computes the solution u of the three dimensional Poisson problem","category":"page"},{"location":"examples/doc_3d_poisson/","page":"3D Poisson-Problem","title":"3D Poisson-Problem","text":"beginaligned\n-Delta u  = f quad textin  Omega\nendaligned","category":"page"},{"location":"examples/doc_3d_poisson/","page":"3D Poisson-Problem","title":"3D Poisson-Problem","text":"with some right-hand side f on the unit cube domain Omega on a series of uniform refined meshes (tetrahedra or parallelepipeds).","category":"page"},{"location":"examples/doc_3d_poisson/","page":"3D Poisson-Problem","title":"3D Poisson-Problem","text":"module Example_3DPoisson\n\nusing GradientRobustMultiPhysics\nusing Printf\n\n# problem data\nfunction exact_function!(result,x::Array{<:Real,1})\n    result[1] = x[1]*(x[3] - x[2]) + x[2]*x[2]\n    return nothing\nend\nfunction exact_gradient!(result,x::Array{<:Real,1})\n    result[1] = x[3] - x[2]\n    result[2] = - x[1] + 2*x[2]\n    result[3] = x[1]\n    return nothing\nend\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, verbosity = 0, nlevels = 4)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # choose initial mesh\n    # (replace Parallelepiped3D by Tetrahedron3D to change the cell geometries)\n    xgrid = grid_unitcube(Tetrahedron3D)\n\n    # set finite element type used for discretisation\n    FEType = H1P1{1}\n\n    # negotiate data functions to the package\n    user_function = DataFunction(exact_function!, [1,3]; name = \"u\", dependencies = \"X\", quadorder = 2)\n    user_function_gradient = DataFunction(exact_gradient!, [3,3]; name = \"∇(u)\", dependencies = \"X\", quadorder = 1)\n    user_function_rhs = DataFunction([-2]; name = \"f\")\n\n    # create Poisson problem via prototype and add data\n    Problem = PoissonProblem(1.0)\n    add_boundarydata!(Problem, 1, [1,2,3,4,5,6], BestapproxDirichletBoundary; data = user_function)\n    add_rhsdata!(Problem, 1,  RhsOperator(Identity, [0], user_function_rhs))\n\n    # prepare error calculation\n    L2ErrorEvaluator = L2ErrorIntegrator(Float64, user_function, Identity)\n    H1ErrorEvaluator = L2ErrorIntegrator(Float64, user_function_gradient, Gradient)\n    L2error = []; H1error = []; NDofs = []\n\n    # loop over levels\n    Solution = nothing\n    for level = 1 : nlevels\n        # uniform mesh refinement\n        xgrid = uniform_refine(xgrid)\n\n        # create finite element space and solution vector\n        FES = FESpace{FEType}(xgrid)\n        Solution = FEVector{Float64}(\"u_h\",FES)\n        push!(NDofs,length(Solution.entries))\n\n        # solve the problem\n        solve!(Solution, Problem)\n\n        # calculate L2 and H1 error\n        append!(L2error,sqrt(evaluate(L2ErrorEvaluator,Solution[1])))\n        append!(H1error,sqrt(evaluate(H1ErrorEvaluator,Solution[1])))\n    end\n\n    # output errors in a nice table\n    println(\"\\n   NDOF  |   L2ERROR   |   H1ERROR\")\n    for j=1:nlevels\n        @printf(\"  %6d |\",NDofs[j]);\n        @printf(\" %.5e |\",L2error[j])\n        @printf(\" %.5e\\n\",H1error[j])\n    end\n\n    # plot (Plotter = Makie should work)\n    GradientRobustMultiPhysics.plot(xgrid, [Solution[1]], [Identity]; Plotter = Plotter)\nend\n\nend","category":"page"},{"location":"examples/doc_3d_poisson/","page":"3D Poisson-Problem","title":"3D Poisson-Problem","text":"Main.##272.Example_3DPoisson","category":"page"},{"location":"examples/doc_3d_poisson/#Output-of-default-main()-run","page":"3D Poisson-Problem","title":"Output of default main() run","text":"","category":"section"},{"location":"examples/doc_3d_poisson/","page":"3D Poisson-Problem","title":"3D Poisson-Problem","text":"Example_3DPoisson.main()","category":"page"},{"location":"examples/doc_3d_poisson/","page":"3D Poisson-Problem","title":"3D Poisson-Problem","text":"┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P1{1}, ndofs = 27)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 5.551115123125783e-17\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P1{1}, ndofs = 125)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 3.561045489399806e-16\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P1{1}, ndofs = 729)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 6.218342482269393e-16\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n┌ Info: ----- Solving Poisson problem -----\n│ \tEquation (1.1) Poisson equation : u >> u_h (H1P1{1}, ndofs = 4913)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 1.1688174716217546e-15\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n\n   NDOF  |   L2ERROR   |   H1ERROR\n      27 | 3.38581e-02 | 4.38269e-01\n     125 | 8.97264e-03 | 2.25880e-01\n     729 | 2.28139e-03 | 1.13818e-01\n    4913 | 5.73658e-04 | 5.70179e-02\n","category":"page"},{"location":"examples/doc_3d_poisson/","page":"3D Poisson-Problem","title":"3D Poisson-Problem","text":"","category":"page"},{"location":"examples/doc_3d_poisson/","page":"3D Poisson-Problem","title":"3D Poisson-Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/doc_rational_massmatrix/#Rational-Mass-Matrix","page":"Rational Mass Matrix","title":"Rational Mass Matrix","text":"","category":"section"},{"location":"examples/doc_rational_massmatrix/","page":"Rational Mass Matrix","title":"Rational Mass Matrix","text":"(source code)","category":"page"},{"location":"examples/doc_rational_massmatrix/","page":"Rational Mass Matrix","title":"Rational Mass Matrix","text":"This example demonstrates the usage of rational numbers to calculate e.g. exact mass matrices on reference domains (if exact quadrature rules in Rational number format are available).","category":"page"},{"location":"examples/doc_rational_massmatrix/","page":"Rational Mass Matrix","title":"Rational Mass Matrix","text":"module Example_RationalMAMA\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 1, Plotter = nothing)\n\n    # reference domain as extendable grid\n    xgrid = reference_domain(Triangle2D, Rational)\n\n    # define P1-Courant finite element space\n    FES = FESpace{H1P1{1}}(xgrid)\n\n    # define mass matrix bilinear form\n    MAMA_BLF = SymmetricBilinearForm(Rational,ON_CELLS,[FES,FES],[Identity,Identity])\n\n    # assemble mass matrix and divide by area\n    MAMA = FEMatrix{Rational}(\"mass matrix\",FES)\n    assemble!(MAMA[1],MAMA_BLF)\n    MAMA = MAMA.entries ./ xgrid[CellVolumes][1]\n\n    # print matrix\n    @show MAMA\nend\n\nend","category":"page"},{"location":"examples/doc_rational_massmatrix/","page":"Rational Mass Matrix","title":"Rational Mass Matrix","text":"Main.##273.Example_RationalMAMA","category":"page"},{"location":"examples/doc_rational_massmatrix/#Output-of-default-main()-run","page":"Rational Mass Matrix","title":"Output of default main() run","text":"","category":"section"},{"location":"examples/doc_rational_massmatrix/","page":"Rational Mass Matrix","title":"Rational Mass Matrix","text":"Example_RationalMAMA.main()","category":"page"},{"location":"examples/doc_rational_massmatrix/","page":"Rational Mass Matrix","title":"Rational Mass Matrix","text":"3×3 Matrix{Rational{Int64}}:\n 1//6   1//12  1//12\n 1//12  1//6   1//12\n 1//12  1//12  1//6","category":"page"},{"location":"examples/doc_rational_massmatrix/","page":"Rational Mass Matrix","title":"Rational Mass Matrix","text":"","category":"page"},{"location":"examples/doc_rational_massmatrix/","page":"Rational Mass Matrix","title":"Rational Mass Matrix","text":"This page was generated using Literate.jl.","category":"page"},{"location":"assembly_details/#Assembly-Details","page":"Assembly Details","title":"Assembly Details","text":"","category":"section"},{"location":"assembly_details/","page":"Assembly Details","title":"Assembly Details","text":"The assembly of an operator is essentially based on a combination of Assembly Types and Assembly Patterns. The assembly type mainly allows to choose the geometry information needed for providing quadrature and dof handling. The assembly pattern then basically evaluates the function operators and action for the ansatz and test functions and does the quadrature-weighted accumulation into matrices or vectors that represent the operators.","category":"page"},{"location":"assembly_details/#Assembly-Types","page":"Assembly Details","title":"Assembly Types","text":"","category":"section"},{"location":"assembly_details/","page":"Assembly Details","title":"Assembly Details","text":"The following assembly types are available. Additional to define where AssemblyPatterns live and assemble, they can be also used as an argument for interpolation!.","category":"page"},{"location":"assembly_details/","page":"Assembly Details","title":"Assembly Details","text":"AssemblyType Description\nAT_NODES interpolate at vertices of the mesh (only for H1-conforming FEM)\nON_CELLS assemble/interpolate over the cells of the mesh\nON_FACES assemble/interpolate over all faces of the mesh\nON_IFACES assemble/interpolate over the interior faces of the mesh\nON_BFACES assemble/interpolate over the boundary faces of the mesh\nON_EDGES (*) assemble/interpolate over all edges of the mesh (in 3D)\nON_BEDGES (*) assemble/interpolate over the boundary edges of the mesh (in 3D)","category":"page"},{"location":"assembly_details/","page":"Assembly Details","title":"Assembly Details","text":"note: Note\n(*) = only reasonable in 3D and still experimental, might have some issues","category":"page"},{"location":"assembly_details/","page":"Assembly Details","title":"Assembly Details","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"assemblytypes.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"assembly_details/#GradientRobustMultiPhysics.AT_NODES","page":"Assembly Details","title":"GradientRobustMultiPhysics.AT_NODES","text":"abstract type AT_NODES <: AbstractAssemblyType\n\ncauses interpolation at vertices of the grid (only for H1-conforming interpolations)\n\n\n\n\n\n","category":"type"},{"location":"assembly_details/#GradientRobustMultiPhysics.ON_BEDGES","page":"Assembly Details","title":"GradientRobustMultiPhysics.ON_BEDGES","text":"abstract type ON_BEDGES <: AbstractAssemblyType\n\ncauses assembly/interpolation on boundary edges of the grid (only in 3D)\n\n\n\n\n\n","category":"type"},{"location":"assembly_details/#GradientRobustMultiPhysics.ON_BFACES","page":"Assembly Details","title":"GradientRobustMultiPhysics.ON_BFACES","text":"abstract type ON_BFACES <: AbstractAssemblyType\n\ncauses assembly/interpolation on boundary faces of the grid\n\n\n\n\n\n","category":"type"},{"location":"assembly_details/#GradientRobustMultiPhysics.ON_CELLS","page":"Assembly Details","title":"GradientRobustMultiPhysics.ON_CELLS","text":"abstract type ON_CELLS <: AbstractAssemblyType\n\ncauses assembly/interpolation on cells of the grid\n\n\n\n\n\n","category":"type"},{"location":"assembly_details/#GradientRobustMultiPhysics.ON_EDGES","page":"Assembly Details","title":"GradientRobustMultiPhysics.ON_EDGES","text":"abstract type ON_EDGES <: AbstractAssemblyType\n\ncauses assembly/interpolation on edges of the grid (only in 3D)\n\n\n\n\n\n","category":"type"},{"location":"assembly_details/#GradientRobustMultiPhysics.ON_FACES","page":"Assembly Details","title":"GradientRobustMultiPhysics.ON_FACES","text":"abstract type ON_FACES <: AbstractAssemblyType\n\ncauses assembly/interpolation on faces of the grid\n\n\n\n\n\n","category":"type"},{"location":"assembly_details/#GradientRobustMultiPhysics.ON_IFACES","page":"Assembly Details","title":"GradientRobustMultiPhysics.ON_IFACES","text":"abstract type ON_IFACES <: on faces\n\ncauses assembly/interpolation on interior faces of the grid\n\n\n\n\n\n","category":"type"},{"location":"assembly_details/#Assembly-Patterns","page":"Assembly Details","title":"Assembly Patterns","text":"","category":"section"},{"location":"assembly_details/","page":"Assembly Details","title":"Assembly Details","text":"Each Pattern comes with a number of arguments/quantities with associated Function Operators as well as one of the Assembly Types that states whether the form is evaluated over CELLS, FACES order BFACES (see above). Important note: this assembly type is relative to the grid of the first argument of the pattern. If this argument already lives ONFACES and the pattern is also ONFACES, it will ultimatively assemble on the faces of the faces (that are the edges of the grid with these faces). Moreover, patterns can have Abstract Actions that allow to make the evaluations parameter-, region- and/or function-dependent. Each pattern then has usually on to three implementation that writes into FEMatrix or FEVector (where e.g. a subset of arguments is fixed) or evaluates the pattern in the given FEVectorBlocks.","category":"page"},{"location":"assembly_details/","page":"Assembly Details","title":"Assembly Details","text":"The patterns are used to assembly the PDE operators defined in a PDE Description. However, it is also possible for the user to use them directly, see e.g. the example Commuting Interpolators (2D).","category":"page"},{"location":"assembly_details/","page":"Assembly Details","title":"Assembly Details","text":"GradientRobustMultiPhysics.AssemblyPattern{APT <: AssemblyPatternType, T <: Real, AT <: AbstractAssemblyType}","category":"page"},{"location":"assembly_details/#GradientRobustMultiPhysics.AssemblyPattern","page":"Assembly Details","title":"GradientRobustMultiPhysics.AssemblyPattern","text":"mutable struct AssemblyPattern{APT<:AssemblyPatternType, T<:Real, AT<:AbstractAssemblyType}\n\neach assembly pattern has one of the assembly pattern types (APT) that trigger different assemblies for the involved finite element spaces, operators and an assigned action. The assembly type (AT) determines if the assembly takes place on cells, faces or edges etc. (relatively to the assembly type of the first argument of the pattern)\n\n\n\n\n\n","category":"type"},{"location":"assembly_details/","page":"Assembly Details","title":"Assembly Details","text":"The following table lists all available assembly patterns, their constuctor names and how they can be used for assembly or evaluations.","category":"page"},{"location":"assembly_details/","page":"Assembly Details","title":"Assembly Details","text":"AssemblyPatternType constructor evaluate assembly into matrix assembly into vector\nAPT_ItemIntegrator ItemIntegrator yes no no\nAPT_LinearForm LinearForm no no yes\nAPT_BilinearForm BilinearForm no yes yes (1)\nAPT_TrilinearForm TrilinearForm no yes (1) yes (2)\nAPT_MultiLinearForm MultilinearForm no no yes (N-1)\nAPT_NonlinearForm NonlinearForm no yes (L) yes (L)","category":"page"},{"location":"assembly_details/","page":"Assembly Details","title":"Assembly Details","text":"Number in brackets denotes the number of fixed arguments needed for this assembly, (L) means that a current solution is needed to evaluate (to evaluate the linearisation of the nonlinear form in this state). Evaluations of the other AssemblyPatterns may be possible in a future update, but currently have to be performed by maintaining a duplicate of the pattern rewritten as an ItemIntegrator.","category":"page"},{"location":"assembly_details/#Constructor-details","page":"Assembly Details","title":"Constructor details","text":"","category":"section"},{"location":"assembly_details/","page":"Assembly Details","title":"Assembly Details","text":"Below all constructors are detailed.","category":"page"},{"location":"assembly_details/","page":"Assembly Details","title":"Assembly Details","text":"GradientRobustMultiPhysics.ItemIntegrator\nGradientRobustMultiPhysics.LinearForm\nGradientRobustMultiPhysics.BilinearForm\nGradientRobustMultiPhysics.TrilinearForm\nGradientRobustMultiPhysics.MultilinearForm\nGradientRobustMultiPhysics.NonlinearForm","category":"page"},{"location":"assembly_details/#GradientRobustMultiPhysics.ItemIntegrator","page":"Assembly Details","title":"GradientRobustMultiPhysics.ItemIntegrator","text":"function ItemIntegrator(\n    T::Type{<:Real},\n    AT::Type{<:AbstractAssemblyType},\n    operators::Array{DataType,1}, \n    action::AbstractAction; \n    regions::Array{Int,1} = [0])\n\nCreates an ItemIntegrator assembly pattern with the given operators and action etc.\n\n\n\n\n\n","category":"function"},{"location":"assembly_details/#GradientRobustMultiPhysics.LinearForm","page":"Assembly Details","title":"GradientRobustMultiPhysics.LinearForm","text":"function LinearForm(\n    T::Type{<:Real},\n    AT::Type{<:AbstractAssemblyType},\n    FE::Array{FESpace,1},\n    operators::Array{DataType,1}, \n    action::AbstractAction; \n    regions::Array{Int,1} = [0])\n\nCreates a LinearForm assembly pattern with the given FESpaces, operators and action etc.\n\n\n\n\n\n","category":"function"},{"location":"assembly_details/#GradientRobustMultiPhysics.BilinearForm","page":"Assembly Details","title":"GradientRobustMultiPhysics.BilinearForm","text":"function BilinearForm(\n    T::Type{<:Real},\n    AT::Type{<:AbstractAssemblyType},\n    FE::Array{FESpace,1},\n    operators::Array{DataType,1}, \n    action::AbstractAction; \n    regions::Array{Int,1} = [0])\n\nCreates a general BilinearForm assembly pattern with the given FESpaces, operators and action etc.\n\n\n\n\n\n","category":"function"},{"location":"assembly_details/#GradientRobustMultiPhysics.TrilinearForm","page":"Assembly Details","title":"GradientRobustMultiPhysics.TrilinearForm","text":"function TrilinearForm(\n    T::Type{<:Real},\n    FES::Array{FESpace,1},          \n    operators::Array{DataType,1},\n    action::AbstractAction;\n    regions::Array{Int,1} = [0])\n\nCreates a TrilinearForm assembly pattern with the given FESpaces, operators and action etc.\n\n\n\n\n\n","category":"function"},{"location":"assembly_details/#GradientRobustMultiPhysics.MultilinearForm","page":"Assembly Details","title":"GradientRobustMultiPhysics.MultilinearForm","text":"function MultilinearForm(\n    T::Type{<:Real},\n    AT::Type{<:AbstractAssemblyType},\n    FE::Array{FESpace,1},\n    operators::Array{DataType,1}, \n    action::AbstractAction; \n    regions::Array{Int,1} = [0])\n\nCreates a MultilinearForm assembly pattern with the given FESpaces, operators and action etc.\n\n\n\n\n\n","category":"function"},{"location":"assembly_details/#GradientRobustMultiPhysics.NonlinearForm","page":"Assembly Details","title":"GradientRobustMultiPhysics.NonlinearForm","text":"function NonlinearForm(\n    T::Type{<:Real},\n    FES::Array{FESpace,1},          # finite element spaces for each operator of the ansatz function and the last one refers to the test function\n    operators::Array{DataType,1},   # operators that should be evaluated for the ansatz function and the last one refers to the test function\n    action::AbstractAction;         # action that shoul have an AbstractNLActionKernel\n    regions::Array{Int,1} = [0])\n\nCreates a NonlinearForm assembly pattern.\n\n\n\n\n\n","category":"function"},{"location":"assembly_details/#Evaluate-and-Assemble","page":"Assembly Details","title":"Evaluate and Assemble","text":"","category":"section"},{"location":"assembly_details/","page":"Assembly Details","title":"Assembly Details","text":"Below all evaluate! and assemble! functions of the patterns are listed.","category":"page"},{"location":"assembly_details/","page":"Assembly Details","title":"Assembly Details","text":"evaluate!\nevaluate\nassemble!","category":"page"},{"location":"assembly_details/#GradientRobustMultiPhysics.evaluate!","page":"Assembly Details","title":"GradientRobustMultiPhysics.evaluate!","text":"function evaluate!(\n    b::AbstractArray{T,2},          # target vector\n    AP::AssemblyPattern{APT,T,AT},  # ItemIntegrator pattern\n    FEB::Array{<:FEVectorBlock,1}   # coefficients for arguments\n    where {APT <: APT_ItemIntegrator, T, AT}\n\nEvaluation of an ItemIntegrator assembly pattern with given FEVectorBlocks FEB into given two-dimensional Array b.\n\n\n\n\n\n","category":"function"},{"location":"assembly_details/#GradientRobustMultiPhysics.evaluate","page":"Assembly Details","title":"GradientRobustMultiPhysics.evaluate","text":"function evaluate(\n    AP::AssemblyPattern{APT,T,AT},  # ItemIntegrator pattern\n    FEB::Array{<:FEVectorBlock,1})  # coefficients for arguments\n    where {APT <: APT_ItemIntegrator, T, AT}\n\n\nEvaluation of an ItemIntegrator assembly pattern with given FEVectorBlocks FEB, only returns accumulation over all items.\n\n\n\n\n\n","category":"function"},{"location":"assembly_details/#GradientRobustMultiPhysics.assemble!","page":"Assembly Details","title":"GradientRobustMultiPhysics.assemble!","text":"assemble!(\n    b::Union{AbstractArray{T,1},AbstractArray{T,2}},    # target vector/matrix\n    AP::AssemblyPattern{APT,T,AT};                      # LinearForm pattern\n    factor = 1)                                         # factor that is multiplied\n    where {APT <: APT_LinearForm, T, AT}\n\nAssembly of a LinearForm pattern AP into a vector or matrix (if action is vetor-valued).\n\n\n\n\n\nassemble!(\n    A::AbstractArray{T,2},                  # target matrix\n    AP::AssemblyPattern{APT,T,AT};          # BilinearForm Pattern\n    apply_action_to::Int = 1,               # action is applied to which argument?\n    factor = 1,                             # factor that is multiplied\n    transposed_assembly::Bool = false,      # transpose result?\n    transpose_copy = Nothing)               # copy a transposed block to this matrix\n    where {APT <: APT_BilinearForm, T, AT}\n\nAssembly of a BilinearForm BLF into given two-dimensional AbstractArray (e.g. FEMatrixBlock or a ExtendableSparseMatrix).\n\n\n\n\n\nassemble!(\n    b::AbstractArray{T,1},          # target vector\n    AP::AssemblyPattern{APT,T,AT},  # BilinearForm Pattern\n    fixedFE::AbstractArray;         # coefficients for fixed argument\n    apply_action_to::Int = 1,       # action is applied to 1st or 2nd argument?\n    fixed_arguments = [1],        # which argument is fixed?\n    factor = 1)                     # factor that is multiplied\n    where {APT <: APT_BilinearForm, T, AT}\n\nAssembly of a BilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the second argument is fixed (default) by the given coefficients in fixedFE. With applyactionto=2 the action can be also applied to the second argument instead of the first one (default).\n\n\n\n\n\nassemble!(\n    assemble!(\n    A::AbstractArray{T,2},                  # target matrix\n    AP::AssemblyPattern{APT,T,AT},          # TrilinearForm pattern\n    fixedFE::Array{<:FEVectorBlock,1};      # coefficients for fixed argument\n    fixed_argument = [1],                   # position of fixed argument (as an array)\n    transposed_assembly::Bool = false,      # transpose result?\n    factor = 1)                             # factor that is multiplied\n    where {APT <: APT_TrilinearForm, T, AT}\n\nAssembly of a TrilinearForm AP into given two-dimensional AbstractArray (e.g. a FEMatrixBlock). Here, one argument (specified by fixed_argument) is fixed by the given coefficients in fixedFE[1]. Note, that the action is (currently) always applied to the first and second argument.\n\n\n\n\n\nassemble!(\n    assemble!(\n    b::AbstractVector,                      # target vector\n    AP::AssemblyPattern{APT,T,AT},          # coefficients for fixed arguments\n    fixedFE::Array{<:FEVectorBlock,1};      # TrilinearForm pattern\n    factor = 1)                             # factor that is multiplied\n    where {APT <: APT_TrilinearForm, T, AT}\n\nAssembly of a TrilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the first two arguments are fixed by the given coefficients in FE1 and FE2.\n\n\n\n\n\nassemble!(\n    b::AbstractVector,                        # target vector\n    FE::Array{<:FEVectorBlock,1},             # coefficients of all but last argument\n    AP::AssemblyPattern{APT,T,AT};            # Multilinearform pattern\n    factor = 1)                               # factor that is multiplied\n    where {APT <: APT_MultilinearForm, T, AT}\n\nAssembly of a MultilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the all but the last arguments are fixed by the given coefficients in the components of FE.\n\n\n\n\n\nassemble!(\n    A::AbstractArray{T,2},                 # target matrix\n    AP::AssemblyPattern{APT,T,AT};         # NonlinearForm pattern\n    FEB::Array{<:FEVectorBlock,1};         # coefficients of current solution for each operator\n    factor = 1,                            # factor that is multiplied\n    transposed_assembly::Bool = false)     # transpose result?\n    where {APT <: APT_NonlinearForm, T, AT}\n\nAssembly of a NonlinearForm assembly pattern into given two-dimensional AbstractArray (e.g. FEMatrixBlock).\n\n\n\n\n\nassemble!(\n    b::AbstractVector,                     # target vector\n    AP::AssemblyPattern{APT,T,AT},         # NonlinearForm pattern\n    FEB::Array{<:FEVectorBlock,1};         # coefficients of current solution for each operator\n    factor = 1)                            # factor that is multiplied\n    where {APT <: APT_NonlinearForm, T, AT}\n\nAssembly of a NonlinearForm AP into given AbstractVector (e.g. FEMatrixBlock).\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"(Image: Build status) (Image: ) (Image: ) (Image: DOI)","category":"page"},{"location":"#GradientRobustMultiPhysics.jl","page":"Home","title":"GradientRobustMultiPhysics.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package offers (mostly low-order) finite element methods for multiphysics problems in Julia that focus on the preservation of structural and qualitative properties, in particular the gradient-robustness property for the discretisation of (nearly) incompressible flows and resulting qualitative properties in coupled processes. The code therefore offers several classical and novel non-standard finite element discretisations to play and compare with in these applications and a toolkit to setup multi-physics problems by defining PDE systems and generating fixed-point iterations to solve them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The implementation is based on ExtendableGrids.jl that allows to have unstructured grids with mixed element geometries in it, e.g. triangles and quads in the same mesh.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also note, that this package is part of the meta-package PDELIB.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThe focus is (at least currently) not on high-performance, high-order or parallel-computing. Also, this package is still in an early development stage and features and interfaces might change in future updates.","category":"page"},{"location":"#What-is-gradient-robustness?","page":"Home","title":"What is gradient-robustness?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Gradient-robustness is a feature of discretisations that exactly balance gradient forces in the momentum balance. In the case of the incompressible Navier–Stokes equations this means that the discrete velocity does not depend on the exact pressure. Divergence-free finite element methods have this property but are usually expensive and difficult to contruct. However, also non-divergence-free classical finite element methods can be made pressure-robust with the help of reconstruction operators applied to testfuntions in certain terms of the momentum balance, see e.g. references [1,2] below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Recently gradient-robustness was also connected to the design of well-balanced schemes e.g. in the context of (nearly) compressible flows, see e.g. reference [3] below.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]   \"On the divergence constraint in mixed finite element methods for incompressible flows\",\n      V. John, A. Linke, C. Merdon, M. Neilan and L. Rebholz,\n      SIAM Review 59(3) (2017), 492–544,\n      >Journal-Link<,       >Preprint-Link<\n[2]   \"Pressure-robustness and discrete Helmholtz projectors in mixed finite element methods for the incompressible Navier–Stokes equations\",\n      A. Linke and C. Merdon,       Computer Methods in Applied Mechanics and Engineering 311 (2016), 304–326,\n      >Journal-Link<       >Preprint-Link<\n[3]   \"A gradient-robust well-balanced scheme for the compressible isothermal Stokes problem\",\n      M. Akbas, T. Gallouet, A. Gassmann, A. Linke and C. Merdon,\n      Computer Methods in Applied Mechanics and Engineering 367 (2020),\n      >Journal-Link<       >Preprint-Link<","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"via Julia package manager in Julia 1.5 or above:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# latest stable version\n(@v1.5) pkg> add GradientRobustMultiPhysics\n# latest version\n(@v1.5) pkg> add GradientRobustMultiPhysics#master","category":"page"},{"location":"#Dependencies-on-other-Julia-packages","page":"Home","title":"Dependencies on other Julia packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExtendableGrids.jl\nGridVisualize.jl\nExtendableSparse.jl\nDocStringExtensions.jl\nForwardDiff.jl\nDiffResults.jl\n","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The general work-flow is as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Describe your PDE system with the help of the PDE Description (possibly based on one of the PDE Prototypes). Additional parameters, right-hand side and boundary data can be assigned via User Data and Action Kernels.\nGenerate a mesh, possibly using one of the constructors by ExtendableGrid.jl or via mesh generators in SimplexGridFactory.jl.\nDefine finite element ansatz spaces (see Finite Element Spaces and Arrays for details) for the unknowns of your PDE system.\nSolve by using solve! or via a TimeControlSolver and advance! if the PDE system is time-dependent (see PDE Solvers for details).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please have a look at the Examples.","category":"page"},{"location":"examples/doc_2d_cookmembrane/#D-Linear-Elasticity","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"","category":"section"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"(source code)","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"This example computes the solution mathbfu of the linear elasticity problem","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"beginaligned\n-mathrmdiv (mathbbC epsilon(mathbfu))  = mathbff quad textin  Omega\nmathbbC epsilon(mathbfu) cdot mathbfn  = mathbfg quad textalong  Gamma_N\nendaligned","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"with exterior force mathbff, Neumann boundary force mathbfg, and the stiffness tensor","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"mathbbC epsilon(mathbfu) = 2 mu epsilon( mathbfu) + lambda mathrmtr(epsilon( mathbfu))","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"for isotropic media.","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"The domain will be the Cook membrane and the displacement has homogeneous boundary conditions on the left side of the domain and Neumann boundary conditions (i.e. a constant force that pulls the domain upwards) on the right side.","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"module Example_2DCookMembrane\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing Printf\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, Plotter = nothing)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # load mesh and refine\n    xgrid = simplexgrid(\"assets/2d_grid_cookmembrane.sg\")\n    xgrid = uniform_refine(xgrid,2)\n\n    # problem parameters\n    elasticity_modulus = 1000 # elasticity modulus\n    poisson_number = 1//3 # Poisson number\n    shear_modulus = (1/(1+poisson_number))*elasticity_modulus\n    lambda = (poisson_number/(1-2*poisson_number))*shear_modulus\n\n    # PDE description via prototype\n    Problem = LinearElasticityProblem(2; shear_modulus = shear_modulus, lambda = lambda)\n\n    # add boundary data\n    add_rhsdata!(Problem, 1, RhsOperator(Identity, [2], DataFunction([0,10]; name = \"g\"); AT = ON_BFACES))\n    add_boundarydata!(Problem, 1, [4], HomogeneousDirichletBoundary)\n\n    # show and solve PDE\n    @show Problem\n    FEType = H1P1{2} # P1-Courant FEM will be used\n    Solution = FEVector{Float64}(\"displacement\",FESpace{FEType}(xgrid))\n    solve!(Solution, Problem)\n\n    # plot stress on displaced mesh\n    displace_mesh!(xgrid, Solution[1]; magnify = 4)\n    GradientRobustMultiPhysics.plot(xgrid, [Solution[1], Solution[1]], [Identity, Gradient]; Plotter = Plotter)\nend\n\nend","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"Main.##261.Example_2DCookMembrane","category":"page"},{"location":"examples/doc_2d_cookmembrane/#Output-of-default-main()-run","page":"2D Linear Elasticity","title":"Output of default main() run","text":"","category":"section"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"Example_2DCookMembrane.main()","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"\nPDE-DESCRIPTION\n===============\n  system name = linear elasticity problem\n\n     id   | unknown name / equation name\n    [1]   | u / displacement equation \n\n  LHS block | PDEOperator(s)\n    [1,1]   | Cϵ(u):ϵ(v) (regions = [0])\n\n  RHS block | PDEOperator(s)\n     [1]    | g⋅id(v) (regions = [2])\n\n   BoundaryOperator[1] : HomogeneousDirichletBoundary -> [4]\n                          \n\nProblem = \n┌ Info: ----- Solving linear elasticity problem -----\n│ \tEquation (1.1) displacement equation : u >> displacement (H1P1{2}, ndofs = 3738)\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:1130\n┌ Info: overall residual = 2.3545608631000423e-11\n└ @ GradientRobustMultiPhysics /home/runner/work/GradientRobustMultiPhysics.jl/GradientRobustMultiPhysics.jl/src/solvers.jl:565\n","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"","category":"page"},{"location":"examples/doc_2d_cookmembrane/","page":"2D Linear Elasticity","title":"2D Linear Elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples_advanced/doc_2d_naturalconvection/#D-Natural-Convection","page":"2D Natural Convection","title":"2D Natural Convection","text":"","category":"section"},{"location":"examples_advanced/doc_2d_naturalconvection/","page":"2D Natural Convection","title":"2D Natural Convection","text":"(source code)","category":"page"},{"location":"examples_advanced/doc_2d_naturalconvection/","page":"2D Natural Convection","title":"2D Natural Convection","text":"This example solves the natural convection (or Boussinesque) problem on a triangular domain Omega = mathrmconvlbrace (00)(10)(01) rbrace. Altogether, we are looking for a velocity mathbfu, a pressure mathbfp and a stemperature T such that","category":"page"},{"location":"examples_advanced/doc_2d_naturalconvection/","page":"2D Natural Convection","title":"2D Natural Convection","text":"beginaligned\n- Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = Ra mathbfe_2 T\nmathrmdiv(u)  = 0\n- Delta mathbfT + mathbfu cdot nabla mathbfT  = 0\nendaligned","category":"page"},{"location":"examples_advanced/doc_2d_naturalconvection/","page":"2D Natural Convection","title":"2D Natural Convection","text":"with some parameter Ra. The velocity has zero Dirichlet boundary conditions, while the temperature is zero along the y-axis, trigonometric along the x-axis and do-nothing at the diagonal boundary of the triangular domain.","category":"page"},{"location":"examples_advanced/doc_2d_naturalconvection/","page":"2D Natural Convection","title":"2D Natural Convection","text":"Instead of using a Newton scheme, we solve a simpler fixpoint iteration plus Anderson acceleration. Also, note that a divergence-free reconstruction operator is used for the velocity, which also helps with the convergence and accuracy of the lowest-order method for this test problem.","category":"page"},{"location":"examples_advanced/doc_2d_naturalconvection/","page":"2D Natural Convection","title":"2D Natural Convection","text":"module Example_2DNaturalConvection\n\nusing GradientRobustMultiPhysics\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, Plotter = nothing, Ra = 1e6, viscosity = 1)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # load mesh and refine\n    xgrid = reference_domain(Triangle2D)\n    xgrid = uniform_refine(xgrid,5)\n\n    # types for discretisation by Bernardi--Raugel pressure-robust (BDM1 reconstruction) + P1-FEM for temperature\n    FETypes = [H1BR{2}, H1P0{1}, H1P1{1}];\n    postprocess_operator = ReconstructionIdentity{HDIVBDM1{2}}\n\n    # load Stokes prototype and add a unknown for the temperature\n    Problem = IncompressibleNavierStokesProblem(2; viscosity = viscosity, nonlinear = true, auto_newton = false)\n    add_unknown!(Problem; unknown_name = \"temperature\", equation_name = \"temperature equation\")\n    Problem.name = \"natural convection problem\"\n\n    # add boundary data for velocity (unknown 1) and temperature (unknown 3)\n    add_boundarydata!(Problem, 1, [1,2,3], HomogeneousDirichletBoundary)\n    function bnd_data_bottom!(result,x)\n        result[1] = 2*(1-cos(2*pi*x[1]))\n    end\n    add_boundarydata!(Problem, 3, [1], BestapproxDirichletBoundary; data = DataFunction(bnd_data_bottom!, [1,2]; dependencies = \"X\", quadorder = 4))\n    add_boundarydata!(Problem, 3, [3], HomogeneousDirichletBoundary)\n\n    # add Laplacian to temperature equation\n    add_operator!(Problem,[3,3], LaplaceOperator(1.0; store = true))\n\n    # add coupling terms for velocity and temperature\n    add_operator!(Problem,[3,3], ConvectionOperator(1, postprocess_operator, 2, 1; auto_newton = false))\n    function gravity_kernel(result,input)\n        result[1] = -Ra*input[2]\n    end\n    add_operator!(Problem,[1,3], AbstractBilinearForm([postprocess_operator, Identity], Action(Float64, gravity_kernel, [1,2]; dependencies = \"\")))\n\n    # show final problem description\n    @show Problem\n\n    # construct FESpaces and Solution veector\n    FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid), FESpace{FETypes[3]}(xgrid)]\n    Solution = FEVector{Float64}([\"v_h\", \"p_h\", \"T_h\"],FES)\n\n    # solve (fixedpoint iteration by solving consecutively equations [3] and [1,2] + Anderson acceleration)\n    solve!(Solution, Problem; subiterations = [[3],[1,2]], maxiterations = 100, target_residual = 1e-8, anderson_iterations = 5, anderson_metric = \"l2\", anderson_unknowns = [1,3], anderson_damping = 0.95, show_solver_config = true)\n\n    # plot\n    GradientRobustMultiPhysics.plot(xgrid, [Solution[1], Solution[3]], [Identity, Identity]; Plotter = Plotter)\nend\n\nend","category":"page"},{"location":"examples_advanced/doc_2d_naturalconvection/","page":"2D Natural Convection","title":"2D Natural Convection","text":"","category":"page"},{"location":"examples_advanced/doc_2d_naturalconvection/","page":"2D Natural Convection","title":"2D Natural Convection","text":"This page was generated using Literate.jl.","category":"page"}]
}
