var documenterSearchIndex = {"docs":
[{"location":"examples/ExampleA01_RationalMassMatrix/#A01-:-Rational-Mass-Matrix","page":"A01 : Rational Mass Matrix","title":"A01 : Rational Mass Matrix","text":"","category":"section"},{"location":"examples/ExampleA01_RationalMassMatrix/","page":"A01 : Rational Mass Matrix","title":"A01 : Rational Mass Matrix","text":"(source code)","category":"page"},{"location":"examples/ExampleA01_RationalMassMatrix/","page":"A01 : Rational Mass Matrix","title":"A01 : Rational Mass Matrix","text":"This example demonstrates the usage of rational numbers to calculate e.g. exact mass matrices on reference domains (if exact quadrature rules in Rational number format are available).","category":"page"},{"location":"examples/ExampleA01_RationalMassMatrix/","page":"A01 : Rational Mass Matrix","title":"A01 : Rational Mass Matrix","text":"module ExampleA01_RationalMassMatrix\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\n\n# everything is wrapped in a main function\nfunction main()\n\n    # reference domain as extendable grid\n    xgrid = reference_domain(Triangle2D, Rational{Int64})\n\n    # define P1-Courant finite element space\n    FES = FESpace{H1P1{1}}(xgrid)\n\n    # define mass matrix bilinear form\n    MAMA_BLF = SymmetricBilinearForm(Rational{Int64},ON_CELLS,[FES,FES],[Identity,Identity])\n\n    # assemble mass matrix and divide by area\n    MAMA = FEMatrix{Rational{Int64}}(\"mass matrix\",FES)\n    assemble!(MAMA[1],MAMA_BLF)\n    MAMA = MAMA.entries ./ xgrid[CellVolumes][1]\n\n    # print matrix\n    @show MAMA\nend\n\nend","category":"page"},{"location":"examples/ExampleA01_RationalMassMatrix/","page":"A01 : Rational Mass Matrix","title":"A01 : Rational Mass Matrix","text":"","category":"page"},{"location":"examples/ExampleA01_RationalMassMatrix/","page":"A01 : Rational Mass Matrix","title":"A01 : Rational Mass Matrix","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/ExampleA01_RationalMassMatrix/","page":"A01 : Rational Mass Matrix","title":"A01 : Rational Mass Matrix","text":"Default output:","category":"page"},{"location":"examples/ExampleA01_RationalMassMatrix/","page":"A01 : Rational Mass Matrix","title":"A01 : Rational Mass Matrix","text":"julia> ExampleA01_RationalMassMatrix.main()\nMAMA = Rational{Int64}[1//6 1//12 1//12; 1//12 1//6 1//12; 1//12 1//12 1//6]","category":"page"},{"location":"pointevaluators/#Point-Evaluators","page":"Point Evaluators","title":"Point Evaluators","text":"","category":"section"},{"location":"pointevaluators/","page":"Point Evaluators","title":"Point Evaluators","text":"Point evaluators allow to evaluate the Solution at arbitrary points.","category":"page"},{"location":"pointevaluators/","page":"Point Evaluators","title":"Point Evaluators","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"pointevaluator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"pointevaluators/#GradientRobustMultiPhysics.PointEvaluator","page":"Point Evaluators","title":"GradientRobustMultiPhysics.PointEvaluator","text":"struct PointEvaluator{T<:Real, Tv<:Real, Ti<:Integer, FEType<:AbstractFiniteElement, FEOP<:??, AT<:AssemblyType, ACT<:AbstractAction}\n\nstructure that allows to evaluate a FEVectorBlock at arbitrary points\n\n\n\n\n\n","category":"type"},{"location":"pointevaluators/#GradientRobustMultiPhysics.PointEvaluator-Union{Tuple{Ti}, Tuple{Tv}, Tuple{T}, Tuple{FEVectorBlock{T, Tv, Ti}, Any}, Tuple{FEVectorBlock{T, Tv, Ti}, Any, AbstractAction}} where {T, Tv, Ti}","page":"Point Evaluators","title":"GradientRobustMultiPhysics.PointEvaluator","text":"function PointEvaluator(FEB::FEVectorBlock, FEOP::AbstractFunctionOperator, action::AbstractAction = NoAction(); AT = ON_CELLS)\n\nconstructor for PointEvaluator that evaluate the given FEVectorBlock with the specified operator (possibly postprocessed by an action) at arbitrary points inside entities of the given assembly type\n\n\n\n\n\n","category":"method"},{"location":"pointevaluators/#GradientRobustMultiPhysics.evaluate!-Union{Tuple{ACT}, Tuple{AT}, Tuple{FEOP}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}, Tuple{T}, Tuple{Any, PointEvaluator{T, Tv, Ti, FEType, FEOP, AT, ACT}, Any, Any}} where {T, Tv, Ti, FEType, FEOP, AT, ACT}","page":"Point Evaluators","title":"GradientRobustMultiPhysics.evaluate!","text":"function evaluate!(\n    result,                     # target for result\n    PE::PointEvaluator,         \n    xref,                       # local coordinates inside item\n    item                        # item number\n    ) where  {T, Tv, Ti, FEType, FEOP, AT, ACT}\n\nEvaluates the PointEvaluator at the point with the given local coordinates insides the item with the specified item number. (To get the local coordinates, currently a CellFinder has to be maintained manually, this might change in future.)\n\n\n\n\n\n","category":"method"},{"location":"pointevaluators/#GradientRobustMultiPhysics.evaluate-Tuple{PointEvaluator}","page":"Point Evaluators","title":"GradientRobustMultiPhysics.evaluate","text":"function evaluate(PE::PointEvaluator)\n\nReturns the function     (result,xref,cell) –> evaluate!(result,PE,xref,cell)\n\n(e.g. to be used as a callback function in vectorplot!)\n\n\n\n\n\n","category":"method"},{"location":"pointevaluators/#Noteworthy-Examples","page":"Point Evaluators","title":"Noteworthy Examples","text":"","category":"section"},{"location":"pointevaluators/","page":"Point Evaluators","title":"Point Evaluators","text":"Example 224 uses PointEvaluator to evaluate the pressure difference in a flow around an obstacle and to offer a callback function for a quiver plot.","category":"page"},{"location":"examples/Example231_StokesHdivP1RT/#:-Stokes-(P1-\\oplus-RT0)-\\times-P0","page":"231 : Stokes (P1 oplus RT0) times P0","title":"231 : Stokes (P1 oplus RT0) times P0","text":"","category":"section"},{"location":"examples/Example231_StokesHdivP1RT/","page":"231 : Stokes (P1 oplus RT0) times P0","title":"231 : Stokes (P1 oplus RT0) times P0","text":"(source code)","category":"page"},{"location":"examples/Example231_StokesHdivP1RT/","page":"231 : Stokes (P1 oplus RT0) times P0","title":"231 : Stokes (P1 oplus RT0) times P0","text":"This example computes the velocity mathbfu and pressure mathbfp of the incompressible Navier–Stokes problem","category":"page"},{"location":"examples/Example231_StokesHdivP1RT/","page":"231 : Stokes (P1 oplus RT0) times P0","title":"231 : Stokes (P1 oplus RT0) times P0","text":"beginaligned\n- mu Delta mathbfu + nabla p  = mathbff\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"examples/Example231_StokesHdivP1RT/","page":"231 : Stokes (P1 oplus RT0) times P0","title":"231 : Stokes (P1 oplus RT0) times P0","text":"with exterior force mathbff and some parameter mu and inhomogeneous Dirichlet boundary data.","category":"page"},{"location":"examples/Example231_StokesHdivP1RT/","page":"231 : Stokes (P1 oplus RT0) times P0","title":"231 : Stokes (P1 oplus RT0) times P0","text":"The problem will be solved by a (P1 oplus RT0) times P0 scheme suggested by Li/Rui,arXiv:2012.01689 [math.NA]. The velocity space employs continuous P1 functions plus additional (only H(div)-conforming) RT0 functions and a P0 pressure space leading to an exactly divergence-free discrete velocity.","category":"page"},{"location":"examples/Example231_StokesHdivP1RT/","page":"231 : Stokes (P1 oplus RT0) times P0","title":"231 : Stokes (P1 oplus RT0) times P0","text":"module Example231_StokesHdivP1RT\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# flow data for boundary condition, right-hand side and error calculation\nfunction get_flowdata(μ)\n    p! = (result,x,t) -> (result[1] = cos(t)*(sin(x[1])*cos(x[2]) + (cos(1) -1)*sin(1)))\n    u! = (result,x,t) -> (\n        result[1] = cos(t)*(sin(π*x[1]-0.7)*sin(π*x[2]+0.2));\n        result[2] = cos(t)*(cos(π*x[1]-0.7)*cos(π*x[2]+0.2)))\n    ∇u! = (result,x,t) -> (\n        result[1] = π*cos(t)*(cos(π*x[1]-0.7)*sin(π*x[2]+0.2));\n        result[2] = π*cos(t)*(sin(π*x[1]-0.7)*cos(π*x[2]+0.2));\n        result[3] = -result[2];\n        result[4] = -result[1])\n    f! = (result,x,t) -> (## f= -μΔu + ∇p\n        result[1] = 2*π*π*μ*cos(t)*(sin(π*x[1]-0.7)*sin(π*x[2]+0.2)) + cos(t)*cos(x[1])*cos(x[2]);\n        result[2] = 2*π*π*μ*cos(t)*(cos(π*x[1]-0.7)*cos(π*x[2]+0.2)) - cos(t)*sin(x[1])*sin(x[2]);)\n    u = DataFunction(u!, [2,2]; dependencies = \"XT\", name = \"u\", quadorder = 5)\n    p = DataFunction(p!, [1,2]; dependencies = \"XT\", name = \"p\", quadorder = 4)\n    ∇u = DataFunction(∇u!, [4,2]; dependencies = \"XT\", name = \"∇u\", quadorder = 4)\n    f = DataFunction(f!, [2,2]; dependencies = \"XT\", name = \"f\", quadorder = 5)\n    return u, p, ∇u, f\nend\n\n# everything is wrapped in a main function\nfunction main(; μ = 1e-3, nlevels = 5, Plotter = nothing, verbosity = 0, T = 1, α = 2.0)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # FEType\n    FETypes = [H1P1{2}, HDIVRT0{2}, H1P0{1}]\n\n    # initial grid\n    xgrid = grid_unitsquare(Triangle2D)\n\n    # get exact flow data (see above)\n    u,p,∇u,f = get_flowdata(μ)\n\n    # define problem\n    Problem = PDEDescription(\"Stokes problem\")\n    add_unknown!(Problem; equation_name = \"momentum equation (P1 part)\", unknown_name = \"u_P1\")\n    add_unknown!(Problem; equation_name = \"momentum equation (RT0 part)\", unknown_name = \"u_RT\")\n    add_unknown!(Problem; equation_name = \"incompressibility constraint\", unknown_name = \"p\")\n\n    # add Laplacian for both velocity blocks\n    add_operator!(Problem, [1,1], LaplaceOperator(μ))\n\n    # add stabilising term for RT0 block (lumped diagonal div-div matrix)\n    add_operator!(Problem, [2,2], BilinearForm([Divergence, Divergence]; name = \"α (div u_RT,div v_RT) [lumped]\", factor = α, APT = APT_LumpedBilinearForm))\n\n    # add Lagrange multiplier for divergence of velocity\n    add_operator!(Problem, [1,3], LagrangeMultiplier(Divergence))\n    add_operator!(Problem, [2,3], LagrangeMultiplier(Divergence))\n    add_constraint!(Problem, FixedIntegralMean(3,0))\n\n    # add boundary data and right-hand side\n    add_boundarydata!(Problem, 1, [1,2,3,4], BestapproxDirichletBoundary; data = u)\n    add_boundarydata!(Problem, 2, [1,2,3,4], HomogeneousDirichletBoundary)\n    add_rhsdata!(Problem, 1, RhsOperator(Identity, [1], f))\n    add_rhsdata!(Problem, 2, RhsOperator(Identity, [1], f))\n\n    # show final problem description\n    @show Problem\n\n    # prepare error calculation\n    L2VelocityError = L2ErrorIntegrator(Float64, u, [Identity, Identity]; time = T)\n    L2PressureError = L2ErrorIntegrator(Float64, p, Identity; time = T)\n    H1VelocityError = L2ErrorIntegrator(Float64, ∇u, Gradient; time = T)\n    L2VeloDivEvaluator = L2NormIntegrator(Float64,1 , [Divergence, Divergence])\n    Results = zeros(Float64,nlevels,4); NDofs = zeros(Int,nlevels)\n\n    # loop over levels\n    Solution = nothing\n    for level = 1 : nlevels\n        # refine grid and update grid component references\n        xgrid = uniform_refine(xgrid)\n\n        # generate FES spaces and solution vector\n        FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid), FESpace{FETypes[3]}(xgrid)]\n        Solution = FEVector([\"u_P1\", \"u_RT\", \"p_h\"],FES)\n\n        # solve\n        solve!(Solution, Problem; time = T)\n\n        # compute L2 and H1 errors and save data\n        NDofs[level] = length(Solution.entries)\n        Results[level,1] = sqrt(evaluate(L2VelocityError,[Solution[1],Solution[2]]))\n        Results[level,2] = sqrt(evaluate(L2PressureError,Solution[3]))\n        Results[level,3] = sqrt(evaluate(H1VelocityError,Solution[1]))\n        Results[level,4] = sqrt(evaluate(L2VeloDivEvaluator,[Solution[1], Solution[2]]))\n    end\n\n    # plot\n    p = GridVisualizer(; Plotter = Plotter, layout = (1,3), clear = true, resolution = (1200,400))\n    scalarplot!(p[1,1],xgrid,view(nodevalues(Solution[1]; abs = true),1,:), levels = 3)\n    vectorplot!(p[1,1],xgrid,evaluate(PointEvaluator(Solution[1], Identity)), spacing = 0.05, clear = false, title = \"u_P1 (abs + quiver)\")\n    scalarplot!(p[1,2],xgrid,view(nodevalues(Solution[2]; abs = true),1,:), levels = 3)\n    vectorplot!(p[1,2],xgrid,evaluate(PointEvaluator(Solution[2], Identity)), spacing = 0.05, clear = false, title = \"u_RT (abs + quiver)\")\n    scalarplot!(p[1,3],xgrid,view(nodevalues(Solution[3]),1,:), levels = 11, title = \"p_h\")\n\n    # print/show convergence history\n    print_convergencehistory(NDofs, Results; X_to_h = X -> X.^(-1/2), ylabels = [\"|| u - u_h ||\", \"|| p - p_h ||\", \"|| ∇(u - u_P1) ||\", \"|| div(u_h) ||\"])\n    plot_convergencehistory(NDofs, Results[:,1:3]; add_h_powers = [1,2], X_to_h = X -> X.^(-1/2), Plotter = Plotter, ylabels = [\"|| u - u_h ||\", \"|| p - p_h ||\", \"|| ∇(u - u_h) ||\"])\nend\nend","category":"page"},{"location":"examples/Example231_StokesHdivP1RT/","page":"231 : Stokes (P1 oplus RT0) times P0","title":"231 : Stokes (P1 oplus RT0) times P0","text":"","category":"page"},{"location":"examples/Example231_StokesHdivP1RT/","page":"231 : Stokes (P1 oplus RT0) times P0","title":"231 : Stokes (P1 oplus RT0) times P0","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example231_StokesHdivP1RT/","page":"231 : Stokes (P1 oplus RT0) times P0","title":"231 : Stokes (P1 oplus RT0) times P0","text":"Default output:","category":"page"},{"location":"examples/Example231_StokesHdivP1RT/","page":"231 : Stokes (P1 oplus RT0) times P0","title":"231 : Stokes (P1 oplus RT0) times P0","text":"julia> Example231_StokesHdivP1RT.main()\n\nPDE-DESCRIPTION\n===============\n  system name = Stokes problem\n\n     id   | unknown name / equation name\n    [1]   | u_P1 / momentum equation (P1 part) \n    [2]   | u_RT / momentum equation (RT0 part) \n    [3]   | p / incompressibility constraint \n\n  LHS block | PDEOperator(s)\n    [1,1]   | 0.001 (∇u,∇v) (APT = SymmetricBilinearForm, AT = ON_CELLS, regions = [0])\n    [1,2]   | none\n    [1,3]   | (div(v),q) (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n    [2,1]   | none\n    [2,2]   | α (div u_RT,div v_RT) [lumped] (APT = LumpedBilinearForm, AT = ON_CELLS, regions = [0])\n    [2,3]   | (div(v),q) (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n    [3,1]   | none\n    [3,2]   | none\n    [3,3]   | none\n\n  RHS block | PDEOperator(s)\n     [1]    | (f, id(v)) (APT = LinearForm, AT = ON_CELLS, regions = [1])\n     [2]    | (f, id(v)) (APT = LinearForm, AT = ON_CELLS, regions = [1])\n     [3]    | none\n\n   BoundaryOperator[1] : BestapproxDirichletBoundary -> [1, 2, 3, 4]\n                         \n   BoundaryOperator[2] : HomogeneousDirichletBoundary -> [1, 2, 3, 4]\n                          \n   BoundaryOperator[3] : \n\n  GlobalConstraints[1] : Mean[3] != 0 \nProblem = \n\n    ndofs   |    || u - u_h ||     order  |    || p - p_h ||     order  |  || ∇(u - u_P1) ||   order  |   || div(u_h) ||     order  |\n============|=============================|=============================|=============================|=============================|\n        70  |     4.52039e-02      0.000  |     3.48542e-02      0.000  |     7.89870e-01      0.000  |     1.72358e-16      0.000  |\n       250  |     9.42941e-03      2.463  |     1.74735e-02      1.085  |     3.90158e-01      1.108  |     3.24017e-16      -0.992  |\n       946  |     2.23973e-03      2.160  |     8.74218e-03      1.041  |     1.93064e-01      1.057  |     1.04675e-15      -1.762  |\n      3682  |     5.61233e-04      2.037  |     4.37163e-03      1.020  |     9.62761e-02      1.024  |     1.65690e-15      -0.676  |\n     14530  |     1.45636e-04      1.965  |     2.18585e-03      1.010  |     4.81117e-02      1.011  |     1.87925e-15      -0.183  |","category":"page"},{"location":"examples/Example231_StokesHdivP1RT/","page":"231 : Stokes (P1 oplus RT0) times P0","title":"231 : Stokes (P1 oplus RT0) times P0","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/Example223_NaturalConvection2D/#:-Natural-Convection-2D","page":"223 : Natural Convection 2D","title":"223 : Natural Convection 2D","text":"","category":"section"},{"location":"examples/Example223_NaturalConvection2D/","page":"223 : Natural Convection 2D","title":"223 : Natural Convection 2D","text":"(source code)","category":"page"},{"location":"examples/Example223_NaturalConvection2D/","page":"223 : Natural Convection 2D","title":"223 : Natural Convection 2D","text":"This example solves the natural convection (or Boussinesque) problem on a triangular domain Omega = mathrmconvlbrace (00)(10)(01) rbrace. Altogether, we are looking for a velocity mathbfu, a pressure mathbfp and a stemperature T such that","category":"page"},{"location":"examples/Example223_NaturalConvection2D/","page":"223 : Natural Convection 2D","title":"223 : Natural Convection 2D","text":"beginaligned\n- Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = Ra mathbfe_2 T\nmathrmdiv(u)  = 0\n- Delta mathbfT + mathbfu cdot nabla mathbfT  = 0\nendaligned","category":"page"},{"location":"examples/Example223_NaturalConvection2D/","page":"223 : Natural Convection 2D","title":"223 : Natural Convection 2D","text":"with some parameter Ra. The velocity has zero Dirichlet boundary conditions, while the temperature is zero along the y-axis, trigonometric along the x-axis and do-nothing at the diagonal boundary of the triangular domain.","category":"page"},{"location":"examples/Example223_NaturalConvection2D/","page":"223 : Natural Convection 2D","title":"223 : Natural Convection 2D","text":"Two possible solution strategies are implemented here. The first is Newton's method. For this both nonlinear operators are assigned as auto-differentiated operators. Note, that the nonlinearity in the tmeperature equation involves both unknowns u and T and hence leads to two assigned matrix blocks in the equation for T. However, a direct Newton solve only works smooth for small or moderate Ra (circa up to 1e5).","category":"page"},{"location":"examples/Example223_NaturalConvection2D/","page":"223 : Natural Convection 2D","title":"223 : Natural Convection 2D","text":"Therefore, for larger Ra, Anderson acceleration can be used which is triggered by setting anderson = true","category":"page"},{"location":"examples/Example223_NaturalConvection2D/","page":"223 : Natural Convection 2D","title":"223 : Natural Convection 2D","text":"Also, note that a divergence-free reconstruction operator is used for the velocity, which also helps with the convergence and accuracy of the lowest-order method for this test problem.","category":"page"},{"location":"examples/Example223_NaturalConvection2D/","page":"223 : Natural Convection 2D","title":"223 : Natural Convection 2D","text":"module Example223_NaturalConvection2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# boundary data for temperature on bottom\nT_bottom = DataFunction((T,x) -> (T[1] = 2*(1-cos(2*pi*x[1]))), [1,2]; dependencies = \"X\", quadorder = 4)\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, Plotter = nothing, Ra = 1e5, μ = 1, nrefinements = 6, anderson = false)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # load mesh and refine\n    xgrid = reference_domain(Triangle2D)\n    xgrid = uniform_refine(xgrid, nrefinements)\n\n    # types for discretisation by Bernardi--Raugel pressure-robust (BDM1 reconstruction) + P1-FEM for temperature\n    FETypes = [H1BR{2}, H1P0{1}, H1P1{1}];\n    RIdentity = ReconstructionIdentity{HDIVBDM1{2}}\n\n    # load Stokes prototype and add a unknown for the temperature\n    Problem = IncompressibleNavierStokesProblem(2; viscosity = μ, nonlinear = false, store = true)\n    add_unknown!(Problem; unknown_name = \"T\", equation_name = \"temperature equation\")\n    Problem.name = \"natural convection problem\"\n\n    # add convection term for velocity\n    add_operator!(Problem, [1,1], ConvectionOperator(1, RIdentity, 2, 2; testfunction_operator = RIdentity, auto_newton = !anderson))\n\n    # add boundary data for velocity (unknown 1) and temperature (unknown 3)\n    add_boundarydata!(Problem, 1, [1,2,3], HomogeneousDirichletBoundary)\n    add_boundarydata!(Problem, 3, [1], BestapproxDirichletBoundary; data = T_bottom)\n    add_boundarydata!(Problem, 3, [3], HomogeneousDirichletBoundary)\n\n    # add Laplacian to temperature equation\n    add_operator!(Problem,[3,3], LaplaceOperator(1.0; store = true, name = \"∇(T)⋅∇(V)\"))\n\n    # add coupling terms for velocity and temperature (convection + gravity)\n    if anderson\n        add_operator!(Problem,[3,3], ConvectionOperator(1, RIdentity, 2, 1; name = \"(R(u)⋅∇(T)) V\"))\n    else #if newton\n        function Tconvection_kernel(result,input)\n            # input = [id(u),∇T]\n            result[1] = input[1]*input[3] + input[2]*input[4]\n            return nothing\n        end\n        add_operator!(Problem,3, NonlinearForm([RIdentity,Gradient], [1,3], Identity, Tconvection_kernel, [1,4]; name = \"(R(u)⋅∇(T)) V\", ADnewton = true, quadorder = 0)  )\n    end\n    add_operator!(Problem,[1,3], BilinearForm([RIdentity, Identity], fdot_action(Float64,DataFunction([0,-1.0])); factor = Ra, name = \"-Ra v⋅g T\", store = true))\n\n    # show final problem description\n    @show Problem\n\n    # construct FESpaces and Solution veector\n    FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid), FESpace{FETypes[3]}(xgrid)]\n    Solution = FEVector([\"v_h\", \"p_h\", \"T_h\"],FES)\n\n    # solve (fixedpoint iteration by solving consecutively equations [3] and [1,2] + Anderson acceleration)\n    if anderson\n        solve!(Solution, Problem; subiterations = [[3],[1,2]], maxiterations = 100, target_residual = 1e-8, anderson_iterations = 5, anderson_metric = \"l2\", anderson_unknowns = [1,3], anderson_damping = 0.95, show_solver_config = true, show_statistics = true)\n    else\n        solve!(Solution, Problem; maxiterations = 100, target_residual = 1e2, damping = 0.55, show_solver_config = true, show_statistics = true)\n        solve!(Solution, Problem; maxiterations = 100, target_residual = 1e-8, damping = 0, show_solver_config = false, show_statistics = true)\n    end\n\n    # compute Nusselt number along bottom boundary\n    NuIntegrator = ItemIntegrator(Float64,ON_BFACES,[Jump(Gradient)], fdot_action(Float64,DataFunction([0,-1.0])); regions = [1])\n    println(\"\\tNu = $(evaluate(NuIntegrator,Solution[3]))\")\n\n    # plot\n    p = GridVisualizer(; Plotter = Plotter, layout = (1,2), clear = true, resolution = (1000,500))\n    scalarplot!(p[1,1],xgrid,view(nodevalues(Solution[1]; abs = true),1,:), levels = 0)\n    vectorplot!(p[1,1],xgrid,evaluate(PointEvaluator(Solution[1], Identity)), spacing = 0.1, clear = false, title = \"u_h (abs + quiver)\")\n    scalarplot!(p[1,2],xgrid,view(nodevalues(Solution[3]),1,:), levels = 11, title = \"T_h\")\nend\n\nend","category":"page"},{"location":"examples/Example223_NaturalConvection2D/","page":"223 : Natural Convection 2D","title":"223 : Natural Convection 2D","text":"","category":"page"},{"location":"examples/Example223_NaturalConvection2D/","page":"223 : Natural Convection 2D","title":"223 : Natural Convection 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example223_NaturalConvection2D/","page":"223 : Natural Convection 2D","title":"223 : Natural Convection 2D","text":"Default output:","category":"page"},{"location":"examples/Example223_NaturalConvection2D/","page":"223 : Natural Convection 2D","title":"223 : Natural Convection 2D","text":"julia> Example223_NaturalConvection2D.main()\n\nPDE-DESCRIPTION\n===============\n  system name = natural convection problem\n\n     id   | unknown name / equation name\n    [1]   | u / momentum equation \n    [2]   | p / incompressibility constraint \n    [3]   | T / temperature equation \n\n  LHS block | PDEOperator(s)\n    [1,1]   | (∇u,∇v) (APT = SymmetricBilinearForm, AT = ON_CELLS, regions = [0])\n            | ((R(u) ⋅ ∇) u, R(v)) [AD-Newton] [∂u] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n    [1,2]   | (div(v),q) (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n    [1,3]   | -Ra v⋅g T (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n    [2,1]   | none\n    [2,2]   | none\n    [2,3]   | none\n    [3,1]   | (R(u)⋅∇(T)) V [AD-Newton] [∂u] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n    [3,2]   | none\n    [3,3]   | ∇(T)⋅∇(V) (APT = SymmetricBilinearForm, AT = ON_CELLS, regions = [0])\n            | (R(u)⋅∇(T)) V [AD-Newton] [∂T] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n\n  RHS block | PDEOperator(s)\n     [1]    | ((R(u) ⋅ ∇) u, R(v)) [AD-Newton] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n     [2]    | none\n     [3]    | (R(u)⋅∇(T)) V [AD-Newton] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n\n   BoundaryOperator[1] : HomogeneousDirichletBoundary -> [1, 2, 3]\n                          \n   BoundaryOperator[2] : \n   BoundaryOperator[3] : BestapproxDirichletBoundary -> [1]\n                         HomogeneousDirichletBoundary -> [3]\n                          \n\n  GlobalConstraints[1] : Mean[2] != 0 \nProblem = \nSC = \nSOLVER-CONFIGURATION\n======================\n  overall nonlinear = true\n  overall timedependent = false\n  anderson_iterations = 0\n  subiterations = UnitRange{Int64}[1:3]\n  show_iteration_details = true\n  timedependent_equations = Any[]\n  anderson_unknowns = [1]\n  show_statistics = true\n  anderson_metric = l2\n  skip_update = [1]\n  linsolver = GradientRobustMultiPhysics.LinearSystem{Float64, Int64, LUFactorization{Float64, Int64}}\n  damping = 0.55\n  time = 0\n  show_solver_config = true\n  anderson_damping = 1\n  check_nonlinear_residual = true\n  fixed_penalty = 1.0e60\n  target_residual = 100.0\n  maxiterations = 100\n  AssemblyTriggers = \n         LHS_AT[1] :  A  I  I \n         LHS_AT[2] :  N  N  N \n         LHS_AT[3] :  A  N  A \n         RHS_AT[1] :  A \n         RHS_AT[2] :  N \n         RHS_AT[3] :  A \n                     (I = Once, T = EachTimeStep/SubIteration, A = Always, N = Never)\n\n  LHS_dependencies = [[1] [1, 2] [1, 3]; [2, 1] [2] [2, 3]; [3, 1] [3, 2] [3, 1]]\n\n\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL  | TIME ASSEMBLY/SOLVE/TOTAL (s)\n\t-----------------------------------------------------------------------\n\t      1   | 7.337426e-12 | 9.615916e+02 | 1.87e+00/2.67e-01/2.21e+00\n\t      2   | 1.013452e-11 | 5.931504e+02 | 6.84e-01/2.35e-01/9.22e-01\n\t      3   | 7.977056e-12 | 6.568060e+02 | 6.94e-01/1.98e-01/8.95e-01\n\t      4   | 9.304290e-12 | 3.990824e+02 | 6.92e-01/2.15e-01/9.10e-01\n\t      5   | 8.529943e-12 | 2.340174e+02 | 6.90e-01/1.97e-01/8.90e-01\n\t      6   | 8.377752e-12 | 1.387982e+02 | 6.88e-01/2.43e-01/9.34e-01\n\t      7   | 8.389930e-12 | 8.267079e+01 | 6.97e-01/1.95e-01/8.95e-01\n\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL  | TIME ASSEMBLY/SOLVE/TOTAL (s)\n\t-----------------------------------------------------------------------\n\t      1   | 6.934140e-12 | 2.205491e+01 | 6.98e-01/2.66e-01/9.66e-01\n\t      2   | 6.630677e-12 | 1.839015e+00 | 6.80e-01/2.53e-01/9.36e-01\n\t      3   | 6.958546e-12 | 9.514267e-03 | 6.86e-01/2.62e-01/9.50e-01\n\t      4   | 6.846058e-12 | 3.288516e-07 | 6.94e-01/2.39e-01/9.35e-01\n\t      5   | 6.905736e-12 | 7.428078e-12 | 7.17e-01/2.82e-01/1.00e+00\n\n\tNu = 13.9780237166483","category":"page"},{"location":"examples/Example223_NaturalConvection2D/","page":"223 : Natural Convection 2D","title":"223 : Natural Convection 2D","text":"(Image: )","category":"page"},{"location":"examples/ExampleA06_LocalEquilibratedFluxes2D/#A06-:-Local-Equilibrated-Fluxes-2D","page":"A06 : Local Equilibrated Fluxes 2D","title":"A06 : Local Equilibrated Fluxes 2D","text":"","category":"section"},{"location":"examples/ExampleA06_LocalEquilibratedFluxes2D/","page":"A06 : Local Equilibrated Fluxes 2D","title":"A06 : Local Equilibrated Fluxes 2D","text":"(source code)","category":"page"},{"location":"examples/ExampleA06_LocalEquilibratedFluxes2D/","page":"A06 : Local Equilibrated Fluxes 2D","title":"A06 : Local Equilibrated Fluxes 2D","text":"This example computes a local equilibration error estimator for the H^1 error of some H^1-conforming approximation u_h to the solution u of some Poisson problem -Delta u = f on an L-shaped domain, i.e.","category":"page"},{"location":"examples/ExampleA06_LocalEquilibratedFluxes2D/","page":"A06 : Local Equilibrated Fluxes 2D","title":"A06 : Local Equilibrated Fluxes 2D","text":"eta^2(sigma_h) =  sigma_h - nabla u_h ^2_L^2(T)","category":"page"},{"location":"examples/ExampleA06_LocalEquilibratedFluxes2D/","page":"A06 : Local Equilibrated Fluxes 2D","title":"A06 : Local Equilibrated Fluxes 2D","text":"where sigma_h discretisates the exact sigma in the dual mixed problem","category":"page"},{"location":"examples/ExampleA06_LocalEquilibratedFluxes2D/","page":"A06 : Local Equilibrated Fluxes 2D","title":"A06 : Local Equilibrated Fluxes 2D","text":"sigma - nabla u = 0\nquad textand quad\nmathrmdiv(sigma) + f = 0","category":"page"},{"location":"examples/ExampleA06_LocalEquilibratedFluxes2D/","page":"A06 : Local Equilibrated Fluxes 2D","title":"A06 : Local Equilibrated Fluxes 2D","text":"by some local equilibration strategy, see reference below for details.","category":"page"},{"location":"examples/ExampleA06_LocalEquilibratedFluxes2D/","page":"A06 : Local Equilibrated Fluxes 2D","title":"A06 : Local Equilibrated Fluxes 2D","text":"This examples demonstrates the use of low-level structures to assemble individual problems and a strategy to solve several small problems in parallel by use of non-overlapping node patch groups.","category":"page"},{"location":"examples/ExampleA06_LocalEquilibratedFluxes2D/","page":"A06 : Local Equilibrated Fluxes 2D","title":"A06 : Local Equilibrated Fluxes 2D","text":"reference: Reference\n''A posteriori error estimates for efficiency and error control in numerical simulations'' Lecture Notes by M. Vohralik >Link<","category":"page"},{"location":"examples/ExampleA06_LocalEquilibratedFluxes2D/","page":"A06 : Local Equilibrated Fluxes 2D","title":"A06 : Local Equilibrated Fluxes 2D","text":"module ExampleA06_LocalEquilibratedFluxes2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing ExtendableSparse\nusing GridVisualize\n\n# exact solution u for the Poisson problem\nfunction exact_function!(result,x)\n    result[1] = atan(x[2],x[1])\n    if result[1] < 0\n        result[1] += 2*pi\n    end\n    result[1] = sin(2*result[1]/3)\n    result[1] *= (x[1]^2 + x[2]^2)^(1/3)\nend\n# ... and its gradient\nfunction exact_function_gradient!(result,x)\n    result[1] = atan(x[2],x[1])\n    if result[1] < 0\n        result[1] += 2*pi\n    end\n    # du/dy = du/dr * sin(phi) + (1/r) * du/dphi * cos(phi)\n    result[2] = sin(2*result[1]/3) * sin(result[1]) + cos(2*result[1]/3) * cos(result[1])\n    result[2] *= (x[1]^2 + x[2]^2)^(-1/6) * 2/3\n    # du/dx = du/dr * cos(phi) - (1/r) * du/dphi * sin(phi)\n    result[1] = sin(2*result[1]/3) * cos(result[1]) - cos(2*result[1]/3) * sin(result[1])\n    result[1] *= (x[1]^2 + x[2]^2)^(-1/6) * 2/3\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, order = 2, nlevels = 15, theta = 1//2, Plotter = nothing)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # initial grid\n    xgrid = grid_lshape(Triangle2D)\n\n    # choose some finite elements for primal and dual problem (= for equilibrated fluxes)\n    # (local equilibration for Pk needs at least BDMk)\n    if order == 1\n        FEType = H1P1{1}\n        FETypeDual = HDIVBDM1{2}\n    elseif order == 2\n        FEType = H1P2{1,2}\n        FETypeDual = HDIVBDM2{2}\n    else\n        @error \"order must be 1 or 2\"\n    end\n\n    # negotiate data functions to the package\n    u = DataFunction(exact_function!, [1,2]; name = \"u\", dependencies = \"X\", quadorder = 5)\n    ∇u = DataFunction(exact_function_gradient!, [2,2]; name = \"∇u\", dependencies = \"X\", quadorder = 4)\n\n    # setup Poisson problem\n    Problem = PoissonProblem()\n    add_boundarydata!(Problem, 1, [2,3,4,5,6,7], BestapproxDirichletBoundary; data = u)\n    add_boundarydata!(Problem, 1, [1,8], HomogeneousDirichletBoundary)\n\n    # define error estimator : || sigma_h - nabla u_h ||^2_{L^2(T)}\n    # this can be realised via a kernel function\n    function eqestimator_kernel(result, input)\n        # input = [Identity(sigma_h), Divergence(sigma_h), Gradient(u_h)]\n        result[1] = (input[1] - input[4])^2 + (input[2] - input[5])^2 + input[3]^2\n        return nothing\n    end\n    estimator_action = Action(eqestimator_kernel, [1,5]; name = \"estimator kernel\", dependencies = \"\", quadorder = 3)\n    EQIntegrator = ItemIntegrator(Float64,ON_CELLS,[Identity, Divergence, Gradient],estimator_action)\n\n    # setup exact error evaluations\n    L2Error = L2ErrorIntegrator(Float64, u, Identity)\n    H1Error = L2ErrorIntegrator(Float64, ∇u, Gradient)\n    L2ErrorDual = L2ErrorIntegrator(Float64, ∇u, Identity)\n\n    # refinement loop (only uniform for now)\n    NDofs = zeros(Int, nlevels)\n    NDofsDual = zeros(Int, nlevels)\n    Results = zeros(Float64, nlevels, 4)\n    Solution = nothing\n    for level = 1 : nlevels\n\n        # create a solution vector and solve the problem\n        FES = FESpace{FEType}(xgrid)\n        Solution = FEVector(\"u_h\",FES)\n        solve!(Solution, Problem)\n        NDofs[level] = length(Solution[1])\n\n        # evaluate eqilibration error estimator adn append it to Solution vector (for plotting etc.)\n        DualSolution = get_local_equilibration_estimator(xgrid, Solution, FETypeDual)\n        NDofsDual[level] = length(DualSolution.entries)\n        error4cell = zeros(Float64,1,num_sources(xgrid[CellNodes]))\n        evaluate!(error4cell, EQIntegrator, [DualSolution[1], DualSolution[1], Solution[1]])\n\n        if verbosity > 0\n            println(\"\\n  SOLVE LEVEL $level\")\n            println(\"    ndofs = $(NDofs[level])\")\n            println(\"    ndofsDual = $(NDofsDual[level])\")\n        end\n\n        # calculate L2 error, H1 error, estimator, dual L2 error and write to results\n        Results[level,1] = sqrt(evaluate(L2Error,Solution[1]))\n        Results[level,2] = sqrt(evaluate(H1Error,Solution[1]))\n        Results[level,3] = sqrt(sum(view(error4cell,1,:)))\n        Results[level,4] = sqrt(evaluate(L2ErrorDual,DualSolution[1]))\n        if verbosity > 0\n            println(\"  ESTIMATE\")\n            println(\"    estim H1 error = $(Results[level,3])\")\n            println(\"    exact H1 error = $(Results[level,2])\")\n            println(\"     dual L2 error = $(Results[level,4])\")\n        end\n\n        if level == nlevels\n            break;\n        end\n\n        # mesh refinement\n        if theta >= 1\n            # uniform mesh refinement\n            xgrid = uniform_refine(xgrid)\n        else\n            # adaptive mesh refinement\n            # refine by red-green-blue refinement (incl. closuring)\n            facemarker = bulk_mark(xgrid, error4cell[:], theta)\n            xgrid = RGB_refine(xgrid, facemarker)\n        end\n    end\n\n    # plot\n    p=GridVisualizer(; Plotter=Plotter, layout=(1,3), clear=true, resolution=(1200,400))\n    scalarplot!(p[1,1], xgrid, view(nodevalues(Solution[1]),1,:), levels=11, title = \"u_h\")\n    gridplot!(p[1,2], xgrid; linewidth = 1)\n    gridplot!(p[1,3], xgrid; linewidth = 1, xlimits = [-0.001,0.001], ylimits = [-0.001,0.001])\n\n    # print/plot convergence history\n    print_convergencehistory(NDofs, Results; X_to_h = X -> X.^(-1/2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"η\", \"|| ∇u - σ_h ||\"])\n    plot_convergencehistory(NDofs, Results; add_h_powers = [order,order+1], X_to_h = X -> X.^(-1/2), Plotter = Plotter, ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"η\", \"|| ∇u - σ_h ||\"])\nend\n\n\n# this function computes the local equilibrated fluxes\n# by solving local problems on (disjunct group of) node patches\nfunction get_local_equilibration_estimator(xgrid::ExtendableGrid{Tv,Ti}, Solution::FEVector{T,Tv,Ti}, FETypeDual) where {T,Tv,Ti}\n    # needed grid stuff\n    xCellNodes::Array{Ti,2} = xgrid[CellNodes]\n    xCellVolumes::Array{Tv,1} = xgrid[CellVolumes]\n    xNodeCells::Adjacency{Ti} = atranspose(xCellNodes)\n    nnodes::Int = num_sources(xNodeCells)\n    ncells = size(xCellNodes,2)\n\n    # get node patch groups that can be solved in parallel\n    group4node = xgrid[NodePatchGroups]\n\n    # init equilibration space (and Lagrange multiplier space)\n    FESDual = FESpace{FETypeDual}(xgrid)\n    xItemDofs::Union{VariableTargetAdjacency{Ti},SerialVariableTargetAdjacency{Ti},Array{Ti,2}} = FESDual[CellDofs]\n    xItemDofs_uh::Union{VariableTargetAdjacency{Ti},SerialVariableTargetAdjacency{Ti},Array{Ti,2}} = Solution[1].FES[CellDofs]\n    DualSolution = FEVector{T}(\"σ_h\",FESDual)\n\n    # partition of unity and their gradients\n    POUFEType = H1P1{1}\n    POUFES = FESpace{POUFEType}(xgrid)\n    POUqf = QuadratureRule{Tv,Triangle2D}(0)\n\n    # quadrature formulas\n    qf = QuadratureRule{Tv,Triangle2D}(2*get_polynomialorder(FETypeDual, Triangle2D))\n    weights::Array{Tv,1} = qf.w\n\n    # some constants\n    div_penalty::T = 1e5\n    bnd_penalty::T = 1e30\n    maxdofs::Int = max_num_targets_per_source(xItemDofs)\n    maxdofs_uh::Int = max_num_targets_per_source(xItemDofs_uh)\n\n    # redistribute groups for more equilibrated thread load (first groups are larger)\n    maxgroups = maximum(group4node)\n    groups = Array{Int,1}(1 : maxgroups)\n    for j::Int = 1 : floor(maxgroups/2)\n        a = groups[j]\n        groups[j] = groups[2*j]\n        groups[2*j] = a\n    end\n    X = Array{Array{T,1},1}(undef,maxgroups)\n\n    Threads.@threads for group in groups\n        grouptime = @elapsed begin\n        @info \"  Starting equilibrating patch group $group on thread $(Threads.threadid())... \"\n        # temporary variables\n        localnode::Int = 0\n        graduh = zeros(T,2)\n        gradphi = zeros(Tv,2)\n        coeffs_uh = zeros(Tv, maxdofs_uh)\n        eval_i = zeros(Tv,2)\n        eval_j = zeros(Tv,2)\n        eval_phi = zeros(Tv,1)\n        cell::Int = 0\n        dofi::Int = 0\n        dofj::Int = 0\n        weight::Tv = 0\n        temp::Tv = 0\n        temp2::Tv = 0\n        temp3::Tv = 0\n        Alocal = zeros(Tv,maxdofs,maxdofs)\n        blocal = zeros(Tv,maxdofs)\n\n        # init FEBasiEvaluators\n        FEBasis_gradphi = FEBasisEvaluator{Tv,Triangle2D,Gradient,ON_CELLS}(POUFES, POUqf)\n        FEBasis_xref = FEBasisEvaluator{Tv,Triangle2D,Identity,ON_CELLS}(POUFES, qf)\n        FEBasis_graduh = FEBasisEvaluator{Tv,Triangle2D,Gradient,ON_CELLS}(Solution[1].FES, qf)\n        FEBasis_div = FEBasisEvaluator{Tv,Triangle2D,Divergence,ON_CELLS}(FESDual, qf)\n        FEBasis_id = FEBasisEvaluator{Tv,Triangle2D,Identity,ON_CELLS}(FESDual, qf)\n\n        # init system\n        A = ExtendableSparseMatrix{Tv,Int64}(FESDual.ndofs,FESDual.ndofs)\n        b = zeros(Tv,FESDual.ndofs)\n\n        # find dofs at boundary of current node patches\n        # and in interior of cells outside of current node patch group\n        is_noninvolveddof = zeros(Bool,FESDual.ndofs)\n        outside_cell::Bool = false\n        for cell = 1 : ncells\n            outside_cell = true\n            for k = 1 : 3\n                if group4node[xCellNodes[k,cell]] == group\n                    outside_cell = false\n                    break\n                end\n            end\n            if (outside_cell) # mark interior dofs of outside cell\n                for j = 1 : maxdofs\n                    is_noninvolveddof[xItemDofs[j,cell]] = true\n                end\n            end\n        end\n\n\n        for node = 1 : nnodes\n        if group4node[node] == group\n            for c = 1 : num_targets(xNodeCells,node)\n                cell = xNodeCells[c,node]\n\n                # find local node number of global node z\n                # and evaluate (constant) gradient of nodal basis function phi_z\n                localnode = 1\n                while xCellNodes[localnode,cell] != node\n                    localnode += 1\n                end\n                update_febe!(FEBasis_gradphi,cell)\n                eval_febe!(gradphi, FEBasis_gradphi, localnode, 1)\n\n                # read coefficients for discrete flux\n                for j=1:maxdofs_uh\n                    coeffs_uh[j] = Solution[1].entries[xItemDofs_uh[j,cell]]\n                end\n\n                # update other FE evaluators\n\n                update_febe!(FEBasis_graduh,cell)\n                update_febe!(FEBasis_div,cell)\n                update_febe!(FEBasis_id,cell)\n\n                # assembly on this cell\n                for i in eachindex(weights)\n                    weight = weights[i] * xCellVolumes[cell]\n\n                    # evaluate grad(u_h) and nodal basis function at quadrature point\n                    fill!(graduh,0)\n                    eval_febe!(graduh, FEBasis_graduh, coeffs_uh, i)\n                    eval_febe!(eval_phi, FEBasis_xref, localnode, i)\n\n                    # compute residual -f*phi_z + grad(u_h) * grad(phi_z) at quadrature point i ( f = 0 in this example !!! )\n                    temp2 = div_penalty * sqrt(xCellVolumes[cell]) * weight\n                    temp = temp2*( graduh[1] * gradphi[1] + graduh[2] * gradphi[2] )\n                    for dof_i = 1 : maxdofs\n                        eval_febe!(eval_i, FEBasis_id, dof_i, i)\n                        eval_i .*= weight\n                        # right-hand side for best-approximation (grad(u_h)*phi)\n                        blocal[dof_i] += (graduh[1]*eval_i[1] + graduh[2]*eval_i[2]) * eval_phi[1]\n                        # mass matrix Hdiv\n                        for dof_j = dof_i : maxdofs\n                            eval_febe!(eval_j, FEBasis_id, dof_j, i)\n                            Alocal[dof_i,dof_j] += (eval_i[1]*eval_j[1] + eval_i[2]*eval_j[2])\n                        end\n                        # div-div matrix Hdiv * penalty (quick and dirty to avoid Lagrange multiplier)\n                        eval_febe!(eval_i, FEBasis_div, dof_i, i)\n                        blocal[dof_i] += temp * eval_i[1]\n                        temp3 = temp2 * eval_i[1]\n                        for dof_j = dof_i : maxdofs\n                            eval_febe!(eval_j, FEBasis_div, dof_j, i)\n                            Alocal[dof_i,dof_j] += temp3*eval_j[1]\n                        end\n                    end\n                end\n\n                # write into global A and b\n                for dof_i = 1 : maxdofs\n                    dofi = xItemDofs[dof_i,cell]\n                    b[dofi] += blocal[dof_i]\n                    for dof_j = 1 : maxdofs\n                        dofj = xItemDofs[dof_j,cell]\n                        if dof_j < dof_i # use that Alocal is symmetric\n                            _addnz(A,dofi,dofj,Alocal[dof_j,dof_i],1)\n                        else\n                            _addnz(A,dofi,dofj,Alocal[dof_i,dof_j],1)\n                        end\n                    end\n                end\n\n                # reset local A and b\n                fill!(Alocal,0)\n                fill!(blocal,0)\n            end\n        end\n        end\n\n        # penalize dofs that are not involved\n        for j = 1 : FESDual.ndofs\n            if is_noninvolveddof[j]\n                A[j,j] = bnd_penalty\n                b[j] = 0\n            end\n        end\n\n        # solve local problem\n        X[group] = A\\b\n    end\n\n    @info \"Finished equilibration patch group $group on thread $(Threads.threadid()) in $(grouptime)s \"\n    end\n\n    # write local solutions to global vector\n    for group = 1 : maxgroups\n        DualSolution[1].entries .+= X[group]\n    end\n\n    return DualSolution\nend\n\nend","category":"page"},{"location":"examples/ExampleA06_LocalEquilibratedFluxes2D/","page":"A06 : Local Equilibrated Fluxes 2D","title":"A06 : Local Equilibrated Fluxes 2D","text":"","category":"page"},{"location":"examples/ExampleA06_LocalEquilibratedFluxes2D/","page":"A06 : Local Equilibrated Fluxes 2D","title":"A06 : Local Equilibrated Fluxes 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/ExampleA06_LocalEquilibratedFluxes2D/","page":"A06 : Local Equilibrated Fluxes 2D","title":"A06 : Local Equilibrated Fluxes 2D","text":"Default output:","category":"page"},{"location":"examples/ExampleA06_LocalEquilibratedFluxes2D/","page":"A06 : Local Equilibrated Fluxes 2D","title":"A06 : Local Equilibrated Fluxes 2D","text":"julia> ExampleA06_LocalEquilibratedFluxes2D.main()\n\n    ndofs   |    || u - u_h ||     order  |  || ∇(u - u_h) ||    order  |          η           order  |   || ∇u - σ_h ||     order  |\n============|=============================|=============================|=============================|=============================|\n        21  |     2.51263e-02      0.000  |     2.07647e-01      0.000  |     2.52975e-01      0.000  |     1.27753e-01      0.000  |\n        43  |     1.68175e-02      1.120  |     1.47652e-01      0.952  |     1.81919e-01      0.920  |     8.68219e-02      1.078  |\n        66  |     6.14056e-03      4.703  |     9.46620e-02      2.075  |     1.17661e-01      2.034  |     5.75060e-02      1.923  |\n        92  |     2.76870e-03      4.796  |     6.24936e-02      2.500  |     7.65903e-02      2.585  |     3.65790e-02      2.724  |\n       118  |     1.86787e-03      3.163  |     4.36523e-02      2.883  |     5.17987e-02      3.143  |     2.30920e-02      3.696  |\n       144  |     1.66991e-03      1.125  |     3.33631e-02      2.700  |     3.78394e-02      3.154  |     1.49901e-02      4.340  |\n       209  |     1.40634e-03      0.922  |     2.64820e-02      1.240  |     2.89354e-02      1.440  |     9.96047e-03      2.195  |\n       308  |     7.71721e-04      3.095  |     1.97006e-02      1.526  |     2.12017e-02      1.604  |     7.03768e-03      1.792  |\n       376  |     3.86089e-04      6.943  |     1.37828e-02      3.581  |     1.46833e-02      3.683  |     4.50562e-03      4.471  |\n       504  |     2.80786e-04      2.174  |     1.00936e-02      2.126  |     1.05770e-02      2.239  |     2.90894e-03      2.987  |\n       797  |     1.44621e-04      2.896  |     6.60108e-03      1.853  |     6.92195e-03      1.850  |     1.87969e-03      1.906  |\n      1092  |     7.87768e-05      3.858  |     4.60884e-03      2.282  |     4.80791e-03      2.315  |     1.27338e-03      2.473  |\n      1540  |     4.13878e-05      3.745  |     3.17731e-03      2.164  |     3.29485e-03      2.199  |     8.05750e-04      2.663  |\n      2168  |     2.48801e-05      2.976  |     2.15580e-03      2.268  |     2.22746e-03      2.289  |     5.41368e-04      2.325  |\n      3228  |     1.31080e-05      3.220  |     1.45114e-03      1.989  |     1.49433e-03      2.006  |     3.47809e-04      2.223  |","category":"page"},{"location":"examples/ExampleA06_LocalEquilibratedFluxes2D/","page":"A06 : Local Equilibrated Fluxes 2D","title":"A06 : Local Equilibrated Fluxes 2D","text":"(Image: ) (Image: )","category":"page"},{"location":"pdeoperators/#PDE-Operators","page":"PDE Operators","title":"PDE Operators","text":"","category":"section"},{"location":"pdeoperators/#Purpose","page":"PDE Operators","title":"Purpose","text":"","category":"section"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"The PDEDescription consists of PDEOperators characterising some feature of the model (like friction, convection, exterior forces, optimality conditions etc.) and describe the continuous weak form of the PDE. They can be separated roughly into two categories: linear operators and nonlinear operators.","category":"page"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"GradientRobustMultiPhysics.PDEOperator","category":"page"},{"location":"pdeoperators/#GradientRobustMultiPhysics.PDEOperator","page":"PDE Operators","title":"GradientRobustMultiPhysics.PDEOperator","text":"mutable struct PDEOperator{T<:Real, APT<:AssemblyPatternType, AT<:AssemblyType} <: AbstractPDEOperator\n\ncommon structures for all finite element operators that are assembled with GradientRobustMultiPhysics; better look at the AssemblyPatternType and the constructors\n\n\n\n\n\n","category":"type"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"The following table lists all available operators and available physics-motivated constructors for them (besides the abstract main constructor). Click on them or scroll down to find out more details.","category":"page"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"Main constructors Special constructors Mathematically\nBilinearForm  (mathrmA(mathrmFO_1(u))mathrmFO_2(v)) or (mathrmFO_1(u)mathrmA(mathrmFO_2(v)))\n LaplaceOperator (kappa nabla unabla v)\n ReactionOperator (alpha u v)\n LagrangeMultiplier (mathrmFO_1(u) v) (automatically assembles 2nd transposed block)\n ConvectionOperator (beta cdot nabla u v) (beta is function)\n HookStiffnessOperator2D (mathbbC epsilon(u)epsilon(v)) (also 1D or 3D variants exist)\nTrilinearForm  (mathrmA(mathrmFO_1(a)mathrmFO_2(u))mathrmFO_3(v))\n ConvectionOperator ((a cdot nabla) u v) (a is registered unknown)\n ConvectionRotationFormOperator ((a times nabla) uv) (a is registered unknown, only 2D for now)\nNonlinearForm  (mathrmNA(mathrmFO_1(u)mathrmFO_N-1(u))mathrmFO_N(v))\nRhsOperator  (f cdot mathrmFO(v)) or mathrmA(mathrmFO(v))","category":"page"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"Legend: mathrmFO  are placeholders for Function Operators, and mathrmA stands for a (linear) Action (that only expects the operator value of the finite element function as an input) and mathrmNA stands for a (nonlinear) Action (see NonlinearForm for details).","category":"page"},{"location":"pdeoperators/#Assembly-Type","page":"PDE Operators","title":"Assembly Type","text":"","category":"section"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"Many PDE operators need a specification that decides on which set of entities of the mesh (e.g. cells, faces, bfaces, edges) a PDEOperator lives and has to be assembled. This can be steered by the AssemblyType of ExtendableGrids. The AssemblyType can be also used as an argument for Finite Element Interpolations. The following AssemblyTypes are available. ","category":"page"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"AssemblyType Description\nAT_NODES interpolate at vertices of the mesh (only for H1-conforming FEM)\nON_CELLS assemble/interpolate on the cells of the mesh\nON_FACES assemble/interpolate on all faces of the mesh\nON_IFACES assemble/interpolate on the interior faces of the mesh\nON_BFACES assemble/interpolate on the boundary faces of the mesh\nON_EDGES (*) assemble/interpolate on all edges of the mesh (in 3D)\nON_BEDGES (*) assemble/interpolate on the boundary edges of the mesh (in 3D)","category":"page"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"note: Note\n(*) = only reasonable in 3D and still experimental, might have some issues","category":"page"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"assemblytypes.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"pdeoperators/#Special-Linear-Operators","page":"PDE Operators","title":"Special Linear Operators","text":"","category":"section"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"Below you find the special constructors of available common linear, bilinear and trilinear forms.","category":"page"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"LaplaceOperator\nReactionOperator\nConvectionOperator\nConvectionRotationFormOperator\nHookStiffnessOperator1D\nHookStiffnessOperator2D\nHookStiffnessOperator3D\nRhsOperator","category":"page"},{"location":"pdeoperators/#GradientRobustMultiPhysics.LaplaceOperator","page":"PDE Operators","title":"GradientRobustMultiPhysics.LaplaceOperator","text":"LaplaceOperator() -> GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, ON_CELLS}\nLaplaceOperator(κ; name, AT, ∇, regions, store) -> Union{Nothing, GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, ON_CELLS}}\n\n\nconstructor for a bilinearform that describes a(u,v) = κ (∇u,∇v) where kappa is some constant (diffusion) coefficient.\n\n\n\n\n\n","category":"function"},{"location":"pdeoperators/#GradientRobustMultiPhysics.ReactionOperator","page":"PDE Operators","title":"GradientRobustMultiPhysics.ReactionOperator","text":"ReactionOperator() -> GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, ON_CELLS}\nReactionOperator(α) -> Union{Nothing, GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}, GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, ON_CELLS}}\nReactionOperator(α, ncomponents; name, AT, id, regions, store) -> Union{Nothing, GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}, GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, ON_CELLS}}\n\n\nconstructor for a bilinearform that describes a(u,v) = (αu,v) or (u,αv) with some coefficient α that can be a number or an AbstractDataFunction.\n\n\n\n\n\n","category":"function"},{"location":"pdeoperators/#GradientRobustMultiPhysics.ConvectionOperator","page":"PDE Operators","title":"GradientRobustMultiPhysics.ConvectionOperator","text":"function ConvectionOperator(\n    a_from::Int, \n    beta_operator::Type{<:AbstractFunctionOperator},\n    xdim::Int,\n    ncomponents::Int;\n    name = \"auto\",\n    AT::Type{<:AssemblyType} = ON_CELLS,\n    fixed_argument::Int = 1,\n    factor = 1,\n    ansatzfunction_operator::Type{<:AbstractFunctionOperator} = Gradient,\n    testfunction_operator::Type{<:AbstractFunctionOperator} = Identity,\n    regions::Array{Int,1} = [0],\n    auto_newton::Bool = false,\n    quadorder = 0)\n\nconstructs a trilinearform for a convection term of the form c(a,u,v) = (betaoperator(a)*ansatzfunctionoperator(u),testfunctionoperator(v)) where afrom is the id of some unknown of the PDEDescription; xdim is the space dimension (= number of components of betaoperato(a)) and ncomponents is the number of components of u. With fixedargument = 2 a and u can switch their places, i.e.  c(u,a,v) = (betaoperator(u)*grad(a),v), With autonewton = true a Newton scheme for c(u,u,v) is automatically derived (and fixed_argument is ignored).\n\n\n\n\n\nConvectionOperator(β::UserData{AbstractDataFunction}, ncomponents::Int64; name, store, AT, ansatzfunction_operator, testfunction_operator, transposed_assembly, regions) -> GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}\n\n\nconstructor for a bilinearform that describes a(u,v) = ((β ⋅ ∇) u,v) with some user-specified DataFunction β. The user also has to specify the number of components (ncomponents) the convection is applied to. The operators for u and v can be changed (if this leads to something reasonable).\n\n\n\n\n\n","category":"function"},{"location":"pdeoperators/#GradientRobustMultiPhysics.ConvectionRotationFormOperator","page":"PDE Operators","title":"GradientRobustMultiPhysics.ConvectionRotationFormOperator","text":"ConvectionRotationFormOperator(beta::Int64, beta_operator::Type{<:??}, xdim::Int64, ncomponents::Int64; name, AT, factor, ansatzfunction_operator, testfunction_operator, regions) -> Union{Nothing, GradientRobustMultiPhysics.PDEOperator{Float64, TrilinearForm, ON_CELLS}}\n\n\nconstructor for a trilinearform that describes a(u,v) = (beta x curl(u),v) where beta is the id of some unknown vector field of the PDEDescription, u and v are also vector-fields and x is the cross product (so far this is only implemented in 2D)\n\n\n\n\n\n","category":"function"},{"location":"pdeoperators/#GradientRobustMultiPhysics.HookStiffnessOperator1D","page":"PDE Operators","title":"GradientRobustMultiPhysics.HookStiffnessOperator1D","text":"HookStiffnessOperator1D(μ; name, regions, ∇, store) -> GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}\n\n\nconstructor for a bilinearform that describes a(u,v) = (μ ∇u,∇v) where C is the 1D stiffness tensor for given μ.\n\n\n\n\n\n","category":"function"},{"location":"pdeoperators/#GradientRobustMultiPhysics.HookStiffnessOperator2D","page":"PDE Operators","title":"GradientRobustMultiPhysics.HookStiffnessOperator2D","text":"HookStiffnessOperator2D(μ, λ; name, AT, regions, ϵ, store) -> GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}\n\n\nconstructor for a bilinearform that describes a(u,v) = (C ϵ(u), ϵ(v)) where C is the 2D stiffness tensor for isotropic media in Voigt notation, i.e. C ϵ(u) = 2 μ ϵ(u) + λ tr(ϵ(u)) for Lame parameters μ and λ\n\nIn Voigt notation C is a 3 x 3 matrix\nC = [c11,c12,  0\n     c12,c11,  0\n       0,  0,c33]\n\nwhere c33 = μ, c12 = λ and c11 = 2*c33 + c12\n\nNote: ϵ is the symmetric part of the gradient (in Voigt notation)\n\n\n\n\n\n","category":"function"},{"location":"pdeoperators/#GradientRobustMultiPhysics.HookStiffnessOperator3D","page":"PDE Operators","title":"GradientRobustMultiPhysics.HookStiffnessOperator3D","text":"HookStiffnessOperator3D(μ, λ; name, AT, regions, ϵ, store) -> GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}\n\n\nconstructor for a bilinearform that describes a(u,v) = (C ϵ(u), ϵ(v)) where C is the 3D stiffness tensor for isotropic media in Voigt notation, i.e. C ϵ(u) = 2 μ ϵ(u) + λ tr(ϵ(u)) for Lame parameters μ and λ\n\nIn Voigt notation C is a 6 x 6 matrix\nC = [c11,c12,c12,  0,  0,  0\n     c12,c11,c12,  0,  0,  0\n     c12,c12,c11,  0,  0,  0\n       0,  0,  0,c44,  0,  0\n       0,  0,  0,  0,c44,  0\n       0,  0,  0,  0,  0,c44]   \n\nwhere c44 = μ, c12 = λ and c11 = 2*c44 + c12\n\nNote: ϵ is the symmetric part of the gradient (in Voigt notation)\n\n\n\n\n\n","category":"function"},{"location":"pdeoperators/#GradientRobustMultiPhysics.RhsOperator","page":"PDE Operators","title":"GradientRobustMultiPhysics.RhsOperator","text":"RhsOperator(operator::Type{<:??}, action::AbstractAction; name, AT, regions, factor, store) -> GradientRobustMultiPhysics.PDEOperator{Float64, LinearForm, ON_CELLS}\n\n\ngenerates a linearform from an action (whose input dimension has to equal the result dimension of operator and the result dimension has to be 1), L(v) = (A(operator(v)),1)\n\n\n\n\n\nRhsOperator(operator::Type{<:??}, regions::Vector{Int64}, f::UserData{<:AbstractDataFunction}; name, AT, factor, store) -> GradientRobustMultiPhysics.PDEOperator{Float64, LinearForm, ON_CELLS}\n\n\ngenerates a linearform from a given UserData{<:DataFunction} f (that should have the same result dimensions as the length of result of the operator applied to the testfunction), i.e. L(v) = (f,operator(v))\n\n\n\n\n\n","category":"function"},{"location":"pdeoperators/#Custom-Linear-Operators","page":"PDE Operators","title":"Custom Linear Operators","text":"","category":"section"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"It is possible to define custom bilineraforms and trilinearforms by specifiyng Function Operators and (in case of bilinearform optionally) an Action.","category":"page"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"BilinearForm\nTrilinearForm","category":"page"},{"location":"pdeoperators/#GradientRobustMultiPhysics.BilinearForm","page":"PDE Operators","title":"GradientRobustMultiPhysics.BilinearForm","text":"function BilinearForm(\n    T::Type{<:Real},\n    AT::Type{<:AssemblyType},\n    FE::Array{FESpace,1},\n    operators::Array{DataType,1}, \n    action::AbstractAction; \n    regions::Array{Int,1} = [0])\n\nCreates a general BilinearForm assembly pattern with the given FESpaces, operators and action etc.\n\n\n\n\n\nfunction BilinearForm(\n    operators::Array{AbstractFunctionOperator,1},\n    action::AbstractAction = NoAction();\n    name = \"auto\",\n    AT::Type{<:AssemblyType} = ON_CELLS,\n    APT::Type{<:APT_BilinearForm} = APT_BilinearForm,\n    apply_action_to = 1,\n    regions::Array{Int,1} = [0],\n    transposed_assembly::Bool = false,\n    store::Bool = false)\n\nabstract bilinearform constructor that assembles\n\nb(u,v) = intregions action(operator1(u)) * operator2(v) if applyaction_to = 1\nb(u,v) = intregions operator1(u) * action(operator2(v)) if applyaction_to = 2\n\nThe optional arguments AT and regions specifies on which grid item the operator lives/assembles, while store toggles the separate storage for the operator (which is advisable if it is not alone i an otherweise nonlinear block of a PDEDescription). With the optional argument APT one can trigger different subpatterns like APTSymmetricBilinearForm (assembles only a triangular block) or APTLumpedBilinearForm (assembles only the diagonal).\n\n\n\n\n\n","category":"function"},{"location":"pdeoperators/#GradientRobustMultiPhysics.TrilinearForm","page":"PDE Operators","title":"GradientRobustMultiPhysics.TrilinearForm","text":"function TrilinearForm(\n    T::Type{<:Real},\n    FES::Array{FESpace,1},          \n    operators::Array{DataType,1},\n    action::AbstractAction;\n    regions::Array{Int,1} = [0])\n\nCreates a TrilinearForm assembly pattern with the given FESpaces, operators and action etc.\n\n\n\n\n\nfunction TrilinearForm(\n    operators::Array{AbstractFunctionOperator,1},\n    a_from::Int,\n    a_to::Int,\n    action::AbstractAction;\n    name = \"auto\",\n    AT::Type{<:AssemblyType} = ON_CELLS,\n    regions::Array{Int,1} = [0],\n    transposed_assembly::Bool = false)\n\nabstract trilinearform constructor that assembles\n\nc(a,u,v) = (action(operators1,operators2), operators3)\n\nwhere u and are the ansatz and test function coressponding to the PDE coordinates and a is an additional unknown of the PDE. The argument a can be moved to the other positions with ato and gets it data from unknown afrom of the full PDEdescription.\n\nThe optional arguments AT and regions specifies on which grid item the operator lives/assembles,\n\nAlso note that this operator is always marked as nonlinear by the Solver configuration.\n\n\n\n\n\n","category":"function"},{"location":"pdeoperators/#Examples","page":"PDE Operators","title":"Examples","text":"","category":"section"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"Below some examples for operators are given:","category":"page"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"# Example 1 : div-div bilinearform with a factor λ (e.g. for divergence-penalisation)\noperator = BilinearForm([Divergence,Divergence]; factor = λ, name = \"λ (div(u),div(v))\")\n\n# Example 2 : Gradient jump stabilisation with an item-dependent action and a factor s (e.g. for convection stabilisation)\nxFaceVolumes::Array{Float64,1} = xgrid[FaceVolumes]\nfunction stabilisation_kernel(result, input, item)\n    result .= input \n    result .*= xFaceVolumes[item]^2\nend\naction = Action(stabilisation_kernel, [2,2]; dependencies = \"I\", quadorder = 0 )\noperator = BilinearForm([Jump(Gradient), Jump(Gradient)], action; AT = ON_IFACES, factor = s, name = \"s |F|^2 [∇(u)]⋅[∇(v)]\")\n","category":"page"},{"location":"pdeoperators/#Lagrange-Multipliers","page":"PDE Operators","title":"Lagrange Multipliers","text":"","category":"section"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"There is a special bilinearform intended to use for the assembly of Lagrange multipliers that automatically copies itself to the transposed block of the PDEdescription.","category":"page"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"LagrangeMultiplier","category":"page"},{"location":"pdeoperators/#GradientRobustMultiPhysics.LagrangeMultiplier","page":"PDE Operators","title":"GradientRobustMultiPhysics.LagrangeMultiplier","text":"LagrangeMultiplier(operator::Type{<:??}; name, AT, action, regions, store, factor) -> GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}\n\n\nconstructor for a bilinearform that describes a(u,v) = (A(operator(u)), id(v)) and assembles a second transposed block at the block of the transposed PDE coordinates. It is intended to use to render one unknown of the PDE the Lagrange multiplier for another unknown by putting this operator on the coressponding subdiagonal block of the PDE description.\n\nExample: LagrangeMultiplier(Divergence) is used to render the pressure the LagrangeMultiplier for the velocity divergence constraint in the Stokes prototype.\n\n\n\n\n\n","category":"function"},{"location":"pdeoperators/#Nonlinear-Operators","page":"PDE Operators","title":"Nonlinear Operators","text":"","category":"section"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"Nonlinear Operators can be setup in two ways. The manual way requires the user to define an action with a nonlinear action kernel (see Action Kernel) that specifies the linearisation of the nonlinearity. There is also an automatic way where the user specifies only a function (where the input can be used nonlinearly) which is then automatically differentiated to generate the linearised action kernel, see below for details.","category":"page"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"NonlinearForm","category":"page"},{"location":"pdeoperators/#GradientRobustMultiPhysics.NonlinearForm","page":"PDE Operators","title":"GradientRobustMultiPhysics.NonlinearForm","text":"function NonlinearForm(\n    T::Type{<:Real},\n    FES::Array{FESpace,1},          # finite element spaces for each operator of the ansatz function and the last one refers to the test function\n    operators::Array{DataType,1},   # operators that should be evaluated for the ansatz function and the last one refers to the test function\n    action::AbstractAction;         # action that shoul have an AbstractNLActionKernel\n    regions::Array{Int,1} = [0])\n\nCreates a NonlinearForm assembly pattern.\n\n\n\n\n\nfunction NonlinearForm(\n    operator1::Array{DataType,1},\n    coeff_from::Array{Int,1},\n    operator2::Type{<:AbstractFunctionOperator},\n    action_kernel::Function,\n    argsizes::Array{Int,1},\n    dim::Int;\n    name::String = \"nonlinear form\",\n    AT::Type{<:AssemblyType} = ON_CELLS,\n    ADnewton::Bool = false,\n    action_kernel_rhs = nothing,\n    factor = 1,\n    regions = [0])\n\ngenerates an abstract nonlinearform operator G.  The array coeff_from stores the ids of the unknowns that should be used to evaluate the operators. The array argsizes is a vector with two entries where the first one is the length of the expected result vector and the second one is the length of the input vector.\n\nIf ADnewton == true, the specified actionkernel is automatically differentiated to assemble the Jacobian DG and setup a Newton iteration. The actionkernel has to be a function of the interface \n\nfunction name(result,input)\n\nwhere input is a vector of the operators of the solution and result is what then is multiplied with operator2 of the testfunction. Given some operator G(u), the Newton iteration reads DG u_next = DG u - G(u) which is added to the rest of the (linear) operators in the PDEDescription.\n\nIf ADnewton == false, the user is epected to prescribe a linearisation of the nonlinear operator. In this case the action_kernel has to satisfy the interface\n\nfunction name(result, input_current, input_ansatz)\n\nwhere inputcurrent is a vector of the operators of the solution and inputansatz is a vecor with the operators evaluated at one of the basis functions. If necessary, also a right-hand side action in the same format can be prescribed in actionkernelrhs. \n\nNote 1: The AD feature matured a bit, but still is to be considered experimental.\n\nNote 2: The limitation that the nonlinearity only can depend on one unknown of the PDE was recently lifted, however the behavior how to assign this operator to the PDE may be revised in future. Currently, the nonlinearity can indeed depend on arbitrary unknowns (i.e. coefffrom may contain more than one different unknown ids), which will lead to copies of the operator assigned also to off-diagonal blocks which are then related to partial derivatives with respect to the other unknowns (i.e. inputansatz will only contain the operator evaluations that coresspond to the unknown of the subblock it is evaluated at, all other entries are zero). The subblock assignment of the copies is done automatically by the add_operator! function.\n\n\n\n\n\n","category":"function"},{"location":"pdeoperators/#Other-Operators","page":"PDE Operators","title":"Other Operators","text":"","category":"section"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"There are some more operators that do not fit into the structures above. Also, in the future, the goal is to open up the operator level for exterior code to setup operators that are assembled elsewhere.","category":"page"},{"location":"pdeoperators/","page":"PDE Operators","title":"PDE Operators","text":"FVConvectionDiffusionOperator\nDiagonalOperator\nCopyOperator","category":"page"},{"location":"pdeoperators/#GradientRobustMultiPhysics.FVConvectionDiffusionOperator","page":"PDE Operators","title":"GradientRobustMultiPhysics.FVConvectionDiffusionOperator","text":"FVConvectionDiffusionOperator(beta_from::Int64; μ) -> FVConvectionDiffusionOperator{Float64}\n\n\nfinite-volume convection diffusion operator (for cell-wise P0 rho)\n\ndiv(μ ∇ρ + β ρ)\n\nFor μ = 0, the upwind divergence div_upw(β ρ) is generated  For μ > 0, TODO\n\n\n\n\n\n","category":"type"},{"location":"pdeoperators/#GradientRobustMultiPhysics.DiagonalOperator","page":"PDE Operators","title":"GradientRobustMultiPhysics.DiagonalOperator","text":"DiagonalOperator() -> DiagonalOperator{Float64}\nDiagonalOperator(value::Real; name, onlynz, regions) -> DiagonalOperator\n\n\nputs value on the diagonal entries of the cell dofs within given regions\n\nif onlyz == true only values that are zero are changed\n\ncan only be applied in PDE LHS\n\n\n\n\n\n","category":"type"},{"location":"pdeoperators/#GradientRobustMultiPhysics.CopyOperator","page":"PDE Operators","title":"GradientRobustMultiPhysics.CopyOperator","text":"CopyOperator(copy_from, factor) -> CopyOperator\n\n\ncopies entries from TargetVector to rhs block\n\ncan only be applied in PDE RHS\n\n\n\n\n\n","category":"type"},{"location":"pdeprototypes/#PDE-Prototypes","page":"PDE Prototypes","title":"PDE Prototypes","text":"","category":"section"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Below all available prototypes (i.e. pre-defined constructors for PDEDescription) are listed. They can be used as a point of deperature for more complex models. Also have a look in to the examples for more complex model problems.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"note: Note\nFor most prototypes boundary data and right-hand side data or other modifications to the weak form of the PDE have to be added after a proto-type constructor has been called, see the examples for further assistance.","category":"page"},{"location":"pdeprototypes/#Poisson-equation","page":"PDE Prototypes","title":"Poisson equation","text":"","category":"section"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The Poisson equation seeks a function u such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"- mu Delta u = f","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"where mu is some diffusion coefficient and f some given right-hand side data.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The (primal) weak formulation (for homogeneous Dirichlet boundary data) seeks u such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"(mu nabla unabla v)  = (fv) quad textfor all  vin H^1_0(Omega)","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"A vanilla PDEDescription for this weak formulation (without boundary data) can be created with the constructor below.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"PoissonProblem","category":"page"},{"location":"pdeprototypes/#GradientRobustMultiPhysics.PoissonProblem","page":"PDE Prototypes","title":"GradientRobustMultiPhysics.PoissonProblem","text":"function PoissonProblem(diffusion = 1.0)\n\nCreates a PDEDescription for a Poisson problem with globally constant diffusion parameter.\n\nBoundary and right-hand side data or other modifications have to be added afterwards.\n\n\n\n\n\n","category":"function"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Remarks:","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"dual weak formulations are also possible but are not available as a prototype currently","category":"page"},{"location":"pdeprototypes/#Incompressible-Navier–Stokes-equations","page":"PDE Prototypes","title":"Incompressible Navier–Stokes equations","text":"","category":"section"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The Navier–Stokes equations in d dimensions seek a (vector-valued) velocity mathbfu and a pressure p such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"beginaligned\n- mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = mathbff\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"where mu is some viscosity coefficient and f some given right-hand side data.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The weak formulation (for homogeneous Dirichlet boundary data) seeks (mathbfup) such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"beginaligned\n(mu nabla mathbfunabla mathbfv) + ((u cdot nabla) mathbfu mathbfv) + (mathrmdiv mathbfv p)  = (mathbffmathbfv)  textfor all  mathbfvin H^1_0(Omega)^d\n(mathrmdiv mathbfu q)  = 0  textfor all  q in L^2_0(Omega)\nendaligned","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"A vanilla PDEDescription for this weak formulation (without boundary data) can be created with the constructor below.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"IncompressibleNavierStokesProblem","category":"page"},{"location":"pdeprototypes/#GradientRobustMultiPhysics.IncompressibleNavierStokesProblem","page":"PDE Prototypes","title":"GradientRobustMultiPhysics.IncompressibleNavierStokesProblem","text":"function IncompressibleNavierStokesProblem(\n    dimension::Int = 2;\n    viscosity = 1.0,\n    nonlinear::Bool = false,\n    auto_newton::Bool = false,\n    nopressureconstraint::Bool = false,\n    pmean = 0)\n\nCreates a PDEDescription for the incompressible (Navier-)Stokes equations of the specified dimension and globally constant viscosity parameter. If nonlinear = true the nonlinear convection term is added to the PDEDescription. If also auto_newton = true, a Newton iteration is devised by automatic differentiation of the convection term.\n\n\n\n\n\n","category":"function"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Remarks:","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"if nonlinear == false the nonlinear convection term is not added to the equation resulting in the plain Stokes equations.\nif nopressureconstraint == true removes the integral mean constraint on the pressure.","category":"page"},{"location":"pdeprototypes/#Navier-Lame-equations-(linear-elasticity)","page":"PDE Prototypes","title":"Navier-Lame equations (linear elasticity)","text":"","category":"section"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The Navier-Lame equations seek a displacement mathbfu such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"- mathrmdiv( mathbbC epsilon( mathbfu)) = mathbff","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"where epsilon( mathbfu) is the symmetric part of the gradient, mathbbC is the stiffness tensor (according to Hooke's law) and mathbff some given right-hand side data.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"In 1D, it is assumed that the stiffness tensor has the form","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"mathbbC epsilon( u) = mu nabla u","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"where mu is the elasticity modulus. In 2D, it is assumed that the stiffness tensor has the form","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"mathbbC epsilon( u) = 2 mu epsilon( mathbfu) + lambda mathrmtr(epsilon( mathbfu))","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"where mu and lambda are the Lame coefficients.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"The (primal) weak formulation (for homogeneous Dirichlet boundary data) seeks u such that","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"(mathbbC epsilon(mathbfu)epsilon(mathbfv)) = (mathbffmathbfv) quad textfor all  vin H^1_0(Omega)^d","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"A vanilla PDEDescription for this weak formulation (without boundary data) can be created with the constructor below.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"LinearElasticityProblem","category":"page"},{"location":"pdeprototypes/#GradientRobustMultiPhysics.LinearElasticityProblem","page":"PDE Prototypes","title":"GradientRobustMultiPhysics.LinearElasticityProblem","text":"function LinearElasticityProblem(\n    dimension::Int = 2;\n    elasticity_modulus = 1.0,\n    shear_modulus = 1.0,\n    lambda = 1.0)\n\nCreates a PDEDescription for the linear elasticity problem of the specified dimension.\n\nIf dimension == 1, only the elasticitymodulus is used as a parameter in the Hookian stiffness operator. If dimension == 2, shearmodulus and lambda are used as Lame parameters in the Hookian stiffness operator.\n\nBoundary and right-hand side data or other modifications have to be added afterwards.\n\n\n\n\n\n","category":"function"},{"location":"pdeprototypes/#L2-Bestapproximation","page":"PDE Prototypes","title":"L2-Bestapproximation","text":"","category":"section"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"This PDEDescription can be used to setup an L2-Bestapproximation very fast. The weak formulation simply seeks some function u such that, for some given function u_textexact, it holds u = u_textexact along the (specified) boundary and","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"(uv) = (u_textexactv) quad textfor all  vin L^2(Omega)","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"Of course, on the continuous level, it holds u = u_textexact, but if the weak formulation is assembled for a finite element space one obtains a discrete L2-bestapproximation for this space.","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"L2BestapproximationProblem","category":"page"},{"location":"pdeprototypes/#GradientRobustMultiPhysics.L2BestapproximationProblem","page":"PDE Prototypes","title":"GradientRobustMultiPhysics.L2BestapproximationProblem","text":"function L2BestapproximationProblem(\n    uexact::UserData{AbstractDataFunction};\n    bonus_quadorder::Int = 0,\n    bestapprox_boundary_regions = [])\n\nCreates an PDEDescription for an L2-Bestapproximation problem for the given exact function. Since this prototype already includes boundary and right-hand side data also a bonus quadrature order can be specified to steer the accuracy.\n\n\n\n\n\n","category":"function"},{"location":"pdeprototypes/#H1-Bestapproximation","page":"PDE Prototypes","title":"H1-Bestapproximation","text":"","category":"section"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"This PDEDescription can be used to setup an H1-Bestapproximation very fast. The weak formulation simply seeks some function u such that, for some given function u_textexact, it holds u = u_textexact along the (specified) boundary and","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"(nabla unabla v) = (nabla u_textexact nabla v) quad textfor all  vin H^1_0(Omega)","category":"page"},{"location":"pdeprototypes/","page":"PDE Prototypes","title":"PDE Prototypes","text":"H1BestapproximationProblem","category":"page"},{"location":"pdeprototypes/#GradientRobustMultiPhysics.H1BestapproximationProblem","page":"PDE Prototypes","title":"GradientRobustMultiPhysics.H1BestapproximationProblem","text":"function H1BestapproximationProblem(\n    exact_function_gradient::UserData{AbstractDataFunction},\n    exact_function_boundary::UserData{AbstractDataFunction};\n    bonus_quadorder::Int = 0,\n    bonus_quadorder_boundary::Int = 0,\n    bestapprox_boundary_regions = [])\n\nCreates an PDEDescription for an H1-Bestapproximation problem for the given exact function (only used on the boundary) and its exact gradient (used in the right-hand side). Since this prototype already includes boundary and right-hand side data also a bonus quadrature order can be specified to steer the accuracy.\n\n\n\n\n\n","category":"function"},{"location":"examples/Example202_LinearElasticity2D/#:-Linear-Elasticity","page":"202 : Linear Elasticity","title":"202 : Linear Elasticity","text":"","category":"section"},{"location":"examples/Example202_LinearElasticity2D/","page":"202 : Linear Elasticity","title":"202 : Linear Elasticity","text":"(source code)","category":"page"},{"location":"examples/Example202_LinearElasticity2D/","page":"202 : Linear Elasticity","title":"202 : Linear Elasticity","text":"This example computes the solution mathbfu of the linear elasticity problem","category":"page"},{"location":"examples/Example202_LinearElasticity2D/","page":"202 : Linear Elasticity","title":"202 : Linear Elasticity","text":"beginaligned\n-mathrmdiv (mathbbC epsilon(mathbfu))  = mathbff quad textin  Omega\nmathbbC epsilon(mathbfu) cdot mathbfn  = mathbfg quad textalong  Gamma_N\nendaligned","category":"page"},{"location":"examples/Example202_LinearElasticity2D/","page":"202 : Linear Elasticity","title":"202 : Linear Elasticity","text":"with exterior force mathbff, Neumann boundary force mathbfg, and the stiffness tensor","category":"page"},{"location":"examples/Example202_LinearElasticity2D/","page":"202 : Linear Elasticity","title":"202 : Linear Elasticity","text":"mathbbC epsilon(mathbfu) = 2 mu epsilon( mathbfu) + λ mathrmtr(epsilon( mathbfu))","category":"page"},{"location":"examples/Example202_LinearElasticity2D/","page":"202 : Linear Elasticity","title":"202 : Linear Elasticity","text":"for isotropic media.","category":"page"},{"location":"examples/Example202_LinearElasticity2D/","page":"202 : Linear Elasticity","title":"202 : Linear Elasticity","text":"The domain will be the Cook membrane and the displacement has homogeneous boundary conditions on the left side of the domain and Neumann boundary conditions (i.e. a constant force that pulls the domain upwards) on the right side.","category":"page"},{"location":"examples/Example202_LinearElasticity2D/","page":"202 : Linear Elasticity","title":"202 : Linear Elasticity","text":"module Example202_LinearElasticity2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\nconst g = DataFunction([0,10]; name = \"g\")\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, E = 1000, ν = 0.4, Plotter = nothing)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # load mesh and refine\n    xgrid = simplexgrid(\"assets/2d_grid_cookmembrane.sg\")\n    xgrid = uniform_refine(xgrid,2)\n\n    # compute Lame' coefficients from E and ν\n    μ = (1/(1+ν))*E\n    λ = (ν/(1-2*ν))*μ\n\n    # PDE description via prototype and add data\n    Problem = LinearElasticityProblem(2; shear_modulus = μ, lambda = λ)\n    add_rhsdata!(Problem, 1, RhsOperator(Identity, [2], g; AT = ON_BFACES))\n    add_boundarydata!(Problem, 1, [4], HomogeneousDirichletBoundary)\n\n    # show and solve PDE\n    @show Problem\n    FEType = H1P1{2} # P1-Courant FEM will be used\n    Solution = FEVector(\"u_h\",FESpace{FEType}(xgrid))\n    solve!(Solution, Problem)\n\n    # plot stress on displaced mesh\n    displace_mesh!(xgrid, Solution[1]; magnify = 4)\n    p = GridVisualizer(; Plotter = Plotter, layout = (1,2), clear = true, resolution = (1000,500))\n    scalarplot!(p[1,1], xgrid, view(nodevalues(Solution[1]; abs = true),1,:), levels = 7, title = \"u_h\")\n    vectorplot!(p[1,1], xgrid, evaluate(PointEvaluator(Solution[1], Identity)), spacing = 5, clear = false, title = \"u_h (abs + quiver)\")\n    scalarplot!(p[1,2], xgrid, view(nodevalues(Solution[1], SymmetricGradient{1/√2}; abs = true),1,:), levels=11, title = \"ϵ(u_h) (abs)\")\nend\n\nend","category":"page"},{"location":"examples/Example202_LinearElasticity2D/","page":"202 : Linear Elasticity","title":"202 : Linear Elasticity","text":"","category":"page"},{"location":"examples/Example202_LinearElasticity2D/","page":"202 : Linear Elasticity","title":"202 : Linear Elasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example202_LinearElasticity2D/","page":"202 : Linear Elasticity","title":"202 : Linear Elasticity","text":"Default output:","category":"page"},{"location":"examples/Example202_LinearElasticity2D/","page":"202 : Linear Elasticity","title":"202 : Linear Elasticity","text":"julia> Example202_LinearElasticity2D.main()\n\nPDE-DESCRIPTION\n===============\n  system name = linear elasticity problem\n\n     id   | unknown name / equation name\n    [1]   | u / displacement equation \n\n  LHS block | PDEOperator(s)\n    [1,1]   | (C(μ,λ) ϵ(u),ϵ(v)) (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n\n  RHS block | PDEOperator(s)\n     [1]    | (g, id(v)) (APT = LinearForm, AT = ON_BFACES, regions = [2])\n\n   BoundaryOperator[1] : HomogeneousDirichletBoundary -> [4]\n                          \n\nProblem = ","category":"page"},{"location":"examples/Example202_LinearElasticity2D/","page":"202 : Linear Elasticity","title":"202 : Linear Elasticity","text":"(Image: )","category":"page"},{"location":"examples/Example240_TransientFlowAroundCylinder2D/#:-Transient-Flow-around-a-cylinder-2D","page":"240 : Transient Flow around a cylinder 2D","title":"240 : Transient Flow around a cylinder 2D","text":"","category":"section"},{"location":"examples/Example240_TransientFlowAroundCylinder2D/","page":"240 : Transient Flow around a cylinder 2D","title":"240 : Transient Flow around a cylinder 2D","text":"(source code)","category":"page"},{"location":"examples/Example240_TransientFlowAroundCylinder2D/","page":"240 : Transient Flow around a cylinder 2D","title":"240 : Transient Flow around a cylinder 2D","text":"This example solves the time-dependent DFG Navier-Stokes benchmark problem","category":"page"},{"location":"examples/Example240_TransientFlowAroundCylinder2D/","page":"240 : Transient Flow around a cylinder 2D","title":"240 : Transient Flow around a cylinder 2D","text":"beginaligned\nmathbfu_t  - mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = 0\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"examples/Example240_TransientFlowAroundCylinder2D/","page":"240 : Transient Flow around a cylinder 2D","title":"240 : Transient Flow around a cylinder 2D","text":"on a rectangular 2D domain with a circular obstacle in the time interval [0,8], see here for details.","category":"page"},{"location":"examples/Example240_TransientFlowAroundCylinder2D/","page":"240 : Transient Flow around a cylinder 2D","title":"240 : Transient Flow around a cylinder 2D","text":"Note: This example needs the additional packages Triangulate and SimplexGridFactory to generate the mesh.","category":"page"},{"location":"examples/Example240_TransientFlowAroundCylinder2D/","page":"240 : Transient Flow around a cylinder 2D","title":"240 : Transient Flow around a cylinder 2D","text":"module Example240_TransientFlowAroundCylinder2D\n\nusing GradientRobustMultiPhysics\nusing Triangulate\nusing SimplexGridFactory\nusing GridVisualize\nusing ExtendableGrids\nusing Printf\n\n# inlet data for Karman vortex street example\n# as in DFG benchmark 2D-3 (Re = 100)\nconst L, W, H = 0.1, 2.2, 0.41\nfunction bnd_inlet!(result,x,t)\n    result[1] = 6*x[2]*(H-x[2])/(H*H) * max(sin(pi*t/8),0)\n    result[2] = 0.0\nend\nconst inflow = DataFunction(bnd_inlet!, [2,2]; name = \"u_inflow\", dependencies = \"XT\", quadorder = 2)\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, μ = 1e-3, maxvol = 6e-3, T = [1//1,2//1,3//1,6//1,8//1], timestep = [2//100,1//100,5//1000,2//1000,5//1000], TIR = CrankNicolson, plot_step = 1e-2)\n\n    # load grid, finer grid is used for plots\n    xgrid = make_grid(W,H; n = Int(ceil(sqrt(1/maxvol))), maxvol = maxvol)\n    xgrid_plot = uniform_refine(xgrid,2; store_parents = true)\n    nnodes_plot = size(xgrid_plot[Coordinates],2)\n\n    # P2-bubble element + reconstruction operator\n    FETypes = [H1P2B{2,2}, H1P1{1}];\n    VeloIdentity = ReconstructionIdentity{HDIVBDM2{2}} # div-free reconstruction operator for Identity\n\n    # PDE description\n    Problem = PDEDescription(\"NSE problem (μ = $μ)\")\n    add_unknown!(Problem; equation_name = \"momentum equation\", unknown_name = \"u\")\n    add_unknown!(Problem; equation_name = \"incompressibility constraint\", unknown_name = \"p\", algebraic_constraint = true)\n    add_operator!(Problem, [1,1], LaplaceOperator(μ; store = true))\n    add_operator!(Problem, [1,2], LagrangeMultiplier(Divergence))\n\n    # the convection operator is assembled to the right-hand side\n    # to keep the matrix constant in time (but we do subiterations in each timestep)\n    CO = ConvectionOperator(1, VeloIdentity, 2, 2; testfunction_operator = VeloIdentity, auto_newton = false)\n    add_rhsdata!(Problem, 1, restrict_operator(CO; fixed_arguments = [1,2], fixed_arguments_ids = [1,1], factor = -1))\n\n    # add boundary data (bregion 2 is outflow, 4 is inflow, 5 is cylinder)\n    add_boundarydata!(Problem, 1, [1,3,5], HomogeneousDirichletBoundary)\n    add_boundarydata!(Problem, 1, [4], InterpolateDirichletBoundary; data = inflow)\n\n    # generate FESpaces and Solution vector and UpscaledSolution vector (for plot on finer grid)\n    FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid; broken = true)]\n    Solution = FEVector{Float64}([\"u_h\",\"p_h\"],FES)\n    UpscaledSolution = FEVector{Float64}([\"u_h (fine)\", \"p_h (fine)\"],[FESpace{H1P1{2}}(xgrid_plot),FESpace{H1P1{1}}(xgrid_plot)])\n\n    # prepare drag lift calculation by testfunctions\n    function circle_bnd_testfunction(component) # mask for drag/lift testfunction\n        function closure!(result,x)\n            fill!(result,0)\n            if sqrt((x[1] - 0.2)^2 + (x[2] - 0.2)^2) <= 0.06\n                result[component] = 1\n            end\n            return nothing\n        end\n    end\n\n    function draglift_kernel(result, input)\n        # input = [ u, grad(u), p , v , grad(v)]\n        #         [1:2,  3:6,   7 ,8:9,  10:13 ]\n        result[1] = μ * (input[3]*input[10] + input[4]*input[11] + input[5]*input[12] + input[6]*input[13])\n        result[1] += (input[1] * input[3] + input[2] * input[4]) * input[8]\n        result[1] += (input[1] * input[5] + input[2] * input[6]) * input[9]\n        result[1] -= input[7] * (input[10] + input[13])\n        result[1] *= -(2/L)\n        return nothing\n    end\n    drag::Float64 = 0\n    lift::Float64 = 0\n    draglift_action = Action{Float64}( draglift_kernel, [1,13]; name = \"drag/lift by testfunction\", dependencies = \"\", quadorder = 0)\n    DLIntegrator = ItemIntegrator(Float64,ON_CELLS,[Identity, Gradient, Identity, Identity, Gradient], draglift_action)\n\n    # prepare drag/lift calculation\n    TestFunctionD = FEVector{Float64}(\"drag testfunction\",Solution[1].FES)\n    TestFunctionL = FEVector{Float64}(\"lift testfunction\",Solution[1].FES)\n    xBFaceFaces = Solution[1].FES.xgrid[BFaceFaces]\n    dragtest = DataFunction(circle_bnd_testfunction(1), [2,2]; name = \"drag test\", dependencies = \"X\", quadorder = 0)\n    lifttest = DataFunction(circle_bnd_testfunction(2), [2,2]; name = \"lift test\", dependencies = \"X\", quadorder = 0)\n    interpolate!(TestFunctionD[1], ON_FACES, dragtest; items = xBFaceFaces)\n    interpolate!(TestFunctionL[1], ON_FACES, lifttest; items = xBFaceFaces)\n\n    # prepare viewer\n    vis=GridVisualizer(Plotter=Plotter, resolution = (1200,300), isolines = 7, flimits = (-0.6,2.2))\n\n    # this function is called after each timestep\n    plot_step_count = Int(ceil(plot_step/timestep[1]))\n    function do_after_each_timestep(step, statistics)\n        if step == 0\n            @printf(\"|    DRAG        LIFT\")\n        else\n            drag = evaluate(DLIntegrator,[Solution[1],Solution[1],Solution[2],TestFunctionD[1],TestFunctionD[1]])\n            lift = evaluate(DLIntegrator,[Solution[1],Solution[1],Solution[2],TestFunctionL[1],TestFunctionL[1]])\n            @printf(\"| %.4e  %.4e\", drag, lift)\n            if mod(step,plot_step_count) == 0 && (step > 1) && Plotter !== nothing\n                interpolate!(UpscaledSolution[1], Solution[1], use_cellparents = true)\n                scalarplot!(vis, xgrid_plot, view(UpscaledSolution.entries,1:nnodes_plot), Plotter = Plotter, title = \"ux (T = $(Float64(TCS.ctime)))\")\n            end\n        end\n    end\n\n    # solve (after T[j] is reached the timestep is changed)\n    TCS = TimeControlSolver(Problem, Solution, TIR; timedependent_equations = [1], dt_operator = [VeloIdentity], show_iteration_details = true, maxiterations = 5, skip_update = [-1], target_residual = 1e-8, T_time = eltype(timestep))\n    for j = 1 : length(T)\n        plot_step_count = Int(ceil(plot_step/timestep[j]))\n        advance_until_time!(TCS, timestep[j], T[j]; do_after_each_timestep = do_after_each_timestep)\n    end\nend\n\n\n# grid generator script using SimplexGridBuilder/Triangulate\nfunction make_grid(W,H; n=20,maxvol=0.1)\n\tbuilder=SimplexGridBuilder(Generator=Triangulate)\n    function circlehole!(builder, center, radius; n=20)\n        points=[point!(builder, center[1]+radius*sin(t),center[2]+radius*cos(t)) for t in range(0,2π,length=n)]\n        for i=1:n-1\n            facet!(builder,points[i],points[i+1])\n        end\n        facet!(builder,points[end],points[1])\n        holepoint!(builder,center)\n    end\n    p1=point!(builder,0,0)\n    p2=point!(builder,W,0)\n    p3=point!(builder,W,H)\n    p4=point!(builder,0,H)\n\n    # heuristic refinement around cylinder\n    refine_radius = 0.25\n    maxrefinefactor = 1//20\n    function unsuitable(x1,y1,x2,y2,x3,y3,area)\n        if area>maxvol*min(max(4*maxrefinefactor,abs((x1+x2+x3)/3 - 0.2)),1/maxrefinefactor)\n            return true\n        end\n        dist = sqrt( ( (x1+x2+x3)/3 - 0.2 )^2 + ( (y1+y2+y3)/3 - 0.2)^2) - 0.05\n        myarea= dist < refine_radius ? maxvol*max(maxrefinefactor,1-(refine_radius - dist)/refine_radius) : maxvol\n        if area>myarea\n           return true\n        else\n            return false\n        end\n    end\n\n    facetregion!(builder,1); facet!(builder,p1,p2)\n    facetregion!(builder,2); facet!(builder,p2,p3)\n    facetregion!(builder,3); facet!(builder,p3,p4)\n    facetregion!(builder,4); facet!(builder,p4,p1)\n    facetregion!(builder,5); circlehole!(builder, (0.2,0.2),0.05,n=n)\n\n    simplexgrid(builder,maxvolume=16*maxvol, unsuitable = unsuitable)\nend\n\nend","category":"page"},{"location":"examples/Example240_TransientFlowAroundCylinder2D/","page":"240 : Transient Flow around a cylinder 2D","title":"240 : Transient Flow around a cylinder 2D","text":"","category":"page"},{"location":"examples/Example240_TransientFlowAroundCylinder2D/","page":"240 : Transient Flow around a cylinder 2D","title":"240 : Transient Flow around a cylinder 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example240_TransientFlowAroundCylinder2D/","page":"240 : Transient Flow around a cylinder 2D","title":"240 : Transient Flow around a cylinder 2D","text":"(Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/Example221_StokesIterated2D/#:-Stokes-iterated-penalty-method-2D","page":"221 : Stokes iterated penalty method 2D","title":"221 : Stokes iterated penalty method 2D","text":"","category":"section"},{"location":"examples/Example221_StokesIterated2D/","page":"221 : Stokes iterated penalty method 2D","title":"221 : Stokes iterated penalty method 2D","text":"(source code)","category":"page"},{"location":"examples/Example221_StokesIterated2D/","page":"221 : Stokes iterated penalty method 2D","title":"221 : Stokes iterated penalty method 2D","text":"This example computes a velocity mathbfu and pressure mathbfp of the incompressible Navier–Stokes problem","category":"page"},{"location":"examples/Example221_StokesIterated2D/","page":"221 : Stokes iterated penalty method 2D","title":"221 : Stokes iterated penalty method 2D","text":"beginaligned\n- mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = mathbf0\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"examples/Example221_StokesIterated2D/","page":"221 : Stokes iterated penalty method 2D","title":"221 : Stokes iterated penalty method 2D","text":"with some μ parameter mu.","category":"page"},{"location":"examples/Example221_StokesIterated2D/","page":"221 : Stokes iterated penalty method 2D","title":"221 : Stokes iterated penalty method 2D","text":"Here we solve the simple Hagen-Poiseuille flow on the two-dimensional unit square domain with the iterated penalty method for the Bernardi–Raugel finite element method. Given intermediate solutions  mathbfu_h and  p_h the next approximations are computed by the two equations","category":"page"},{"location":"examples/Example221_StokesIterated2D/","page":"221 : Stokes iterated penalty method 2D","title":"221 : Stokes iterated penalty method 2D","text":"beginaligned\n(nabla mathbfu_h^next nabla mathbfv_h) + ((mathbfu_h^next cdot nabla) mathbfu_h^next mathbfv_h) + lambda (mathrmdiv_h(mathbfu_h) mathrmdiv_h(mathbfv_h))  = (mathbffmathbfv_h) + (p_hmathrmdiv(mathbfv_h))\n textfor all  mathbfv_h in mathbfV_h\n(p^next_hq_h)  = (p_hq_h) - (mathrmdiv(mathbfu_h^next)q_h)  textfor all  q_h in Q_h\nendaligned","category":"page"},{"location":"examples/Example221_StokesIterated2D/","page":"221 : Stokes iterated penalty method 2D","title":"221 : Stokes iterated penalty method 2D","text":"This is done consecutively until the residual of both equations is small enough. The convection term is linearised by auto-differentiated Newton terms. The discrete divergence is computed via a RT0 reconstruction operator that preserves the disrete divergence. (another way would be to compute Binv(M)B' where M is the mass matrix of the pressure and B is the matrix for the div-pressure block).","category":"page"},{"location":"examples/Example221_StokesIterated2D/","page":"221 : Stokes iterated penalty method 2D","title":"221 : Stokes iterated penalty method 2D","text":"module Example221_StokesIterated2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing ExtendableSparse\nusing GridVisualize\n\n# data for Hagen-Poiseuille flow\nfunction exact_pressure!(μ)\n    function closure(result,x)\n        result[1] = μ*(-2*x[1]+1.0)\n    end\nend\nfunction exact_velocity!(result,x)\n    result[1] = x[2]*(1.0-x[2]);\n    result[2] = 0.0;\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, Plotter = nothing, λ = 1e4, μ = 1.0)\n\n    # set verbosity level\n    set_verbosity(verbosity)\n\n    # initial grid\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D),4)\n\n    # Bernardi--Raugel element\n    FETypes = [H1BR{2}, H1P0{1}]; PenaltyDivergence = ReconstructionDivergence{HDIVRT0{2}}\n\n    # FE spaces\n    FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid; broken = true)]\n\n    # negotiate data functions to the package\n    u = DataFunction(exact_velocity!, [2,2]; name = \"u\", dependencies = \"X\", quadorder = 2)\n    p = DataFunction(exact_pressure!(μ), [1,2]; name = \"p\", dependencies = \"X\", quadorder = 1)\n\n    # generate Stokes problem\n    Problem = PDEDescription(\"NSE (iterated penalty)\")\n    add_unknown!(Problem; equation_name = \"velocity update\", unknown_name = \"u\")\n    add_unknown!(Problem; equation_name = \"pressure update\", unknown_name = \"p\")\n    add_constraint!(Problem, FixedIntegralMean(2,0))\n\n    # add boundary data\n    add_boundarydata!(Problem, 1, [1,2,3,4], InterpolateDirichletBoundary; data = u)\n\n    # velocity update equation\n    add_operator!(Problem, [1,1], LaplaceOperator(μ; store = true))\n    add_operator!(Problem, [1,2], BilinearForm([Divergence, Identity]; name = \"(div(v),p)\", store = true, factor = -1))\n    add_operator!(Problem, [1,1], ConvectionOperator(1, Identity, 2, 2; auto_newton = true))\n\n    # add penalty for discrete divergence\n    add_operator!(Problem, [1,1], BilinearForm([PenaltyDivergence, PenaltyDivergence]; name = \"ϵ (div_h(u),div_h(v))\", store = true, factor = λ))\n\n    # pressure update equation\n    PressureMAMA = BilinearForm([Identity, Identity]; name = \"(p,q)\", store = true)\n    add_operator!(Problem, [2,1], BilinearForm([Identity, Divergence]; name = \"(q,div(u))\", store = true, factor = λ))\n    add_operator!(Problem, [2,2], PressureMAMA)\n    add_rhsdata!(Problem, 2, restrict_operator(PressureMAMA; fixed_arguments = [1], fixed_arguments_ids = [2]))\n\n    # show and solve problem\n    @show Problem\n    Solution = FEVector([\"u_h\",\"p_h\"],[FES[1],FES[2]])\n    solve!(Solution, Problem; subiterations = [[1],[2]], maxiterations = 20, show_solver_config = true)\n\n    # calculate L2 error\n    L2ErrorV = L2ErrorIntegrator(Float64, u, Identity)\n    L2ErrorP = L2ErrorIntegrator(Float64, p, Identity)\n    println(\"|| u - u_h || = $(sqrt(evaluate(L2ErrorV,Solution[1])))\")\n    println(\"|| p - p_h || = $(sqrt(evaluate(L2ErrorP,Solution[2])))\")\n\n    # plot\n    p = GridVisualizer(; Plotter = Plotter, layout = (1,2), clear = true, resolution = (1000,500))\n    scalarplot!(p[1,1],xgrid,view(nodevalues(Solution[1]; abs = true),1,:), levels = 3)\n    vectorplot!(p[1,1],xgrid,evaluate(PointEvaluator(Solution[1], Identity)), spacing = [0.25,0.1], clear = false, title = \"u_h (abs + quiver)\")\n    scalarplot!(p[1,2],xgrid,view(nodevalues(Solution[2]),1,:), levels = 11, title = \"p_h\")\nend\nend","category":"page"},{"location":"examples/Example221_StokesIterated2D/","page":"221 : Stokes iterated penalty method 2D","title":"221 : Stokes iterated penalty method 2D","text":"","category":"page"},{"location":"examples/Example221_StokesIterated2D/","page":"221 : Stokes iterated penalty method 2D","title":"221 : Stokes iterated penalty method 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example221_StokesIterated2D/","page":"221 : Stokes iterated penalty method 2D","title":"221 : Stokes iterated penalty method 2D","text":"Default output:","category":"page"},{"location":"examples/Example221_StokesIterated2D/","page":"221 : Stokes iterated penalty method 2D","title":"221 : Stokes iterated penalty method 2D","text":"julia> Example221_StokesIterated2D.main()\n\nPDE-DESCRIPTION\n===============\n  system name = NSE (iterated penalty)\n\n     id   | unknown name / equation name\n    [1]   | u / velocity update \n    [2]   | p / pressure update \n\n  LHS block | PDEOperator(s)\n    [1,1]   | (∇u,∇v) (APT = SymmetricBilinearForm, AT = ON_CELLS, regions = [0])\n            | ((id(u) ⋅ ∇) u, id(v)) [AD-Newton] [∂u] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n            | ϵ (div_h(u),div_h(v)) (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n    [1,2]   | (div(v),p) (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n    [2,1]   | (q,div(u)) (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n    [2,2]   | (p,q) (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n\n  RHS block | PDEOperator(s)\n     [1]    | ((id(u) ⋅ ∇) u, id(v)) [AD-Newton] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n     [2]    | (p,q) (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n\n   BoundaryOperator[1] : InterpolateDirichletBoundary -> [1, 2, 3, 4]\n                         \n   BoundaryOperator[2] : \n\n  GlobalConstraints[1] : Mean[2] != 0 \nProblem = \nSC = \nSOLVER-CONFIGURATION\n======================\n  overall nonlinear = true\n  overall timedependent = false\n  anderson_iterations = 0\n  subiterations = [[1], [2]]\n  show_iteration_details = true\n  timedependent_equations = Any[]\n  anderson_unknowns = [1]\n  show_statistics = false\n  anderson_metric = l2\n  skip_update = [1, 1]\n  linsolver = GradientRobustMultiPhysics.LinearSystem{Float64, Int64, LUFactorization{Float64, Int64}}\n  damping = 0\n  time = 0\n  show_solver_config = true\n  anderson_damping = 1\n  check_nonlinear_residual = true\n  fixed_penalty = 1.0e60\n  target_residual = 1.0e-10\n  maxiterations = 20\n  AssemblyTriggers = \n         LHS_AT[1] :  A  T \n         LHS_AT[2] :  T  I \n         RHS_AT[1] :  A \n         RHS_AT[2] :  A \n                     (I = Once, T = EachTimeStep/SubIteration, A = Always, N = Never)\n\n  LHS_dependencies = [[1] [1, 2]; [2, 1] [2]]\n\n\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 2.016865e-11 | 1.145706e-01\n\t      2   | 2.026354e-11 | 4.876621e-05\n\t      3   | 2.050388e-11 | 2.635037e-08\n\t      4   | 2.103826e-11 | 4.337964e-11\n\n|| u - u_h || = 0.00015826122829896215\n|| p - p_h || = 0.020919592761015873","category":"page"},{"location":"examples/Example221_StokesIterated2D/","page":"221 : Stokes iterated penalty method 2D","title":"221 : Stokes iterated penalty method 2D","text":"(Image: )","category":"page"},{"location":"examples/Example102_RobinBoundaryCondition1D/#:-Robin-Boundary-Conditions-1D","page":"102 : Robin-Boundary Conditions 1D","title":"102 : Robin-Boundary Conditions 1D","text":"","category":"section"},{"location":"examples/Example102_RobinBoundaryCondition1D/","page":"102 : Robin-Boundary Conditions 1D","title":"102 : Robin-Boundary Conditions 1D","text":"(source code)","category":"page"},{"location":"examples/Example102_RobinBoundaryCondition1D/","page":"102 : Robin-Boundary Conditions 1D","title":"102 : Robin-Boundary Conditions 1D","text":"This demonstrates the assignment of a mixed Robin boundary condition for a nonlinear 1D convection-diffusion-reaction PDE on the unit interval, i.e.","category":"page"},{"location":"examples/Example102_RobinBoundaryCondition1D/","page":"102 : Robin-Boundary Conditions 1D","title":"102 : Robin-Boundary Conditions 1D","text":"beginaligned\n-partial u  partial x^2 + u partial u  partial x + u  = f  textin  Omega\nu + partial u  partial_x  = g  textat  Gamma_1 =  0 \nu  = u_D  textat  Gamma_2 =  1 \nendaligned","category":"page"},{"location":"examples/Example102_RobinBoundaryCondition1D/","page":"102 : Robin-Boundary Conditions 1D","title":"102 : Robin-Boundary Conditions 1D","text":"tested with data f(x) = e^2x, g = 2 and u_D = e such that u(x) = e^x is the exact solution.","category":"page"},{"location":"examples/Example102_RobinBoundaryCondition1D/","page":"102 : Robin-Boundary Conditions 1D","title":"102 : Robin-Boundary Conditions 1D","text":"module Example102_RobinBoundaryCondition1D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# data and exact solution\nconst f = DataFunction((result,x) -> (result[1] = exp(2*x[1]);), [1,1]; name = \"f\", dependencies = \"X\", quadorder = 4)\nconst u = DataFunction((result,x) -> (result[1] = exp(x[1]);), [1,1]; name = \"u\", dependencies = \"X\", quadorder = 4)\nconst g = DataFunction([2]; name = \"g\")\nconst uD = DataFunction([exp(1)]; name = \"u_D\")\n\n# kernel for the (nonlinear) reaction-convection-diffusion oeprator\nfunction operator_kernel!(result, input)\n    # input = [u,∇u] as a vector of length 2\n    result[1] = input[1] * input[2] + input[1] # convection + reaction (will be multiplied with v)\n    result[2] = input[2]                       # diffusion (will be multiplied with ∇v)\n    return nothing\nend\n\n# kernel for Robin boundary condition\nfunction robin_kernel!(result, input)\n    # input = [u]\n    eval_data!(result,g)\n    result[1] -= input[1] # = g - u (will be multiplied with v)\n    return nothing\nend\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, verbosity = 0, h = 1e-1, h_fine = 1e-3)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # generate coarse and fine mesh\n    xgrid = simplexgrid(0:h:1)\n\n    # setup a problem description with one unknown\n    Problem = PDEDescription(\"reaction-convection-diffusion problem\")\n    add_unknown!(Problem; unknown_name = \"u\", equation_name = \"reaction-convection-diffusion equation\")\n\n    # add nonlinear operator\n    add_operator!(Problem, [1,1], NonlinearForm([OperatorPair{Identity, Gradient}], [1], OperatorPair{Identity, Gradient}, operator_kernel!, [2,2]; name = \"∇u ⋅ ∇v + (u ∇u + u) ⋅ v\", quadorder = 4, ADnewton = true) )\n\n    # right-hand side data\n    add_rhsdata!(Problem, 1, RhsOperator(Identity, [0], f))\n\n    # Robin boundary data right\n    add_operator!(Problem, [1,1], BilinearForm([Identity, Identity], Action(robin_kernel!, [1,1]); name = \"(g - u) ⋅ v\", AT = ON_BFACES, regions = [1]) )\n\n    # Dirichlet boundary data left\n    add_boundarydata!(Problem, 1, [2], InterpolateDirichletBoundary; data = uD)\n\n    # choose some finite element type and generate a FESpace for the grid\n    # (here it is a one-dimensional H1-conforming P2 element H1P2{1,1})\n    FEType = H1P2{1,1}\n    FES = FESpace{FEType}(xgrid)\n\n    # generate a solution vector and solve\n    Solution = FEVector(\"u_h\",FES)\n    solve!(Solution, Problem)\n\n    # compute L2 error\n    L2error = L2ErrorIntegrator(Float64,u)\n    println(\"L2error = $(sqrt(evaluate(L2error,Solution[1])))\")\n\n    # plot discrete and exact solution (on finer grid)\n    p=GridVisualizer(Plotter = Plotter, layout = (1,1))\n    scalarplot!(p[1,1], xgrid, nodevalues_view(Solution[1])[1], color=(0,0.7,0), label = \"u_h\", markershape = :x, markersize = 10, markevery = 1)\n    xgrid_fine = simplexgrid(0:h_fine:1)\n    scalarplot!(p[1,1], xgrid_fine, view(nodevalues(xgrid_fine,u),1,:), clear = false, color = (1,0,0), label = \"u\", legend = :best, markershape = :none)\nend\n\nend","category":"page"},{"location":"examples/Example102_RobinBoundaryCondition1D/","page":"102 : Robin-Boundary Conditions 1D","title":"102 : Robin-Boundary Conditions 1D","text":"","category":"page"},{"location":"examples/Example102_RobinBoundaryCondition1D/","page":"102 : Robin-Boundary Conditions 1D","title":"102 : Robin-Boundary Conditions 1D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example102_RobinBoundaryCondition1D/","page":"102 : Robin-Boundary Conditions 1D","title":"102 : Robin-Boundary Conditions 1D","text":"Default output:","category":"page"},{"location":"examples/Example102_RobinBoundaryCondition1D/","page":"102 : Robin-Boundary Conditions 1D","title":"102 : Robin-Boundary Conditions 1D","text":"julia> Example102_RobinBoundaryCondition1D.main()\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 6.164379e-14 | 6.400322e-01\n\t      2   | 6.323254e-14 | 5.344356e-02\n\t      3   | 5.493943e-14 | 4.413179e-05\n\t      4   | 6.373344e-14 | 4.726568e-11\n\nL2error = 1.0271403976005922e-5","category":"page"},{"location":"examples/Example102_RobinBoundaryCondition1D/","page":"102 : Robin-Boundary Conditions 1D","title":"102 : Robin-Boundary Conditions 1D","text":"(Image: )","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusionSUPG2D/#:-Reaction-Convection-Diffusion-Problem-SUPG-2D","page":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","title":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","text":"","category":"section"},{"location":"examples/Example203_ReactionConvectionDiffusionSUPG2D/","page":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","title":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","text":"(source code)","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusionSUPG2D/","page":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","title":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","text":"This example is almost similar to the last example (with the same number) and also computes the solution of some convection-diffusion problem","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusionSUPG2D/","page":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","title":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","text":"-nu Delta u + mathbfbeta cdot nabla u + alpha u = f quad textin  Omega","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusionSUPG2D/","page":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","title":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","text":"with some diffusion coefficient  nu, some vector-valued function  mathbfbeta, some scalar-valued function alpha and inhomogeneous Dirichlet boundary data.","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusionSUPG2D/","page":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","title":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","text":"We prescribe an analytic solution with mathbfbeta = (10) and alpha = 01 and check the L2 and H1 error convergence of the method on a series of uniformly refined meshes. We also compare with the error of a simple nodal interpolation and plot the solution and the norm of its gradient.","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusionSUPG2D/","page":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","title":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","text":"For small nu, the convection term dominates and pollutes the accuracy of the method. This time a SUPG stabilisation is added to improve things.","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusionSUPG2D/","page":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","title":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","text":"module Example203_ReactionConvectionDiffusionSUPG2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# coefficient functions\nconst β = DataFunction([1,0]; name = \"β\")\nconst α = DataFunction([0.1]; name = \"α\")\n\n# problem data and expected exact solution\nfunction exact_solution!(result,x)\n    result[1] = x[1]*x[2]*(x[1]-1)*(x[2]-1) + x[1]\nend\nfunction exact_solution_gradient!(result,x)\n    result[1] = x[2]*(2*x[1]-1)*(x[2]-1) + 1\n    result[2] = x[1]*(2*x[2]-1)*(x[1]-1)\nend\nfunction exact_solution_rhs!(ν)\n    eval_alpha = zeros(Float64,1)\n    eval_beta = zeros(Float64,2)\n    function closure(result,x)\n        # diffusion part\n        result[1] = -ν*(2*x[2]*(x[2]-1) + 2*x[1]*(x[1]-1))\n        # convection part (beta * grad(u))\n        eval_data!(eval_beta, β, x, 0)\n        result[1] += eval_beta[1] * (x[2]*(2*x[1]-1)*(x[2]-1) + 1)\n        result[1] += eval_beta[2] * (x[1]*(2*x[2]-1)*(x[1]-1))\n        # reaction part (alpha*u)\n        eval_data!(eval_alpha, α, x, 0)\n        result[1] += eval_alpha[1] * (x[1]*x[2]*(x[1]-1)*(x[2]-1) + x[1])\n        return nothing\n    end\nend\n\n# custom bilinearform that can assemble the full PDE operator\n#             ν(∇u,∇v) + (αu + β⋅∇u, v)\nfunction ReactionConvectionDiffusionOperator(α, β, ν)\n    eval_alpha = zeros(Float64,1)\n    eval_beta = zeros(Float64,2)\n    function action_kernel!(result, input,x)\n        # input = [u_h,∇u_h] as a vector of length 3\n        eval_data!(eval_beta, β, x, 0)\n        eval_data!(eval_alpha, α, x, 0)\n        result[1] = eval_alpha[1] * input[1] + eval_beta[1] * input[2] + eval_beta[2] * input[3]\n        result[2] = ν * input[2]\n        result[3] = ν * input[3]\n        # result will be multiplied with [v_h,∇v_h]\n        return nothing\n    end\n    action = Action(action_kernel!, [3,3]; dependencies = \"X\", quadorder = max(α.quadorder,β.quadorder))\n    return BilinearForm([OperatorPair{Identity,Gradient},OperatorPair{Identity,Gradient}], action; name = \"ν(∇u,∇v) + (αu + β⋅∇u, v)\", transposed_assembly = true)\nend\n\n# function that provides the SUPG left-hand side operator\n#       τ (h^2 (-ν Δu + αu + β⋅∇u), β⋅∇v)\nfunction SUPGOperator_LHS(α, β, ν, τ, xCellDiameters)\n    eval_alpha = zeros(Float64,1)\n    eval_beta = zeros(Float64,2)\n    function action_kernel!(result, input, x, item)\n        # input = [u_h,∇u_h,Δu_h] as a vector of length 4\n        eval_data!(eval_beta, β, x, 0)\n        eval_data!(eval_alpha, α, x, 0)\n        # compute residual -νΔu_h + (β⋅∇)u_h + αu_h\n        result[1] = - ν * input[4] + eval_alpha[1] * input[1] + eval_beta[1] * input[2] + eval_beta[2] * input[3]\n        # multiply stabilisation factor\n        result[1] *= τ * xCellDiameters[item]^2\n        # compute coefficients for ∇ eval of test function v_h\n        result[1] = result[1] * eval_beta[1]  # will be multiplied with ∇v_h[1]\n        result[2] = result[1] * eval_beta[2]  # will be multiplied with ∇v_h[2]\n        return nothing\n    end\n    action = Action(action_kernel!, [2,4]; dependencies = \"XI\", quadorder = max(α.quadorder,β.quadorder))\n    return BilinearForm([OperatorTriple{Identity,Gradient,Laplacian},Gradient], action; name = \"τ (h^2 (-ν Δu + αu + β⋅∇u), β⋅∇v)\", transposed_assembly = true)\nend\n\n# function that provides the SUPG right-hand side operator\n#                  τ (h^2 f, β⋅∇v)\nfunction SUPGOperator_RHS(f, β, τ, xCellDiameters)\n    eval_f = zeros(Float64,1)\n    eval_beta = zeros(Float64,2)\n    function action_kernel!(result, input, x, item)\n        # input = [v,∇v] as a vector of length 3\n        eval_data!(eval_beta, β, x, 0)\n        eval_data!(eval_f, f, x, 0)\n        # compute f times (β⋅∇)v_h\n        result[1] = eval_f[1] * (input[1] * eval_beta[1] + input[2] * eval_beta[2])\n        # multiply stabilisation factor\n        result[1] *= τ * xCellDiameters[item]^2\n        return nothing\n    end\n    action = Action(action_kernel!, [1,2]; dependencies = \"XI\", quadorder = max(f.quadorder,β.quadorder))\n    return RhsOperator(Gradient, action; name = \"τ (h^2 f, β⋅∇v)\")\nend\n\n# the SUPG stabilisation is weighted by powers of the cell diameter\n# so we need a function that computes them\nfunction getCellDiameters(xgrid)\n    xCellFaces = xgrid[CellFaces]\n    xFaceVolumes = xgrid[FaceVolumes]\n    xCellDiameters = zeros(Float64, num_sources(xCellFaces))\n    for cell = 1 : length(xCellDiameters)\n        xCellDiameters[cell] = maximum(xFaceVolumes[xCellFaces[:,cell]])\n    end\n    return xCellDiameters\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, Plotter = nothing, ν = 1e-5, τ = 10, nlevels = 5, order = 2)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # load initial mesh\n    xgrid = grid_unitsquare(Triangle2D)\n\n    # negotiate data functions to the package\n    u = DataFunction(exact_solution!, [1,2]; name = \"u\", dependencies = \"X\", quadorder = 4)\n    ∇u = DataFunction(exact_solution_gradient!, [2,2]; name = \"∇(u)\", dependencies = \"X\", quadorder = 3)\n    f = DataFunction(exact_solution_rhs!(ν), [1,2]; name = \"f\", dependencies = \"X\", quadorder = 5)\n\n    # set finite element type according to chosen order\n    FEType = H1Pk{1,2,order}\n\n    # create PDE description and assign operator and data\n    Problem = PDEDescription(\"reaction-convection-diffusion problem\")\n    add_unknown!(Problem; unknown_name = \"u\", equation_name = \"reaction-convection-diffusion equation\")\n    add_operator!(Problem, [1,1], ReactionConvectionDiffusionOperator(α,β,ν))\n    add_rhsdata!(Problem, 1, RhsOperator(Identity, [0], f))\n    add_boundarydata!(Problem, 1, [1,2,3,4], BestapproxDirichletBoundary; data = u)\n\n    # add SUPG stabilisation and remember operator positions\n    if τ > 0\n        xCellDiameters = getCellDiameters(xgrid)\n        supg_id = add_operator!(Problem, [1,1], SUPGOperator_LHS(α,β,ν,τ,xCellDiameters))\n        supg_id2 = add_rhsdata!(Problem, 1, SUPGOperator_RHS(f,β,τ,xCellDiameters))\n    end\n\n    # finally we have a look at the defined problem\n    @show Problem\n\n    # define ItemIntegrators for L2/H1 error computation and some arrays to store the errors\n    L2Error = L2ErrorIntegrator(Float64, u, Identity)\n    H1Error = L2ErrorIntegrator(Float64, ∇u, Gradient)\n    Results = zeros(Float64,nlevels,4); NDofs = zeros(Int,nlevels)\n\n    # refinement loop over levels\n    Solution = nothing\n    for level = 1 : nlevels\n        # uniform mesh refinement\n        xgrid = uniform_refine(xgrid)\n\n        # update SUPG operator (with updated CellDiameters)\n        if τ > 0\n            xCellDiameters = getCellDiameters(xgrid)\n            replace_operator!(Problem, [1,1], supg_id, SUPGOperator_LHS(α,β,ν,τ,xCellDiameters))\n            replace_rhsdata!(Problem, 1, supg_id2, SUPGOperator_RHS(f,β,τ,xCellDiameters))\n        end\n\n        # generate FESpace and solution vector\n        FES = FESpace{FEType}(xgrid)\n        Solution = FEVector(\"u_h\",FES)\n\n        # solve PDE\n        solve!(Solution, Problem)\n\n        # interpolate (just for comparison)\n        Interpolation = FEVector(\"I(u)\",FES)\n        interpolate!(Interpolation[1], u)\n\n        # compute L2 and H1 errors and save data\n        NDofs[level] = length(Solution.entries)\n        Results[level,1] = sqrt(evaluate(L2Error,Solution[1]))\n        Results[level,2] = sqrt(evaluate(L2Error,Interpolation[1]))\n        Results[level,3] = sqrt(evaluate(H1Error,Solution[1]))\n        Results[level,4] = sqrt(evaluate(H1Error,Interpolation[1]))\n    end\n\n    # plot\n    p=GridVisualizer(; Plotter = Plotter, layout = (1,2), clear = true, resolution = (1000,500))\n    scalarplot!(p[1,1], xgrid, view(nodevalues(Solution[1]),1,:), levels = 11, title = \"u_h\")\n    scalarplot!(p[1,2], xgrid, view(nodevalues(Solution[1], Gradient; abs = true),1,:), levels = 7)\n    vectorplot!(p[1,2], xgrid, evaluate(PointEvaluator(Solution[1], Gradient)), spacing = 0.1, clear = false, title = \"∇u_h (abs + quiver)\")\n\n    # print/plot convergence history\n    print_convergencehistory(NDofs, Results; X_to_h = X -> X.^(-1/2), ylabels = [\"|| u - u_h ||\", \"|| u - Iu ||\", \"|| ∇(u - u_h) ||\", \"|| ∇(u - Iu) ||\"])\n    plot_convergencehistory(NDofs, Results; add_h_powers = [2,3], X_to_h = X -> X.^(-1/2), Plotter = Plotter, ylabels = [\"|| u - u_h ||\", \"|| u - Iu ||\", \"|| ∇(u - u_h) ||\", \"|| ∇(u - Iu) ||\"])\nend\nend","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusionSUPG2D/","page":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","title":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","text":"","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusionSUPG2D/","page":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","title":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusionSUPG2D/","page":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","title":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","text":"Default output:","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusionSUPG2D/","page":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","title":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","text":"julia> Example203_ReactionConvectionDiffusionSUPG2D.main()\n\nPDE-DESCRIPTION\n===============\n  system name = reaction-convection-diffusion problem\n\n     id   | unknown name / equation name\n    [1]   | u / reaction-convection-diffusion equation \n\n  LHS block | PDEOperator(s)\n    [1,1]   | ν(∇u,∇v) + (αu + β⋅∇u, v) (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n            | τ (h^2 (-ν Δu + αu + β⋅∇u), β⋅∇v) (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n\n  RHS block | PDEOperator(s)\n     [1]    | (f, id(v)) (APT = LinearForm, AT = ON_CELLS, regions = [0])\n            | τ (h^2 f, β⋅∇v) (APT = LinearForm, AT = ON_CELLS, regions = [0])\n\n   BoundaryOperator[1] : BestapproxDirichletBoundary -> [1, 2, 3, 4]\n                         \n\nProblem = \n\n    ndofs   |    || u - u_h ||     order  |    || u - Iu ||      order  |  || ∇(u - u_h) ||    order  |   || ∇(u - Iu) ||    order  |\n============|=============================|=============================|=============================|=============================|\n        41  |     8.43750e-04      0.000  |     7.66225e-04      0.000  |     1.55036e-02      0.000  |     1.45087e-02      0.000  |\n       145  |     9.63421e-05      3.436  |     9.34178e-05      3.332  |     3.63888e-03      2.295  |     3.57540e-03      2.218  |\n       545  |     1.40275e-05      2.911  |     1.16023e-05      3.151  |     1.21755e-03      1.654  |     8.90584e-04      2.100  |\n      2113  |     1.83460e-06      3.002  |     1.44793e-06      3.072  |     3.43256e-04      1.869  |     2.22441e-04      2.047  |\n      8321  |     2.00826e-07      3.228  |     1.80918e-07      3.035  |     6.65448e-05      2.394  |     5.55975e-05      2.023  |","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusionSUPG2D/","page":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","title":"203 : Reaction-Convection-Diffusion-Problem SUPG 2D","text":"(Image: ) (Image: )","category":"page"},{"location":"meshing/#Meshing","page":"Meshing","title":"Meshing","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"Meshes are stored as an ExtendableGrid, see ExtendableGrids.jl for details and constructors. Grid generators for simplex grids can be found e.g. in the external module SimplexGridFactory.jl","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"Cells, faces and edges of the mesh are associated to AbstractElementGeometries (defined by ExtendableGrids.jl) that are used to dispatch functionality (local/global transformation, enumeration rules, set of basis functions, volume calculation, refinements etc.). See further below for a list of recognized element geometries.","category":"page"},{"location":"meshing/#Recognized-Geometries-and-Reference-Domains","page":"Meshing","title":"Recognized Geometries and Reference Domains","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"The following list contains all subtypes of ExtendableGrids.AbstractElementGeometries and their reference domains for which the package offers finite elements on them.","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Edge1D-:-AbstractElementGeometry1D","page":"Meshing","title":"Edge1D <: AbstractElementGeometry1D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[1]-----[2]               [1] = [0]\n                          [2] = [1]","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Triangle2D","page":"Meshing","title":"Triangle2D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[3]                 \n | \\   \n |   \\                    [1] = [0,0]\n |     \\                  [2] = [1,0]\n |       \\                [3] = [0,1]\n |         \\ \n[1]--------[2]","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Parallelogram2D-:-Quadrilateral2D","page":"Meshing","title":"Parallelogram2D <: Quadrilateral2D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[4]--------[3]               \n |          |             [1] = [0,0]\n |          |             [2] = [1,0]\n |          |             [3] = [1,1]\n |          |             [4] = [0,1]\n[1]--------[2]\n\nNote: most finite elements only work as intended on Parallelogram2D\n      since the local<>global map stays affine in this case","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Tetrahedron3D","page":"Meshing","title":"Tetrahedron3D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"[4]                 \n |\\\\   \n | \\ \\                    [1] = [0,0,0]\n |  \\  \\                  [2] = [1,0,0]\n |   \\   \\                [3] = [0,1,0]\n | _-[3]-_ \\              [4] = [0,0,1]\n[1]--------[2]","category":"page"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"","category":"page"},{"location":"meshing/#Parallelepiped3D-:-Hexahedron3D","page":"Meshing","title":"Parallelepiped3D <: Hexahedron3D","text":"","category":"section"},{"location":"meshing/","page":"Meshing","title":"Meshing","text":"    [8]--------[7]        [1] = [0,0,0]\n   / |        / |         [2] = [1,0,0]\n[5]--------[6]  |         [3] = [1,1,0]\n |   |      |   |         [4] = [0,1,0]\n |   |      |   |         [5] = [0,0,1]\n |  [4]-----|--[3]        [6] = [1,0,1]\n | /        | /           [7] = [1,1,1]\n[1]--------[2]            [8] = [0,1,1]\n\nNote: most finite elements only work as intended on Parallelepiped3D\n      since the local<>global map stays affine in this case","category":"page"},{"location":"export/#Data-Export","page":"Data Export","title":"Data Export","text":"","category":"section"},{"location":"export/","page":"Data Export","title":"Data Export","text":"Data export is possible into VTK (based on WriteVTK.jl) or CSV files.","category":"page"},{"location":"export/","page":"Data Export","title":"Data Export","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"dataexport.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"export/#GradientRobustMultiPhysics.writeCSV!-Tuple{String, Vector{<:FEVectorBlock}}","page":"Data Export","title":"GradientRobustMultiPhysics.writeCSV!","text":"writeCSV!(filename::String, Data::Vector{<:FEVectorBlock}; operators, names, seperator)\n\n\nWrites the specified FEVectorBlocks into a CSV datafile with the given filename. First d colomuns are the grid coordinates, the remaining columns are filled with the evaluations of the operators where operator[j] is applied to Data[j].\n\n\n\n\n\n","category":"method"},{"location":"export/#GradientRobustMultiPhysics.writeVTK!-Tuple{String, Vector{<:FEVectorBlock}}","page":"Data Export","title":"GradientRobustMultiPhysics.writeVTK!","text":"writeVTK!(filename::String, Data::Vector{<:FEVectorBlock}; xgrid, operators, names, vectorabs, add_regions, caplength)\n\n\nWrites the specified FEVector into a vtk datafile with the given filename. Each FEVectorBlock in the Data array is saved as separate VTKPointData. Vector-valued quantities also generate a data field that represents the absolute value of the vector field at each grid point (if vectorabs is true).\n\n\n\n\n\n","category":"method"},{"location":"examples/Example230_StokesHdivDG2D/#:-Stokes-Hdiv-DG-2D","page":"230 : Stokes Hdiv-DG 2D","title":"230 : Stokes Hdiv-DG 2D","text":"","category":"section"},{"location":"examples/Example230_StokesHdivDG2D/","page":"230 : Stokes Hdiv-DG 2D","title":"230 : Stokes Hdiv-DG 2D","text":"(source code)","category":"page"},{"location":"examples/Example230_StokesHdivDG2D/","page":"230 : Stokes Hdiv-DG 2D","title":"230 : Stokes Hdiv-DG 2D","text":"This example computes a velocity mathbfu and pressure mathbfp of the incompressible Navier–Stokes problem","category":"page"},{"location":"examples/Example230_StokesHdivDG2D/","page":"230 : Stokes Hdiv-DG 2D","title":"230 : Stokes Hdiv-DG 2D","text":"beginaligned\n- mu Delta mathbfu + nabla p  = mathbff\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"examples/Example230_StokesHdivDG2D/","page":"230 : Stokes Hdiv-DG 2D","title":"230 : Stokes Hdiv-DG 2D","text":"with exterior force mathbff and some μ parameter mu and inhomogeneous Dirichlet boundary data.","category":"page"},{"location":"examples/Example230_StokesHdivDG2D/","page":"230 : Stokes Hdiv-DG 2D","title":"230 : Stokes Hdiv-DG 2D","text":"The problem will be solved by a dicontinuous Galerkin method with Hdiv-conforming ansatz space (e.g. BDM1). The normal components of the velocity are fixed by the boundary data, while the tangential boundary fluxes are handled by the DG discretisation of the Laplacian that involves several discontinuous terms on faces mathcalF, i.e.","category":"page"},{"location":"examples/Example230_StokesHdivDG2D/","page":"230 : Stokes Hdiv-DG 2D","title":"230 : Stokes Hdiv-DG 2D","text":"beginaligned\na_h(u_hv_h) = mu Bigl( int nabla_h u_h  nabla_h v_h dx +  sum_F in mathcalF fraclambdah_F int_F u_h cdot v_h ds - int_F nabla_h u_h n_F cdot v_h ds\n - int_F u_h cdot nabla_h v_h n_F ds Bigr)\nendaligned","category":"page"},{"location":"examples/Example230_StokesHdivDG2D/","page":"230 : Stokes Hdiv-DG 2D","title":"230 : Stokes Hdiv-DG 2D","text":"and similar terms on the right-hand side for the inhomogeneous Dirichlet data. The qunatity λ is the SIP parameter.","category":"page"},{"location":"examples/Example230_StokesHdivDG2D/","page":"230 : Stokes Hdiv-DG 2D","title":"230 : Stokes Hdiv-DG 2D","text":"module Example230_StokesHdivDG2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# flow data for boundary condition, right-hand side and error calculation\nfunction get_flowdata(μ)\n    p! = (result,x,t) -> (result[1] = cos(t)*(sin(x[1])*cos(x[2]) + (cos(1) -1)*sin(1)))\n    u! = (result,x,t) -> (\n        result[1] = cos(t)*(sin(π*x[1]-0.7)*sin(π*x[2]+0.2));\n        result[2] = cos(t)*(cos(π*x[1]-0.7)*cos(π*x[2]+0.2)))\n    ∇u! = (result,x,t) -> (\n        result[1] = π*cos(t)*(cos(π*x[1]-0.7)*sin(π*x[2]+0.2));\n        result[2] = π*cos(t)*(sin(π*x[1]-0.7)*cos(π*x[2]+0.2));\n        result[3] = -result[2];\n        result[4] = -result[1])\n    f! = (result,x,t) -> (## f= -μΔu + ∇p\n        result[1] = 2*π*π*μ*cos(t)*(sin(π*x[1]-0.7)*sin(π*x[2]+0.2)) + cos(t)*cos(x[1])*cos(x[2]);\n        result[2] = 2*π*π*μ*cos(t)*(cos(π*x[1]-0.7)*cos(π*x[2]+0.2)) - cos(t)*sin(x[1])*sin(x[2]);)\n    u = DataFunction(u!, [2,2]; dependencies = \"XT\", name = \"u\", quadorder = 5)\n    p = DataFunction(p!, [1,2]; dependencies = \"XT\", name = \"p\", quadorder = 4)\n    ∇u = DataFunction(∇u!, [4,2]; dependencies = \"XT\", name = \"∇u\", quadorder = 4)\n    f = DataFunction(f!, [2,2]; dependencies = \"XT\", name = \"f\", quadorder = 5)\n    return u, p, ∇u, f\nend\n\n# everything is wrapped in a main function\nfunction main(; μ = 1e-3, nlevels = 5, Plotter = nothing, verbosity = 0, T = 1, λ = 4)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # FEType (Hdiv-conforming)\n    FETypes = [HDIVBDM1{2}, H1P0{1}]\n\n    # initial grid\n    xgrid = grid_unitsquare(Triangle2D)\n    xBFaceFaces::Array{Int,1} = xgrid[BFaceFaces]\n    xFaceVolumes::Array{Float64,1} = xgrid[FaceVolumes]\n    xFaceNormals::Array{Float64,2} = xgrid[FaceNormals]\n\n    # load exact flow data\n    u,p,∇u,f = get_flowdata(μ)\n\n    # prepare error calculation\n    L2VelocityErrorEvaluator = L2ErrorIntegrator(Float64, u, Identity; time = T)\n    L2PressureErrorEvaluator = L2ErrorIntegrator(Float64, p, Identity; time = T)\n    H1VelocityErrorEvaluator = L2ErrorIntegrator(Float64, ∇u, Gradient; time = T)\n\n    # load Stokes problem prototype and assign data\n    Problem = IncompressibleNavierStokesProblem(2; viscosity = μ, nonlinear = false)\n    add_rhsdata!(Problem, 1, RhsOperator(Identity, [1], f))\n\n    # add boundary data (fixes normal components of along boundary)\n    add_boundarydata!(Problem, 1, [1,2,3,4], BestapproxDirichletBoundary; data = u)\n\n    # define additional operators for DG terms for Laplacian and Dirichlet data\n    # (in order of their appearance in the documentation above)\n    hdiv_laplace2_kernel = (result, input, item) -> (result .= input / xFaceVolumes[item])\n    function hdiv_laplace3_kernel(result, input, item)\n        for j = 1 : 2, k = 1 : 2\n            result[(j-1)*2+k] = input[j] * xFaceNormals[k,item]\n        end\n        return nothing\n    end\n    function hdiv_laplace4_kernel(result, input, item)\n        result[1] = input[1] * xFaceNormals[1,item] + input[2] * xFaceNormals[2,item]\n        result[2] = input[3] * xFaceNormals[1,item] + input[4] * xFaceNormals[2,item]\n        return nothing\n    end\n    HdivLaplace2 = BilinearForm([Jump(Identity), Jump(Identity)], Action( hdiv_laplace2_kernel, [2,2]; dependencies = \"I\", quadorder = 0); name = \"μ/h_F [u] [v]\", factor = λ*μ, AT = ON_FACES)\n    HdivLaplace3 = BilinearForm([Jump(Identity), Average(Gradient)], Action( hdiv_laplace3_kernel, [4,2]; dependencies = \"I\", quadorder = 0); name = \"-μ [u] {grad(v)*n}\", factor = -μ, AT = ON_FACES)\n    HdivLaplace4 = BilinearForm([Average(Gradient), Jump(Identity)], Action( hdiv_laplace4_kernel, [2,4]; dependencies = \"I\", quadorder = 0); name = \"-μ {grad(u)*n} [v] \", factor = -μ, AT = ON_FACES)\n\n    # additional terms for tangential part at boundary\n    # note: we use average operators here to force evaluation of all basis functions and not only of the face basis functions\n    # (which in case of Hdiv would be only the ones with nonzero normal fluxes)\n    veloeval = zeros(Float64,2)\n    function hdiv_boundary_kernel(result, input, x, t, item)\n        eval_data!(veloeval, u, x, t)\n        result[1] = (input[1] * veloeval[1] + input[2] * veloeval[2]) / xFaceVolumes[xBFaceFaces[item]]\n        return nothing\n    end\n    function hdiv_boundary_kernel2(result, input, x, t, item)\n        eval_data!(veloeval, u, x, t)\n        result[1] = (input[1] * xFaceNormals[1,xBFaceFaces[item]] + input[2] * xFaceNormals[2,xBFaceFaces[item]]) * veloeval[1]\n        result[1] += (input[3] * xFaceNormals[1,xBFaceFaces[item]] + input[4] * xFaceNormals[2,xBFaceFaces[item]]) * veloeval[2]\n        return nothing\n    end\n    HdivBoundary1 = RhsOperator(Average(Identity), Action( hdiv_boundary_kernel, [1,2]; dependencies = \"XTI\", quadorder = u.quadorder); name = \"- μ λ/h_F u_D v\", factor = λ*μ, AT = ON_BFACES)\n    HdivBoundary2 = RhsOperator(Average(Gradient), Action( hdiv_boundary_kernel2, [1,4]; dependencies = \"XTI\", quadorder = u.quadorder); name = \"- μ u_D grad(v)*n\", factor = -μ, AT = ON_BFACES)\n\n    # assign DG operators to problem descriptions\n    add_operator!(Problem, [1,1], HdivLaplace2)\n    add_operator!(Problem, [1,1], HdivLaplace3)\n    add_operator!(Problem, [1,1], HdivLaplace4)\n    add_rhsdata!(Problem, 1, HdivBoundary1)\n    add_rhsdata!(Problem, 1, HdivBoundary2)\n\n    # show final problem description\n    @show Problem\n\n    # loop over levels\n    Results = zeros(Float64,nlevels,3); NDofs = zeros(Int,nlevels)\n    Solution = nothing\n    for level = 1 : nlevels\n\n        # refine grid and update grid component references\n        xgrid = uniform_refine(xgrid)\n        xBFaceFaces = xgrid[BFaceFaces]\n        xFaceVolumes = xgrid[FaceVolumes]\n        xFaceNormals = xgrid[FaceNormals]\n\n        # generate FES spaces and solution vector\n        FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid)]\n        Solution = FEVector([\"u_h\", \"p_h\"],FES)\n\n        # solve\n        solve!(Solution, Problem; time = T)\n\n        # compute L2 and H1 errors and save data\n        NDofs[level] = length(Solution.entries)\n        Results[level,1] = sqrt(evaluate(L2VelocityErrorEvaluator,Solution[1]))\n        Results[level,2] = sqrt(evaluate(L2PressureErrorEvaluator,Solution[2]))\n        Results[level,3] = sqrt(evaluate(H1VelocityErrorEvaluator,Solution[1]))\n    end\n\n    # plot\n    p = GridVisualizer(; Plotter = Plotter, layout = (1,2), clear = true, resolution = (1000,500))\n    scalarplot!(p[1,1],xgrid,view(nodevalues(Solution[1]; abs = true),1,:), levels = 3)\n    vectorplot!(p[1,1],xgrid,evaluate(PointEvaluator(Solution[1], Identity)), spacing = 0.05, clear = false, title = \"u_h (abs + quiver)\")\n    scalarplot!(p[1,2],xgrid,view(nodevalues(Solution[2]),1,:), levels = 11, title = \"p_h\")\n\n    # print/show convergence history\n    print_convergencehistory(NDofs, Results; X_to_h = X -> X.^(-1/2), ylabels = [\"|| u - u_h ||\", \"|| p - p_h ||\", \"|| ∇(u - u_h) ||\"])\n    plot_convergencehistory(NDofs, Results; add_h_powers = [1,2], X_to_h = X -> X.^(-1/2), Plotter = Plotter, ylabels = [\"|| u - u_h ||\", \"|| p - p_h ||\", \"|| ∇(u - u_h) ||\"])\nend\nend","category":"page"},{"location":"examples/Example230_StokesHdivDG2D/","page":"230 : Stokes Hdiv-DG 2D","title":"230 : Stokes Hdiv-DG 2D","text":"","category":"page"},{"location":"examples/Example230_StokesHdivDG2D/","page":"230 : Stokes Hdiv-DG 2D","title":"230 : Stokes Hdiv-DG 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example230_StokesHdivDG2D/","page":"230 : Stokes Hdiv-DG 2D","title":"230 : Stokes Hdiv-DG 2D","text":"Default output:","category":"page"},{"location":"examples/Example230_StokesHdivDG2D/","page":"230 : Stokes Hdiv-DG 2D","title":"230 : Stokes Hdiv-DG 2D","text":"julia> Example230_StokesHdivDG2D.main()\n\nPDE-DESCRIPTION\n===============\n  system name = incompressible Stokes-Problem\n\n     id   | unknown name / equation name\n    [1]   | u / momentum equation \n    [2]   | p / incompressibility constraint \n\n  LHS block | PDEOperator(s)\n    [1,1]   | 0.001 (∇u,∇v) (APT = SymmetricBilinearForm, AT = ON_CELLS, regions = [0])\n            | μ/h_F [u] [v] (APT = BilinearForm, AT = ON_FACES, regions = [0])\n            | -μ [u] {grad(v)*n} (APT = BilinearForm, AT = ON_FACES, regions = [0])\n            | -μ {grad(u)*n} [v]  (APT = BilinearForm, AT = ON_FACES, regions = [0])\n    [1,2]   | (div(v),q) (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n    [2,1]   | none\n    [2,2]   | none\n\n  RHS block | PDEOperator(s)\n     [1]    | (f, id(v)) (APT = LinearForm, AT = ON_CELLS, regions = [1])\n            | - μ λ/h_F u_D v (APT = LinearForm, AT = ON_BFACES, regions = [0])\n            | - μ u_D grad(v)*n (APT = LinearForm, AT = ON_BFACES, regions = [0])\n     [2]    | none\n\n   BoundaryOperator[1] : BestapproxDirichletBoundary -> [1, 2, 3, 4]\n                         \n   BoundaryOperator[2] : \n\n  GlobalConstraints[1] : Mean[2] != 0 \nProblem = \n\n    ndofs   |    || u - u_h ||     order  |    || p - p_h ||     order  |  || ∇(u - u_h) ||    order  |\n============|=============================|=============================|=============================|\n        72  |     1.02863e-01      0.000  |     3.49020e-02      0.000  |     1.49484e+00      0.000  |\n       272  |     1.11840e-02      3.339  |     1.74718e-02      1.041  |     3.90996e-01      2.018  |\n      1056  |     2.73673e-03      2.076  |     8.74172e-03      1.021  |     1.93586e-01      1.036  |\n      4160  |     6.80881e-04      2.029  |     4.37158e-03      1.011  |     9.61205e-02      1.021  |\n     16512  |     1.71156e-04      2.003  |     2.18588e-03      1.006  |     4.80277e-02      1.007  |","category":"page"},{"location":"examples/Example230_StokesHdivDG2D/","page":"230 : Stokes Hdiv-DG 2D","title":"230 : Stokes Hdiv-DG 2D","text":"(Image: ) (Image: )","category":"page"},{"location":"interpolations/#Finite-Element-Interpolations","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"","category":"section"},{"location":"interpolations/#Standard-Interpolations","page":"Finite Element Interpolations","title":"Standard Interpolations","text":"","category":"section"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"Each finite element has its standard interpolator that can be applied to some user-defined DataFunction. Instead of interpolating on the full cells, the interpolation can be restricted to faces or edges, by specifying an Assembly Type in the call. ","category":"page"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"It is also possible to interpolate finite element functions on one grid onto a finite element function on another grid (experimental feature, does not work for all finite elements yet and shall be extended to interpolations of operator evaluations as well in future).","category":"page"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"interpolate!","category":"page"},{"location":"interpolations/#GradientRobustMultiPhysics.interpolate!","page":"Finite Element Interpolations","title":"GradientRobustMultiPhysics.interpolate!","text":"function interpolate!(target::FEVectorBlock,\n     AT::Type{<:AssemblyType},\n     source::UserData{AbstractDataFunction};\n     items = [],\n     time = 0)\n\nInterpolates the given source into the finite elements space assigned to the target FEVectorBlock with the specified AssemblyType (usualy ON_CELLS). The optional time argument is only used if the source depends on time.\n\n\n\n\n\nfunction interpolate!(target::FEVectorBlock,\n     source::UserData{AbstractDataFunction};\n     items = [],\n     time = 0)\n\nInterpolates the given source into the finite element space assigned to the target FEVectorBlock. The optional time argument is only used if the source depends on time.\n\n\n\n\n\nfunction interpolate!(\n    target::FEVectorBlock{T1,Tv,Ti},\n    source::FEVectorBlock{T2,Tv,Ti};\n    operator = Identity,\n    postprocess = NoAction(),\n    xtrafo = nothing,\n    items = [],\n    not_in_domain_value = 1e30,\n    use_cellparents::Bool = false) where {T1,T2,Tv,Ti}\n\nInterpolates (operator-evaluations of) the given finite element function into the finite element space assigned to the target FEVectorBlock.  (Currently not the most efficient way as it is based on the PointEvaluation pattern and cell search. If CellParents are available in the grid components of the target grid, these parent cell information can be used to improve the search. To activate this put 'use_cellparents' = true). By some action with kernel (result,input) the operator evaluation (=input) can be further postprocessed (done by the called point evaluator).\n\nNote: discontinuous quantities at vertices of the target grid will be evaluted in the first found cell of the source grid. No averaging is performed.\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#Nodal-Evaluations","page":"Finite Element Interpolations","title":"Nodal Evaluations","text":"","category":"section"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"Usually, Plotters need nodal values, so there is a gengeric function that evaluates any finite element function at the nodes of the grids (possibly by averaging if discontinuous). In case of Identity evaluations of an H1-conforming finite element, the function nodevalues_view can generate a view into the coefficient field that avoids further allocations.","category":"page"},{"location":"interpolations/","page":"Finite Element Interpolations","title":"Finite Element Interpolations","text":"nodevalues!\nnodevalues\nnodevalues_view","category":"page"},{"location":"interpolations/#GradientRobustMultiPhysics.nodevalues!","page":"Finite Element Interpolations","title":"GradientRobustMultiPhysics.nodevalues!","text":"function nodevalues!(\n    target::AbstractArray{<:Real,2},\n    source::AbstractArray{T,1},\n    FE::FESpace{Tv,Ti,FEType,AT},\n    operator::Type{<:AbstractFunctionOperator} = Identity;\n    regions::Array{Int,1} = [0],\n    abs::Bool = false,\n    factor = 1,\n    target_offset::Int = 0,   # start to write into target after offset\n    zero_target::Bool = true, # target vector is zeroed\n    continuous::Bool = false)\n\nEvaluates the finite element function with the coefficient vector source (interpreted as a coefficient vector for the FESpace FE) and the specified FunctionOperator at all the nodes of the (specified regions of the) grid and writes the values into target. Discontinuous (continuous = false) quantities are averaged.\n\n\n\n\n\nfunction nodevalues!(\n    target::AbstractArray{<:Real,2},\n    source::FEVectorBlock,\n    operator::Type{<:AbstractFunctionOperator} = Identity;\n    regions::Array{Int,1} = [0],\n    abs::Bool = false,\n    factor = 1,\n    target_offset::Int = 0,   # start to write into target after offset\n    zero_target::Bool = true, # target vector is zeroed\n    continuous::Bool = false)\n\nEvaluates the finite element function with the coefficient vector source and the specified FunctionOperator at all the nodes of the (specified regions of the) grid and writes the values into target. Discontinuous (continuous = false) quantities are averaged.\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#GradientRobustMultiPhysics.nodevalues","page":"Finite Element Interpolations","title":"GradientRobustMultiPhysics.nodevalues","text":"function nodevalues(nodevals, xgrid::ExtendableGrid{Tv,Ti}, UD::UserData; time = 0) where {Tv,Ti}\n\nReturns a 2D array with the node values of the data function for the given grid.\n\n\n\n\n\nfunction nodevalues(\n    source::FEVectorBlock,\n    operator::Type{<:AbstractFunctionOperator} = Identity;\n    regions::Array{Int,1} = [0],\n    abs::Bool = false,\n    factor = 1,\n    target_offset::Int = 0,   # start to write into target after offset\n    zero_target::Bool = true, # target vector is zeroed\n    continuous::Bool = false)\n\nEvaluates the finite element function with the coefficient vector source and the specified FunctionOperator at all the nodes of the (specified regions of the) grid and returns an array with the values. Discontinuous (continuous = false) quantities are averaged.\n\n\n\n\n\n","category":"function"},{"location":"interpolations/#GradientRobustMultiPhysics.nodevalues_view","page":"Finite Element Interpolations","title":"GradientRobustMultiPhysics.nodevalues_view","text":"function nodevalues_view(\n    source::FEVectorBlock,\n    operator::Type{<:AbstractFunctionOperator} = Identity)\n\nReturns a vector of views of the nodal values of the source block (currently works for unbroken H1-conforming elements) that directly accesses the coefficients.\n\n\n\n\n\n","category":"function"},{"location":"examples/Example209_FaceLagrangeMultiplier2D/#:-Lagrange-Multiplier-on-Faces","page":"209 : Lagrange Multiplier on Faces","title":"209 : Lagrange Multiplier on Faces","text":"","category":"section"},{"location":"examples/Example209_FaceLagrangeMultiplier2D/","page":"209 : Lagrange Multiplier on Faces","title":"209 : Lagrange Multiplier on Faces","text":"(source code)","category":"page"},{"location":"examples/Example209_FaceLagrangeMultiplier2D/","page":"209 : Lagrange Multiplier on Faces","title":"209 : Lagrange Multiplier on Faces","text":"This code demonstrates the novel feature of finite element spaces on faces by providing AT = ON_FACES in the finite element space constructor. It is used here to solve a bestapproximation into an Hdiv-conforming space by using a broken Hdiv space and setting the normal jumps on interior faces to zero by using a Lagrange multiplier on the faces of the grid (a broken H1-conforming space). Then the solution is compared to the solution of the same problem using the continuous Hdiv-conforming space.","category":"page"},{"location":"examples/Example209_FaceLagrangeMultiplier2D/","page":"209 : Lagrange Multiplier on Faces","title":"209 : Lagrange Multiplier on Faces","text":"module Example209_FaceLagrangeMultiplier2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# problem data\nfunction exact_function!(result,x::Array{<:Real,1})\n    result[1] = x[1]^3+x[2]\n    result[2] = x[2] + 1\n    return nothing\nend\nconst u = DataFunction(exact_function!, [2,2]; name = \"u\", dependencies = \"X\", quadorder = 3)\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, verbosity = 0)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # choose initial mesh\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D),3)\n\n    # define bestapproximation problem\n    Problem = L2BestapproximationProblem(u; name = \"constrained L2-bestapproximation problem\", bestapprox_boundary_regions = [])\n\n    # we want to use a broken space and constrain the normal jumps on interior faces\n    # in form of a Lagrange multiplier which needs an additional unknown\n    add_unknown!(Problem; unknown_name = \"LM face jumps\", equation_name = \"face jump constraint\")\n    add_operator!(Problem, [1,2], LagrangeMultiplier(NormalFluxDisc{Jump}; AT = ON_IFACES))\n    # the diagonal operator sets the Lagrange multiplier on all boundary face regions to zero\n    add_operator!(Problem, [2,2], DiagonalOperator(1; regions = [1,2,3,4]))\n\n    # choose some (inf-sup stable) finite element types\n    # first space is the Hdiv element that lives ON_CELLS\n    # second will be used for the Lagrange multiplier space that lives ON_FACES\n    FEType = [HDIVRT1{2}, H1P1{1}]\n    FES = [FESpace{FEType[1], ON_CELLS}(xgrid; broken = true),FESpace{FEType[2], ON_FACES}(xgrid; broken = true)]\n\n    # solve\n    Solution = FEVector([\"u_h (Hdiv-broken)\", \"LM face jumps\"],FES)\n    solve!(Solution, Problem)\n\n    # solve again with the (unbroken) Hdiv-continuous element to test that we get the same result\n    # note: for an FESpace living ON_CELLS and broken = false is the default\n    Problem = L2BestapproximationProblem(u; bestapprox_boundary_regions = [])\n    Solution2 = FEVector(\"u_h (Hdiv-cont.)\",FESpace{FEType[1]}(xgrid))\n    solve!(Solution2, Problem)\n\n    # calculate L2 error of both solutions and their difference\n    L2Error = L2ErrorIntegrator(Float64, u, Identity)\n    L2Diff = L2DifferenceIntegrator(Float64, 2, Identity)\n    println(\"\\tL2error(Hdiv-broken) = $(sqrt(evaluate(L2Error,Solution[1])))\")\n    println(\"\\tL2error(Hdiv-cont.) = $(sqrt(evaluate(L2Error,Solution2[1])))\")\n    println(\"\\tL2error(difference) = $(sqrt(evaluate(L2Diff,[Solution[1], Solution2[1]])))\")\n\n    # plot both solutions\n    p = GridVisualizer(; Plotter = Plotter, layout = (1,2), clear = true, resolution = (1000,500))\n    scalarplot!(p[1,1],xgrid,view(nodevalues(Solution[1]; abs = true),1,:), levels = 7)\n    vectorplot!(p[1,1],xgrid,evaluate(PointEvaluator(Solution[1], Identity)), spacing = 0.1, clear = false, title = \"u_1 (abs + quiver)\")\n    scalarplot!(p[1,2],xgrid,view(nodevalues(Solution2[1]; abs = true),1,:), levels = 7)\n    vectorplot!(p[1,2],xgrid,evaluate(PointEvaluator(Solution2[1], Identity)), spacing = 0.1, clear = false, title = \"u_2 (abs + quiver)\")\n\nend\nend","category":"page"},{"location":"examples/Example209_FaceLagrangeMultiplier2D/","page":"209 : Lagrange Multiplier on Faces","title":"209 : Lagrange Multiplier on Faces","text":"","category":"page"},{"location":"examples/Example209_FaceLagrangeMultiplier2D/","page":"209 : Lagrange Multiplier on Faces","title":"209 : Lagrange Multiplier on Faces","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example209_FaceLagrangeMultiplier2D/","page":"209 : Lagrange Multiplier on Faces","title":"209 : Lagrange Multiplier on Faces","text":"Default output:","category":"page"},{"location":"examples/Example209_FaceLagrangeMultiplier2D/","page":"209 : Lagrange Multiplier on Faces","title":"209 : Lagrange Multiplier on Faces","text":"julia> Example209_FaceLagrangeMultiplier2D.main()\n\tL2error(Hdiv-broken) = 0.0004715248381994802\n\tL2error(Hdiv-cont.) = 0.00047152483819947583\n\tL2error(difference) = 5.637129750411271e-16","category":"page"},{"location":"examples/Example209_FaceLagrangeMultiplier2D/","page":"209 : Lagrange Multiplier on Faces","title":"209 : Lagrange Multiplier on Faces","text":"(Image: )","category":"page"},{"location":"examples/ExampleA07_InterpolationBetweenMeshes/#A07-:-Interpolation-Between-Meshes","page":"A07 : Interpolation Between Meshes","title":"A07 : Interpolation Between Meshes","text":"","category":"section"},{"location":"examples/ExampleA07_InterpolationBetweenMeshes/","page":"A07 : Interpolation Between Meshes","title":"A07 : Interpolation Between Meshes","text":"(source code)","category":"page"},{"location":"examples/ExampleA07_InterpolationBetweenMeshes/","page":"A07 : Interpolation Between Meshes","title":"A07 : Interpolation Between Meshes","text":"This example demonstrates the interpolation between meshes feature. Here, we interpolate a function withe the P2 element of a coarse triangulation and then interpolate this P2 function on two uniform refinements into some P1 function. Then, both finite element functions are plotted.","category":"page"},{"location":"examples/ExampleA07_InterpolationBetweenMeshes/","page":"A07 : Interpolation Between Meshes","title":"A07 : Interpolation Between Meshes","text":"module ExampleA07_InterpolationBetweenMeshes\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# function to interpolate\nfunction data!(ν)\n    function closure(result,x)\n        result[1] = sin(4*pi*x[1])*sin(4*pi*x[2]);\n        result[2] = cos(4*pi*x[1])*cos(4*pi*x[2]);\n    end\nend\n\n# everything is wrapped in a main function\nfunction main(; ν = 1e-3, nrefinements = 4, verbosity = 0, Plotter = nothing)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # generate two grids\n    xgrid1 = uniform_refine(grid_unitsquare(Triangle2D),nrefinements)\n    xgrid2 = uniform_refine(xgrid1,2; store_parents = true)\n\n    # negotiate data\n    u = DataFunction(data!(ν), [2,2]; name = \"u\", dependencies = \"X\", quadorder = 6)\n\n    # set finite element types for the two grids\n    FEType1 = H1P2{2,2}\n    FEType2 = H1P1{2}\n\n    # generate coressponding finite element spaces and FEVectors\n    FES1 = FESpace{FEType1}(xgrid1)\n    FES2 = FESpace{FEType2}(xgrid2)\n    FEFunction1 = FEVector(\"$FEType1 on grid 1\",FES1)\n    FEFunction2 = FEVector(\"$FEType2 on grid 2\",FES2)\n\n    # interpolate function onto first grid\n    interpolate!(FEFunction1[1], u)\n\n    # interpolate onto other grids\n    @time interpolate!(FEFunction2[1], FEFunction1[1])\n    @time interpolate!(FEFunction2[1], FEFunction1[1], use_cellparents = true)\n\n    # plot\n    p = GridVisualizer(; Plotter = Plotter, layout = (1,2), clear = true, resolution = (1000,500))\n    scalarplot!(p[1,1], xgrid1, view(nodevalues(FEFunction1[1]),1,:), levels = 11, title = \"u_h (coarse grid)\")\n    scalarplot!(p[1,2], xgrid2, view(nodevalues(FEFunction2[1]),1,:), levels = 11, title = \"u_h (fine grid)\")\nend\n\nend","category":"page"},{"location":"examples/ExampleA07_InterpolationBetweenMeshes/","page":"A07 : Interpolation Between Meshes","title":"A07 : Interpolation Between Meshes","text":"","category":"page"},{"location":"examples/ExampleA07_InterpolationBetweenMeshes/","page":"A07 : Interpolation Between Meshes","title":"A07 : Interpolation Between Meshes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/ExampleA07_InterpolationBetweenMeshes/","page":"A07 : Interpolation Between Meshes","title":"A07 : Interpolation Between Meshes","text":"Default output:","category":"page"},{"location":"examples/ExampleA07_InterpolationBetweenMeshes/","page":"A07 : Interpolation Between Meshes","title":"A07 : Interpolation Between Meshes","text":"julia> ExampleA07_InterpolationBetweenMeshes.main()\n  1.157180 seconds (1.44 M allocations: 80.211 MiB, 3.22% gc time, 97.89% compilation time)\n  0.619249 seconds (590.38 k allocations: 26.447 MiB, 5.26% gc time, 90.93% compilation time)","category":"page"},{"location":"examples/ExampleA07_InterpolationBetweenMeshes/","page":"A07 : Interpolation Between Meshes","title":"A07 : Interpolation Between Meshes","text":"(Image: )","category":"page"},{"location":"examples/Example301_Poisson3D/#:-Poisson-Problem-3D","page":"301 : Poisson-Problem 3D","title":"301 : Poisson-Problem 3D","text":"","category":"section"},{"location":"examples/Example301_Poisson3D/","page":"301 : Poisson-Problem 3D","title":"301 : Poisson-Problem 3D","text":"(source code)","category":"page"},{"location":"examples/Example301_Poisson3D/","page":"301 : Poisson-Problem 3D","title":"301 : Poisson-Problem 3D","text":"This example computes the solution u of the three dimensional Poisson problem","category":"page"},{"location":"examples/Example301_Poisson3D/","page":"301 : Poisson-Problem 3D","title":"301 : Poisson-Problem 3D","text":"beginaligned\n-Delta u  = f quad textin  Omega\nendaligned","category":"page"},{"location":"examples/Example301_Poisson3D/","page":"301 : Poisson-Problem 3D","title":"301 : Poisson-Problem 3D","text":"with some right-hand side f on the unit cube domain Omega on a series of uniform refined meshes (tetrahedra or parallelepipeds).","category":"page"},{"location":"examples/Example301_Poisson3D/","page":"301 : Poisson-Problem 3D","title":"301 : Poisson-Problem 3D","text":"module Example301_Poisson3D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# problem data\nfunction exact_function!(result,x)\n    result[1] = x[1]*(x[3] - x[2]) + x[2]*x[2]\n    return nothing\nend\nfunction exact_gradient!(result,x)\n    result[1] = x[3] - x[2]\n    result[2] = - x[1] + 2*x[2]\n    result[3] = x[1]\n    return nothing\nend\n\n# negotiate data functions to the package\nconst u = DataFunction(exact_function!, [1,3]; name = \"u\", dependencies = \"X\", quadorder = 2)\nconst ∇u = DataFunction(exact_gradient!, [3,3]; name = \"∇(u)\", dependencies = \"X\", quadorder = 1)\nconst f = DataFunction([-2]; name = \"f\") # = -Δu = -2\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, verbosity = 0, nlevels = 4)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # choose initial mesh\n    # (replace Parallelepiped3D by Tetrahedron3D to change the cell geometries)\n    xgrid = grid_unitcube(Tetrahedron3D)\n\n    # set finite element type used for discretisation\n    FEType = H1P1{1}\n\n    # create Poisson problem via prototype and add data\n    Problem = PoissonProblem(1.0)\n    add_boundarydata!(Problem, 1, [1,2,3,4,5,6], BestapproxDirichletBoundary; data = u)\n    add_rhsdata!(Problem, 1, RhsOperator(Identity, [0], f))\n\n    # prepare error calculation\n    L2Error = L2ErrorIntegrator(Float64, u)\n    H1Error = L2ErrorIntegrator(Float64, ∇u, Gradient)\n    Results = zeros(Float64, nlevels, 2); NDofs = zeros(Int, nlevels)\n\n    # loop over levels\n    Solution = nothing\n    for level = 1 : nlevels\n        # uniform mesh refinement\n        xgrid = uniform_refine(xgrid)\n\n        # create finite element space and solution vector\n        FES = FESpace{FEType}(xgrid)\n        Solution = FEVector(\"u_h\",FES)\n\n        # solve the problem\n        solve!(Solution, Problem)\n\n        # calculate L2 and H1 errors and save data\n        NDofs[level] = length(Solution.entries)\n        Results[level,1] = sqrt(evaluate(L2Error,Solution[1]))\n        Results[level,2] = sqrt(evaluate(H1Error,Solution[1]))\n    end\n\n    # plot (Plotter = GLMakie should work)\n    p = GridVisualizer(; Plotter = Plotter, layout = (1,1), clear = true, resolution = (500,500))\n    scalarplot!(p[1,1], xgrid, view(nodevalues(Solution[1]),1,:), levels = 5, title = \"u_h\")\n\n    # print/plot convergence history\n    print_convergencehistory(NDofs, Results; X_to_h = X -> X.^(-1/3), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\"])\n    plot_convergencehistory(NDofs, Results; add_h_powers = [1,2], X_to_h = X -> X.^(-1/3), Plotter = Plotter, ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\"])\nend\n\nend","category":"page"},{"location":"examples/Example301_Poisson3D/","page":"301 : Poisson-Problem 3D","title":"301 : Poisson-Problem 3D","text":"","category":"page"},{"location":"examples/Example301_Poisson3D/","page":"301 : Poisson-Problem 3D","title":"301 : Poisson-Problem 3D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example301_Poisson3D/","page":"301 : Poisson-Problem 3D","title":"301 : Poisson-Problem 3D","text":"Default output:","category":"page"},{"location":"examples/Example301_Poisson3D/","page":"301 : Poisson-Problem 3D","title":"301 : Poisson-Problem 3D","text":"julia> Example301_Poisson3D.main()\n\n    ndofs   |    || u - u_h ||     order  |  || ∇(u - u_h) ||    order  |\n============|=============================|=============================|\n        27  |     3.38581e-02      0.000  |     4.38269e-01      0.000  |\n       125  |     8.97264e-03      2.600  |     2.25880e-01      1.298  |\n       729  |     2.28139e-03      2.330  |     1.13818e-01      1.166  |\n      4913  |     5.73658e-04      2.171  |     5.70179e-02      1.087  |","category":"page"},{"location":"examples/Example301_Poisson3D/","page":"301 : Poisson-Problem 3D","title":"301 : Poisson-Problem 3D","text":"(Image: )","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusion2D/#:-Reaction-Convection-Diffusion-Problem-2D","page":"203 : Reaction-Convection-Diffusion-Problem 2D","title":"203 : Reaction-Convection-Diffusion-Problem 2D","text":"","category":"section"},{"location":"examples/Example203_ReactionConvectionDiffusion2D/","page":"203 : Reaction-Convection-Diffusion-Problem 2D","title":"203 : Reaction-Convection-Diffusion-Problem 2D","text":"(source code)","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusion2D/","page":"203 : Reaction-Convection-Diffusion-Problem 2D","title":"203 : Reaction-Convection-Diffusion-Problem 2D","text":"This example computes the solution of some convection-diffusion problem","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusion2D/","page":"203 : Reaction-Convection-Diffusion-Problem 2D","title":"203 : Reaction-Convection-Diffusion-Problem 2D","text":"-nu Delta u + mathbfbeta cdot nabla u + alpha u = f quad textin  Omega","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusion2D/","page":"203 : Reaction-Convection-Diffusion-Problem 2D","title":"203 : Reaction-Convection-Diffusion-Problem 2D","text":"with some diffusion coefficient  nu, some vector-valued function  mathbfbeta, some scalar-valued function alpha and inhomogeneous Dirichlet boundary data.","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusion2D/","page":"203 : Reaction-Convection-Diffusion-Problem 2D","title":"203 : Reaction-Convection-Diffusion-Problem 2D","text":"We prescribe an analytic solution with mathbfbeta = (10) and alpha = 01 and check the L2 and H1 error convergence of the method on a series of uniformly refined meshes. We also compare with the error of a simple nodal interpolation and plot the solution and the norm of its gradient.","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusion2D/","page":"203 : Reaction-Convection-Diffusion-Problem 2D","title":"203 : Reaction-Convection-Diffusion-Problem 2D","text":"For small nu, the convection term dominates and pollutes the accuracy of the method. For demonstration some simple gradient jump (interior penalty) stabilisation is added to improve things.","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusion2D/","page":"203 : Reaction-Convection-Diffusion-Problem 2D","title":"203 : Reaction-Convection-Diffusion-Problem 2D","text":"module Example203_ReactionConvectionDiffusion2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# coefficient functions\nconst β = DataFunction([1,0]; name = \"β\")\nconst α = DataFunction([0.01]; name = \"α\")\n\n# problem data and expected exact solution\nfunction exact_solution!(result,x)\n    result[1] = x[1]*x[2]*(x[1]-1)*(x[2]-1) + x[1]\nend\nfunction exact_solution_gradient!(result,x)\n    result[1] = x[2]*(2*x[1]-1)*(x[2]-1) + 1\n    result[2] = x[1]*(2*x[2]-1)*(x[1]-1)\nend\nfunction exact_solution_rhs!(ν)\n    eval_alpha = zeros(Float64,1)\n    eval_beta = zeros(Float64,2)\n    function closure(result,x)\n        # diffusion part\n        result[1] = -ν*(2*x[2]*(x[2]-1) + 2*x[1]*(x[1]-1))\n        # convection part (beta * grad(u))\n        eval_data!(eval_beta, β, x, 0)\n        result[1] += eval_beta[1] * (x[2]*(2*x[1]-1)*(x[2]-1) + 1)\n        result[1] += eval_beta[2] * (x[1]*(2*x[2]-1)*(x[1]-1))\n        # reaction part (alpha*u)\n        eval_data!(eval_alpha, α, x, 0)\n        result[1] += eval_alpha[1] * (x[1]*x[2]*(x[1]-1)*(x[2]-1) + x[1])\n        return nothing\n    end\nend\n\n# custom bilinearform that can assemble the full PDE operator\nfunction ReactionConvectionDiffusionOperator(α, β, ν)\n    eval_alpha = zeros(Float64,1)\n    eval_beta = zeros(Float64,2)\n    function action_kernel!(result, input,x)\n        # input = [u,∇u] as a vector of length 3\n        eval_data!(eval_beta, β, x, 0)\n        eval_data!(eval_alpha, α, x, 0)\n        result[1] = eval_alpha[1] * input[1] + eval_beta[1] * input[2] + eval_beta[2] * input[3]\n        result[2] = ν * input[2]\n        result[3] = ν * input[3]\n        # result will be multiplied with [v,∇v]\n        return nothing\n    end\n    action = Action(action_kernel!, [3,3]; dependencies = \"X\", quadorder = max(α.quadorder,β.quadorder))\n    return BilinearForm([OperatorPair{Identity,Gradient},OperatorPair{Identity,Gradient}], action; name = \"ν(∇u,∇v) + (αu + β⋅∇u, v)\", transposed_assembly = true)\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, Plotter = nothing, ν = 1e-5, τ = 2e-2, nlevels = 5)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # load a mesh of the unit square\n    # with four boundary regions (1 = bottom, 2 = right, 3 = top, 4 = left)\n    xgrid = grid_unitsquare(Triangle2D); # initial grid\n\n    # negotiate data functions to the package\n    u = DataFunction(exact_solution!, [1,2]; name = \"u\", dependencies = \"X\", quadorder = 4)\n    ∇u = DataFunction(exact_solution_gradient!, [2,2]; name = \"∇(u)\", dependencies = \"X\", quadorder = 3)\n    f = DataFunction(exact_solution_rhs!(ν), [1,2]; name = \"f\", dependencies = \"X\", quadorder = 3)\n\n    # choose a finite element type, here we choose a second order H1-conforming one\n    FEType = H1P2{1,2}\n\n    # create PDE description\n    Problem = PDEDescription(\"reaction-convection-diffusion problem\")\n    add_unknown!(Problem; unknown_name = \"u\", equation_name = \"reaction-convection-diffusion equation\")\n    add_operator!(Problem, [1,1], ReactionConvectionDiffusionOperator(α,β,ν))\n    add_rhsdata!(Problem, 1, RhsOperator(Identity, [0], f))\n\n    # add boundary data to unknown 1 (there is only one in this example)\n    add_boundarydata!(Problem, 1, [1,3], BestapproxDirichletBoundary; data = u)   # u_h =  u in bregions 1 and 3\n    add_boundarydata!(Problem, 1, [2], InterpolateDirichletBoundary; data = u)    # u_h = Iu in bregion 2\n    add_boundarydata!(Problem, 1, [4], HomogeneousDirichletBoundary)              # u_h =  0 in bregion 4\n\n    # add a gradient jump (interior penalty) stabilisation for dominant convection\n    if τ > 0\n        # first we define an item-dependent action kernel...\n        xFaceVolumes::Array{Float64,1} = xgrid[FaceVolumes]\n        stab_action = Action((result,input,item) -> (result .= input .* xFaceVolumes[item]^2), [2,2]; name = \"stabilisation action\", dependencies = \"I\", quadorder = 0 )\n        JumpStabilisation = BilinearForm([Jump(Gradient), Jump(Gradient)], stab_action; AT = ON_IFACES, factor = τ, name = \"τ |F|^2 [∇(u)]⋅[∇(v)]\")\n        add_operator!(Problem, [1,1], JumpStabilisation)\n    end\n\n    # finally we have a look at the defined problem\n    @show Problem\n\n    # define ItemIntegrators for L2/H1 error computation and some arrays to store the errors\n    L2Error = L2ErrorIntegrator(Float64, u, Identity)\n    H1Error = L2ErrorIntegrator(Float64, ∇u, Gradient)\n    Results = zeros(Float64,nlevels,4); NDofs = zeros(Int,nlevels)\n\n    # refinement loop over levels\n    Solution = nothing\n    for level = 1 : nlevels\n        # uniform mesh refinement\n        xgrid = uniform_refine(xgrid)\n        xFaceVolumes = xgrid[FaceVolumes] # update xFaceVolumes used in stabilisation definition\n\n        # generate FESpace and solution vector\n        FES = FESpace{FEType}(xgrid)\n        Solution = FEVector(\"u_h\",FES)\n\n        # solve PDE\n        solve!(Solution, Problem)\n\n        # interpolate (just for comparison)\n        Interpolation = FEVector(\"I(u)\",FES)\n        interpolate!(Interpolation[1], u)\n\n        # compute L2 and H1 errors and save data\n        NDofs[level] = length(Solution.entries)\n        Results[level,1] = sqrt(evaluate(L2Error,Solution[1]))\n        Results[level,2] = sqrt(evaluate(L2Error,Interpolation[1]))\n        Results[level,3] = sqrt(evaluate(H1Error,Solution[1]))\n        Results[level,4] = sqrt(evaluate(H1Error,Interpolation[1]))\n    end\n\n    # plot\n    p=GridVisualizer(; Plotter = Plotter, layout = (1,2), clear = true, resolution = (1000,500))\n    scalarplot!(p[1,1], xgrid, view(nodevalues(Solution[1]),1,:), levels = 11, title = \"u_h\")\n    scalarplot!(p[1,2], xgrid, view(nodevalues(Solution[1], Gradient; abs = true),1,:), levels = 7)\n    vectorplot!(p[1,2], xgrid, evaluate(PointEvaluator(Solution[1], Gradient)), spacing = 0.1, clear = false, title = \"∇u_h (abs + quiver)\")\n\n    # print/plot convergence history\n    print_convergencehistory(NDofs, Results; X_to_h = X -> X.^(-1/2), ylabels = [\"|| u - u_h ||\", \"|| u - Iu ||\", \"|| ∇(u - u_h) ||\", \"|| ∇(u - Iu) ||\"])\n    plot_convergencehistory(NDofs, Results; add_h_powers = [2,3], X_to_h = X -> X.^(-1/2), Plotter = Plotter, ylabels = [\"|| u - u_h ||\", \"|| u - Iu ||\", \"|| ∇(u - u_h) ||\", \"|| ∇(u - Iu) ||\"])\nend\n\nend","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusion2D/","page":"203 : Reaction-Convection-Diffusion-Problem 2D","title":"203 : Reaction-Convection-Diffusion-Problem 2D","text":"","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusion2D/","page":"203 : Reaction-Convection-Diffusion-Problem 2D","title":"203 : Reaction-Convection-Diffusion-Problem 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusion2D/","page":"203 : Reaction-Convection-Diffusion-Problem 2D","title":"203 : Reaction-Convection-Diffusion-Problem 2D","text":"Default output:","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusion2D/","page":"203 : Reaction-Convection-Diffusion-Problem 2D","title":"203 : Reaction-Convection-Diffusion-Problem 2D","text":"julia> Example203_ReactionConvectionDiffusion2D.main()\n\nPDE-DESCRIPTION\n===============\n  system name = reaction-convection-diffusion problem\n\n     id   | unknown name / equation name\n    [1]   | u / reaction-convection-diffusion equation \n\n  LHS block | PDEOperator(s)\n    [1,1]   | ν(∇u,∇v) + (αu + β⋅∇u, v) (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n            | τ |F|^2 [∇(u)]⋅[∇(v)] (APT = BilinearForm, AT = ON_IFACES, regions = [0])\n\n  RHS block | PDEOperator(s)\n     [1]    | (f, id(v)) (APT = LinearForm, AT = ON_CELLS, regions = [0])\n\n   BoundaryOperator[1] : BestapproxDirichletBoundary -> [1, 3]\n                         InterpolateDirichletBoundary -> [2]\n                         HomogeneousDirichletBoundary -> [4]\n                          \n\nProblem = \n\n    ndofs   |    || u - u_h ||     order  |    || u - Iu ||      order  |  || ∇(u - u_h) ||    order  |   || ∇(u - Iu) ||    order  |\n============|=============================|=============================|=============================|=============================|\n        41  |     2.12526e-03      0.000  |     7.66225e-04      0.000  |     2.58888e-02      0.000  |     1.45087e-02      0.000  |\n       145  |     1.79758e-04      3.911  |     9.34178e-05      3.332  |     4.95325e-03      2.618  |     3.57540e-03      2.218  |\n       545  |     1.83002e-05      3.451  |     1.16023e-05      3.151  |     1.11069e-03      2.258  |     8.90584e-04      2.100  |\n      2113  |     1.93925e-06      3.313  |     1.44793e-06      3.072  |     2.58474e-04      2.152  |     2.22441e-04      2.047  |\n      8321  |     2.15115e-07      3.208  |     1.80918e-07      3.035  |     6.17161e-05      2.090  |     5.55975e-05      2.023  |","category":"page"},{"location":"examples/Example203_ReactionConvectionDiffusion2D/","page":"203 : Reaction-Convection-Diffusion-Problem 2D","title":"203 : Reaction-Convection-Diffusion-Problem 2D","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/Example206_PressureRobustness2D/#:-Pressure-robustness-2D","page":"206 : Pressure-robustness 2D","title":"206 : Pressure-robustness 2D","text":"","category":"section"},{"location":"examples/Example206_PressureRobustness2D/","page":"206 : Pressure-robustness 2D","title":"206 : Pressure-robustness 2D","text":"(source code)","category":"page"},{"location":"examples/Example206_PressureRobustness2D/","page":"206 : Pressure-robustness 2D","title":"206 : Pressure-robustness 2D","text":"This example studies two benchmarks for pressure-robust discretisations of the stationary     Navier-Stokes equations that seek a velocity mathbfu and pressure mathbfp such that","category":"page"},{"location":"examples/Example206_PressureRobustness2D/","page":"206 : Pressure-robustness 2D","title":"206 : Pressure-robustness 2D","text":"beginaligned\n- mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = mathbff\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"examples/Example206_PressureRobustness2D/","page":"206 : Pressure-robustness 2D","title":"206 : Pressure-robustness 2D","text":"with (possibly time-dependent) exterior force mathbff and some viscosity parameter mu.","category":"page"},{"location":"examples/Example206_PressureRobustness2D/","page":"206 : Pressure-robustness 2D","title":"206 : Pressure-robustness 2D","text":"Pressure-robustness is concerned with gradient forces that may appear in the right-hand side or the material derivative and should be balanced by the pressure (as divergence-free vector fields are orthogonal on gradient fields). Here, two test problems are considered:","category":"page"},{"location":"examples/Example206_PressureRobustness2D/","page":"206 : Pressure-robustness 2D","title":"206 : Pressure-robustness 2D","text":"HydrostaticTestProblem() : Stokes (without convection term) and mathbff = nabla p such that  mathbfu = 0\nPotentialFlowTestProblem() : Navier-Stokes with mathbff = 0 and mathbfu = nabla h for some harmonic function","category":"page"},{"location":"examples/Example206_PressureRobustness2D/","page":"206 : Pressure-robustness 2D","title":"206 : Pressure-robustness 2D","text":"In both test problems the errors of non-pressure-robust discretisations scale with  1mu, while the pressure-robust discretisation solves mathbfu = 0 exactly in test problem 1 and gives much better results in test problem 2.","category":"page"},{"location":"examples/Example206_PressureRobustness2D/","page":"206 : Pressure-robustness 2D","title":"206 : Pressure-robustness 2D","text":"module Example206_PressureRobustness2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# problem data\nfunction HydrostaticTestProblem()\n    # Stokes problem with f = grad(p)\n    # u = 0\n    # p = x^3+y^3 - 1//2\n    function P1_pressure!(result,x)\n        result[1] = x[1]^3 + x[2]^3 - 1//2\n    end\n    function P1_rhs!(result,x)\n        result[1] = 3*x[1]^2\n        result[2] = 3*x[2]^2\n    end\n    u = DataFunction([0,0]; name = \"u\")\n    p = DataFunction(P1_pressure!, [1,2]; name = \"p\", dependencies = \"X\", quadorder = 3)\n    ∇u = DataFunction([0,0,0,0]; name = \"∇u\")\n    f = DataFunction(P1_rhs!, [2,2]; name = \"f\", dependencies = \"X\", quadorder = 2)\n\n    return p,u,∇u,f,false\nend\n\nfunction PotentialFlowTestProblem()\n    # NavierStokes with f = 0\n    # u = grad(h) with h = x^3 - 3xy^2\n    # p = - |grad(h)|^2 + 14//5\n    function P2_pressure!(result,x)\n        result[1] = - 1//2 * (9*(x[1]^4 + x[2]^4) + 18*x[1]^2*x[2]^2) + 14//5\n    end\n    function P2_velo!(result,x)\n        result[1] = 3*x[1]^2 - 3*x[2]^2;\n        result[2] = -6*x[1]*x[2];\n    end\n    function P2_velogradient!(result,x)\n        result[1] = 6*x[1]\n        result[2] = -6*x[2];\n        result[3] = -6*x[2];\n        result[4] = -6*x[1];\n    end\n    u = DataFunction(P2_velo!, [2,2]; name = \"u\", dependencies = \"X\", quadorder = 2)\n    p = DataFunction(P2_pressure!, [1,2]; name = \"p\", dependencies = \"X\", quadorder = 4)\n    ∇u = DataFunction(P2_velogradient!, [4,2]; name = \"∇u\", dependencies = \"X\", quadorder = 1)\n    f = DataFunction([0,0]; name = \"f\")\n\n    return p,u,∇u,f,true\nend\n\n\nfunction solve(Problem, xgrid, FETypes, viscosity = 1e-2; nlevels = 4, print_results = true, verbosity = 1, target_residual = 1e-10, maxiterations = 20, Plotter = nothing)\n\n    # load problem data and set solver parameters\n    ReconstructionOperator = FETypes[3]\n    p,u,∇u,f,nonlinear = Problem()\n\n    # setup classical (Problem) and pressure-robust scheme (Problem2)\n    Problem = IncompressibleNavierStokesProblem(2; viscosity = viscosity, nonlinear = false)\n    add_boundarydata!(Problem, 1, [1,2,3,4], BestapproxDirichletBoundary; data = u)\n    Problem2 = deepcopy(Problem)\n    Problem.name = \"Stokes problem (classical)\"\n    Problem2.name = \"Stokes problem (p-robust)\"\n\n    # assign right-hand side\n    add_rhsdata!(Problem, 1, RhsOperator(Identity, [0], f))\n    add_rhsdata!(Problem2, 1, RhsOperator(ReconstructionOperator, [0], f))\n\n    # assign convection term\n    if nonlinear\n        add_operator!(Problem,[1,1], ConvectionOperator(1, Identity, 2, 2))\n        add_operator!(Problem2,[1,1], ConvectionOperator(1, ReconstructionOperator, 2, 2; testfunction_operator = ReconstructionOperator))\n    end\n\n    # define bestapproximation problems\n    BAP_L2_u = L2BestapproximationProblem(u; bestapprox_boundary_regions = [1,2,3,4])\n    BAP_L2_p = L2BestapproximationProblem(p; bestapprox_boundary_regions = [])\n    BAP_H1_u = H1BestapproximationProblem(∇u, u; bestapprox_boundary_regions = [1,2,3,4])\n\n    # define ItemIntegrators for L2/H1 error computation\n    L2Error_u = L2ErrorIntegrator(Float64, u, Identity)\n    L2Error_p = L2ErrorIntegrator(Float64, p, Identity)\n    H1Error_u = L2ErrorIntegrator(Float64, ∇u, Gradient)\n    Results = zeros(Float64, nlevels, 9)\n    NDofs = zeros(Int, nlevels)\n\n    # loop over refinement levels\n    Solution, Solution2 = nothing, nothing\n    for level = 1 : nlevels\n\n        # uniform mesh refinement\n        xgrid = uniform_refine(xgrid)\n\n        # get FESpaces\n        FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid; broken = true)]\n        Solution = FEVector([\"u_c (classic)\", \"p_c (classic)\"],FES)\n        Solution2 = FEVector([\"u_r (p-robust)\", \"p_r (p-robust)\"],FES)\n\n        # solve both problems\n        solve!(Solution, Problem; maxiterations = maxiterations, target_residual = target_residual, anderson_iterations = 5)\n        solve!(Solution2, Problem2; maxiterations = maxiterations, target_residual = target_residual, anderson_iterations = 5)\n\n        # solve bestapproximation problems\n        BA_L2_u = FEVector(\"Πu\",FES[1])\n        BA_L2_p = FEVector(\"πp\",FES[2])\n        BA_H1_u = FEVector(\"Su\",FES[1])\n        solve!(BA_L2_u, BAP_L2_u)\n        solve!(BA_L2_p, BAP_L2_p)\n        solve!(BA_H1_u, BAP_H1_u)\n\n        # compute L2 and H1 errors and save data\n        NDofs[level] = length(Solution.entries)\n        Results[level,1] = sqrt(evaluate(L2Error_u,Solution[1]))\n        Results[level,2] = sqrt(evaluate(L2Error_u,Solution2[1]))\n        Results[level,3] = sqrt(evaluate(L2Error_u,BA_L2_u[1]))\n        Results[level,4] = sqrt(evaluate(L2Error_p,Solution[2]))\n        Results[level,5] = sqrt(evaluate(L2Error_p,Solution2[2]))\n        Results[level,6] = sqrt(evaluate(L2Error_p,BA_L2_p[1]))\n        Results[level,7] = sqrt(evaluate(H1Error_u,Solution[1]))\n        Results[level,8] = sqrt(evaluate(H1Error_u,Solution2[1]))\n        Results[level,9] = sqrt(evaluate(H1Error_u,BA_H1_u[1]))\n    end\n\n    # print convergence history\n    print_convergencehistory(NDofs, Results[:,1:3]; X_to_h = X -> X.^(-1/2), ylabels = [\"||u-u_c||\", \"||u-u_r||\", \"||u-Πu||\"])\n    print_convergencehistory(NDofs, Results[:,4:6]; X_to_h = X -> X.^(-1/2), ylabels = [\"||p-p_c||\", \"||p-p_r||\", \"||p-πp||\"])\n    print_convergencehistory(NDofs, Results[:,7:9]; X_to_h = X -> X.^(-1/2), ylabels = [\"||∇(u-u_c)||\", \"||∇(u-u_r)||\", \"||∇(u-Su)||\"])\n\n    # plot\n    p = GridVisualizer(; Plotter = Plotter, layout = (2,2), clear = true, resolution = (1000,1000))\n    scalarplot!(p[1,1],xgrid,view(nodevalues(Solution[1]; abs = true),1,:), levels = 7)\n    vectorplot!(p[1,1],xgrid,evaluate(PointEvaluator(Solution[1], Identity)), spacing = 0.1, clear = false, title = \"u_c (abs + quiver)\")\n    scalarplot!(p[1,2],xgrid,view(nodevalues(Solution[2]),1,:), levels = 11, title = \"p_c\")\n    scalarplot!(p[2,1],xgrid,view(nodevalues(Solution2[1]; abs = true),1,:), levels = 7)\n    vectorplot!(p[2,1],xgrid,evaluate(PointEvaluator(Solution2[1], Identity)), spacing = 0.1, clear = false, title = \"u_r (abs + quiver)\")\n    scalarplot!(p[2,2],xgrid,view(nodevalues(Solution2[2]),1,:), levels = 11, title = \"p_r\")\n\n    # return last L2 error of p-robust method for testing\n    return Results[end,2]\nend\n\n\n# everything is wrapped in a main function\nfunction main(; problem = 2, verbosity = 0, nlevels = 3, viscosity = 1e-2, Plotter = nothing)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # set problem to solve\n    if problem == 1\n        Problem = HydrostaticTestProblem\n    elseif problem == 2\n        Problem = PotentialFlowTestProblem\n    else\n        @error \"No problem defined for this number!\"\n    end\n\n    # set grid and problem parameters\n    xgrid = grid_unitsquare(Triangle2D) # initial grid\n\n    # choose finite element discretisation\n    #FETypes = [H1BR{2}, H1P0{1}, ReconstructionIdentity{HDIVRT0{2}}] # Bernardi--Raugel with RT0 reconstruction\n    FETypes = [H1BR{2}, H1P0{1}, ReconstructionIdentity{HDIVBDM1{2}}] # Bernardi--Raugel with BDM1 reconstruction\n    #FETypes = [H1CR{2}, H1P0{1}, ReconstructionIdentity{HDIVRT0{2}}] # Crouzeix--Raviart with RT0 reconstruction\n\n    # run\n    solve(Problem, xgrid, FETypes, viscosity; nlevels = nlevels, Plotter = Plotter)\n\n    return nothing\nend\n\n\n# test function that is called by test unit\n# tests if hydrostatic problem is solved exactly by pressure-robust methods\nfunction test(; Plotter = nothing)\n    xgrid = uniform_refine(grid_unitsquare_mixedgeometries())\n    testspaces = [[H1CR{2}, H1P0{1}, ReconstructionIdentity{HDIVRT0{2}}],\n                  [H1BR{2}, H1P0{1}, ReconstructionIdentity{HDIVRT0{2}}],\n                  [H1BR{2}, H1P0{1}, ReconstructionIdentity{HDIVBDM1{2}}]\n                  ]\n    error = []\n    for FETypes in testspaces\n        push!(error, solve(HydrostaticTestProblem, xgrid, FETypes, 1; nlevels = 1, print_results = false))\n        println(\"FETypes = $FETypes   error = $(error[end])\")\n    end\n\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D))\n    testspaces = [\n                  [H1P2B{2,2}, H1P1{1}, ReconstructionIdentity{HDIVRT1{2}}]\n                  ]\n    error = []\n    for FETypes in testspaces\n        push!(error, solve(HydrostaticTestProblem, xgrid, FETypes, 1; nlevels = 1, print_results = false, Plotter = Plotter))\n        println(\"FETypes = $FETypes   error = $(error[end])\")\n    end\n    return maximum(error)\nend\n\nend","category":"page"},{"location":"examples/Example206_PressureRobustness2D/","page":"206 : Pressure-robustness 2D","title":"206 : Pressure-robustness 2D","text":"","category":"page"},{"location":"examples/Example206_PressureRobustness2D/","page":"206 : Pressure-robustness 2D","title":"206 : Pressure-robustness 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example206_PressureRobustness2D/","page":"206 : Pressure-robustness 2D","title":"206 : Pressure-robustness 2D","text":"Default output:","category":"page"},{"location":"examples/Example206_PressureRobustness2D/","page":"206 : Pressure-robustness 2D","title":"206 : Pressure-robustness 2D","text":"julia> Example206_PressureRobustness2D.main()\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 1.452589e-16 | 3.907408e+00\n\t      2   | 1.274062e-15 | 1.274009e+00\n\t      3   | 1.703634e-15 | 1.579942e+00\n\t      4   | 1.385375e-15 | 6.859809e-01\n\t      5   | 1.390316e-15 | 4.477920e-01\n\t      6   | 1.259997e-15 | 3.162627e-01\n\t      7   | 1.424997e-15 | 3.153493e-01\n\t      8   | 1.501112e-15 | 3.439853e-01\n\t      9   | 1.388126e-15 | 2.469638e-01\n\t     10   | 1.578961e-15 | 1.880776e-01\n\t     11   | 1.081577e-15 | 2.331640e-01\n\t     12   | 1.210812e-15 | 1.719761e-01\n\t     13   | 1.184534e-15 | 1.236650e-01\n\t     14   | 1.312758e-15 | 1.532406e-01\n\t     15   | 1.604780e-15 | 6.657050e-02\n\t     16   | 1.407839e-15 | 4.815822e-02\n\t     17   | 1.497943e-15 | 3.579211e-02\n\t     18   | 1.333056e-15 | 1.615671e-02\n\t     19   | 1.382878e-15 | 1.255390e-02\n\t     20   | 1.012696e-15 | 5.543517e-03\n\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 1.452589e-16 | 4.356218e+00\n\t      2   | 1.282716e-15 | 3.427807e-01\n\t      3   | 1.151670e-15 | 2.616497e-01\n\t      4   | 1.484761e-15 | 2.423814e-01\n\t      5   | 2.032960e-15 | 1.985077e-01\n\t      6   | 1.476183e-15 | 1.334100e-01\n\t      7   | 9.311629e-16 | 5.475030e-02\n\t      8   | 1.436359e-15 | 2.884838e-02\n\t      9   | 1.340319e-15 | 4.588907e-03\n\t     10   | 1.105291e-15 | 2.626320e-03\n\t     11   | 1.100225e-15 | 1.422550e-03\n\t     12   | 1.279602e-15 | 7.924977e-04\n\t     13   | 1.815513e-15 | 6.584443e-04\n\t     14   | 1.332056e-15 | 6.852785e-04\n\t     15   | 1.049027e-15 | 2.363456e-04\n\t     16   | 1.398890e-15 | 1.426986e-05\n\t     17   | 1.208638e-15 | 5.132736e-06\n\t     18   | 1.238809e-15 | 1.535328e-06\n\t     19   | 9.791654e-16 | 2.103704e-07\n\t     20   | 1.322194e-15 | 6.903052e-08\n\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 1.357512e-16 | 2.498491e+00\n\t      2   | 1.164854e-15 | 4.264672e-01\n\t      3   | 1.200276e-15 | 1.466834e-01\n\t      4   | 1.187324e-15 | 1.233691e-01\n\t      5   | 1.058473e-15 | 2.575874e-02\n\t      6   | 1.133543e-15 | 1.584287e-02\n\t      7   | 1.306747e-15 | 1.023577e-02\n\t      8   | 1.566322e-15 | 1.453320e-03\n\t      9   | 1.261652e-15 | 5.978589e-04\n\t     10   | 1.327668e-15 | 4.218207e-04\n\t     11   | 1.402936e-15 | 1.503106e-04\n\t     12   | 1.603848e-15 | 4.639181e-05\n\t     13   | 1.176274e-15 | 7.099509e-06\n\t     14   | 1.302549e-15 | 2.661706e-06\n\t     15   | 1.340694e-15 | 9.314383e-07\n\t     16   | 1.253975e-15 | 3.788933e-07\n\t     17   | 1.014154e-15 | 2.119052e-07\n\t     18   | 1.327404e-15 | 4.316282e-08\n\t     19   | 1.203067e-15 | 1.071468e-08\n\t     20   | 1.336698e-15 | 5.244141e-09\n\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 1.357512e-16 | 2.776075e+00\n\t      2   | 1.121510e-15 | 4.423908e-02\n\t      3   | 1.327008e-15 | 3.071828e-02\n\t      4   | 1.422797e-15 | 3.349017e-02\n\t      5   | 1.614318e-15 | 4.497733e-03\n\t      6   | 1.111766e-15 | 1.488965e-03\n\t      7   | 1.194319e-15 | 9.470225e-04\n\t      8   | 1.713601e-15 | 3.312038e-04\n\t      9   | 1.210213e-15 | 5.202048e-05\n\t     10   | 1.722075e-15 | 1.296677e-05\n\t     11   | 1.341953e-15 | 1.988109e-06\n\t     12   | 1.151484e-15 | 5.441005e-07\n\t     13   | 9.843337e-16 | 1.996136e-07\n\t     14   | 1.207890e-15 | 4.121641e-08\n\t     15   | 1.293027e-15 | 9.881625e-09\n\t     16   | 1.196856e-15 | 3.023854e-09\n\t     17   | 1.069003e-15 | 1.504866e-09\n\t     18   | 1.238437e-15 | 4.526085e-10\n\t     19   | 1.366768e-15 | 3.113874e-11\n\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 1.819767e-16 | 1.399826e+00\n\t      2   | 1.134963e-15 | 1.018196e-01\n\t      3   | 1.169872e-15 | 1.753466e-02\n\t      4   | 1.255317e-15 | 3.761296e-03\n\t      5   | 1.151965e-15 | 6.421894e-04\n\t      6   | 1.166188e-15 | 2.238335e-04\n\t      7   | 1.314800e-15 | 1.034672e-04\n\t      8   | 1.124899e-15 | 2.554042e-05\n\t      9   | 1.217815e-15 | 1.210502e-05\n\t     10   | 1.172206e-15 | 2.795871e-06\n\t     11   | 1.319222e-15 | 3.545141e-07\n\t     12   | 1.218484e-15 | 9.131551e-08\n\t     13   | 1.296721e-15 | 2.694435e-08\n\t     14   | 1.221037e-15 | 3.825650e-09\n\t     15   | 1.397467e-15 | 1.085089e-09\n\t     16   | 1.223906e-15 | 3.259654e-10\n\t     17   | 1.288756e-15 | 7.760278e-11\n\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 1.819767e-16 | 1.552312e+00\n\t      2   | 1.197808e-15 | 1.953562e-03\n\t      3   | 1.238355e-15 | 6.017487e-04\n\t      4   | 1.175350e-15 | 2.624481e-04\n\t      5   | 1.433105e-15 | 1.586135e-04\n\t      6   | 1.353965e-15 | 4.238678e-05\n\t      7   | 1.440089e-15 | 1.525526e-05\n\t      8   | 1.331648e-15 | 6.411477e-06\n\t      9   | 1.335390e-15 | 1.331816e-06\n\t     10   | 1.261699e-15 | 1.827395e-07\n\t     11   | 1.353969e-15 | 6.848769e-08\n\t     12   | 1.363936e-15 | 2.056931e-08\n\t     13   | 1.357698e-15 | 6.517358e-09\n\t     14   | 1.342189e-15 | 1.560778e-09\n\t     15   | 1.276374e-15 | 2.615672e-10\n\t     16   | 1.306066e-15 | 5.853303e-11\n\n\n    ndofs   |      ||u-u_c||       order  |      ||u-u_r||       order  |      ||u-Πu||        order  |\n============|=============================|=============================|=============================|\n        70  |     1.13125e+00      0.000  |     6.88280e-01      0.000  |     5.40140e-02      0.000  |\n       250  |     6.40409e-01      0.894  |     1.00924e-01      3.016  |     1.27605e-02      2.267  |\n       946  |     2.18402e-01      1.617  |     6.15065e-03      4.205  |     3.02624e-03      2.163  |\n\n    ndofs   |      ||p-p_c||       order  |      ||p-p_r||       order  |      ||p-πp||        order  |\n============|=============================|=============================|=============================|\n        70  |     1.59543e+00      0.000  |     1.31333e+00      0.000  |     1.15315e+00      0.000  |\n       250  |     1.03859e+00      0.674  |     5.91329e-01      1.254  |     5.79567e-01      1.081  |\n       946  |     4.47697e-01      1.265  |     2.90098e-01      1.070  |     2.90014e-01      1.041  |\n\n    ndofs   |    ||∇(u-u_c)||      order  |    ||∇(u-u_r)||      order  |     ||∇(u-Su)||      order  |\n============|=============================|=============================|=============================|\n        70  |     1.76102e+01      0.000  |     9.63537e+00      0.000  |     1.13867e+00      0.000  |\n       250  |     1.46160e+01      0.293  |     1.95442e+00      2.507  |     5.66582e-01      1.097  |\n       946  |     8.87338e+00      0.750  |     3.87639e-01      2.431  |     2.81678e-01      1.050  |","category":"page"},{"location":"examples/Example206_PressureRobustness2D/","page":"206 : Pressure-robustness 2D","title":"206 : Pressure-robustness 2D","text":"(Image: )","category":"page"},{"location":"examples/Example224_FlowAroundCylinder2D/#:-Flow-around-a-cylinder-2D","page":"224 : Flow around a cylinder 2D","title":"224 : Flow around a cylinder 2D","text":"","category":"section"},{"location":"examples/Example224_FlowAroundCylinder2D/","page":"224 : Flow around a cylinder 2D","title":"224 : Flow around a cylinder 2D","text":"(source code)","category":"page"},{"location":"examples/Example224_FlowAroundCylinder2D/","page":"224 : Flow around a cylinder 2D","title":"224 : Flow around a cylinder 2D","text":"This example solves the DFG Navier-Stokes benchmark problem","category":"page"},{"location":"examples/Example224_FlowAroundCylinder2D/","page":"224 : Flow around a cylinder 2D","title":"224 : Flow around a cylinder 2D","text":"beginaligned\n- mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = 0\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"examples/Example224_FlowAroundCylinder2D/","page":"224 : Flow around a cylinder 2D","title":"224 : Flow around a cylinder 2D","text":"on a rectangular 2D domain with a circular obstacle, see here for details.","category":"page"},{"location":"examples/Example224_FlowAroundCylinder2D/","page":"224 : Flow around a cylinder 2D","title":"224 : Flow around a cylinder 2D","text":"This script demonstrates the employment of external grid generators and the computation of drag and lift coefficients.","category":"page"},{"location":"examples/Example224_FlowAroundCylinder2D/","page":"224 : Flow around a cylinder 2D","title":"224 : Flow around a cylinder 2D","text":"Note: This example needs the additional packages Triangulate and SimplexGridFactory to generate the mesh.","category":"page"},{"location":"examples/Example224_FlowAroundCylinder2D/","page":"224 : Flow around a cylinder 2D","title":"224 : Flow around a cylinder 2D","text":"module Example224_FlowAroundCylinder2D\n\nusing GradientRobustMultiPhysics\nusing Triangulate\nusing SimplexGridFactory\nusing ExtendableGrids\nusing GridVisualize\n\n# inlet data for Karman vortex street example\n# as in DFG benchmark 2D-1 (Re = 20, laminar)\nconst umax = 0.3\nconst umean = 2//3 * umax\nconst L, W, H = 0.1, 2.2, 0.41\nfunction bnd_inlet!(result,x)\n    result[1] = 4*umax*x[2]*(H-x[2])/(H*H);\n    result[2] = 0.0;\nend\nconst inflow = DataFunction(bnd_inlet!, [2,2]; name = \"u_inflow\", dependencies = \"X\", quadorder = 2)\n\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, μ = 1e-3, maxvol = 1e-3)\n\n    # load grid (see function below)\n    xgrid = make_grid(W,H; n = Int(ceil(sqrt(1/maxvol))), maxvol = maxvol)\n\n    # Bernardi--Raugel element + reconstruction operator\n    FETypes = [H1P2B{2,2}, H1P1{1}];\n    VeloIdentity = ReconstructionIdentity{HDIVBDM2{2}} # div-free reconstruction operator for Identity\n\n    # PDE description\n    Problem = PDEDescription(\"NSE problem (μ = $μ)\")\n    add_unknown!(Problem; equation_name = \"momentum equation\", unknown_name = \"u\")\n    add_unknown!(Problem; equation_name = \"incompressibility constraint\", unknown_name = \"p\")\n\n    # add operators (Laplacian, Div-LagrangeMultierplier, Convection)\n    add_operator!(Problem, [1,1], LaplaceOperator(μ; store = true))\n    add_operator!(Problem, [1,2], LagrangeMultiplier(Divergence))\n    add_operator!(Problem, [1,1], ConvectionOperator(1, VeloIdentity, 2, 2; testfunction_operator = VeloIdentity, auto_newton = true))\n\n    # add boundary data (bregion 2 is outflow, 4 is inflow, 5 is cylinder)\n    add_boundarydata!(Problem, 1, [1,3,5], HomogeneousDirichletBoundary)\n    add_boundarydata!(Problem, 1, [4], BestapproxDirichletBoundary; data = inflow)\n\n    # inspect problem\n    @show Problem\n\n    # generate FESpaces and Solution vector\n    FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid; broken = true)]\n    Solution = FEVector([\"u_h\",\"p_h\"],FES)\n\n    # solve\n    solve!(Solution, Problem; maxiterations = 50, target_residual = 1e-10, show_statistics = true)\n\n    # postprocess : compute drag/lift (see function below)\n    draglift = get_draglift(Solution, μ)\n    pdiff = get_pressure_difference(Solution)\n    println(\"[drag, lift] = $draglift\")\n    println(\"p difference = $pdiff\")\n\n    # plots via GridVisualize\n    p = GridVisualizer(; Plotter = Plotter, layout = (4,1), clear = true, resolution = (800,1200))\n    gridplot!(p[1,1],xgrid, linewidth = 1)\n    gridplot!(p[2,1],xgrid, linewidth = 1, xlimits = [0,0.3], ylimits = [0.1,0.3])\n    scalarplot!(p[3,1],xgrid,view(nodevalues(Solution[1]; abs = true),1,:), levels = 0, colorbarticks = 7)\n    vectorplot!(p[3,1],xgrid,evaluate(PointEvaluator(Solution[1], Identity)), spacing = [0.2,0.04], clear = false, title = \"u_h (abs + quiver)\")\n    scalarplot!(p[4,1],xgrid,view(nodevalues(Solution[2]),1,:), levels = 11, title = \"p_h\")\nend\n\nfunction get_pressure_difference(Solution::FEVector)\n    xgrid = Solution[2].FES.xgrid\n    PE = PointEvaluator(Solution[2], Identity)\n    CF = CellFinder(xgrid)\n    xref = zeros(Float64,2)\n    p_left = zeros(Float64,1); x1 = [0.15,0.2]\n    p_right = zeros(Float64,1); x2 = [0.25,0.2]\n    cell::Int = gFindLocal!(xref, CF, x1; icellstart = 1)\n    if cell == 0\n        cell = gFindBruteForce!(xref, CF, x1)\n    end\n    evaluate!(p_left,PE,xref,cell)\n    cell = gFindLocal!(xref, CF, x2; icellstart = 1)\n    if cell == 0\n        cell = gFindBruteForce!(xref, CF, x2)\n    end\n    evaluate!(p_right,PE,xref,cell)\n    return p_left - p_right\nend\n\nfunction get_draglift(Solution::FEVector, μ)\n\n    # this function is interpolated for drag/lift test function creation\n    function circle_bnd_testfunction(component)\n        function closure!(result,x)\n            fill!(result,0)\n            if sqrt((x[1] - 0.2)^2 + (x[2] - 0.2)^2) <= 0.06\n                result[component] = 1\n            end\n        end\n    end\n\n    # drag lift calcuation by testfunctions\n    function draglift_kernel(result, input)\n        # input = [ u, grad(u), p , v , grad(v)]\n        #         [1:2,  3:6,   7 ,8:9,  10:13 ]\n        result[1] = μ * (input[3]*input[10] + input[4]*input[11] + input[5]*input[12] + input[6]*input[13])\n        result[1] += (input[1] * input[3] + input[2] * input[4]) * input[8]\n        result[1] += (input[1] * input[5] + input[2] * input[6]) * input[9]\n        result[1] -= input[7] * (input[10] + input[13])\n        result[1] *= -(2/(umean^2*L))\n        return nothing\n    end\n    draglift_action = Action(draglift_kernel, [1,13]; name = \"drag/lift by testfunction\", dependencies = \"\", quadorder = 4)\n    DLIntegrator = ItemIntegrator(Float64,ON_CELLS,[Identity, Gradient, Identity, Identity, Gradient], draglift_action)\n\n    # test for drag\n    TestFunction = FEVector(\"drag testfunction\",Solution[1].FES)\n    xBFaceFaces = Solution[1].FES.xgrid[BFaceFaces]\n    dragtest = DataFunction(circle_bnd_testfunction(1), [2,2]; name = \"drag test\", dependencies = \"X\", quadorder = 0)\n    interpolate!(TestFunction[1], ON_FACES, dragtest; items = xBFaceFaces)\n    drag = evaluate(DLIntegrator,[Solution[1],Solution[1],Solution[2],TestFunction[1],TestFunction[1]])\n\n    # test for lift\n    lifttest = DataFunction(circle_bnd_testfunction(2), [2,2]; name = \"lift test\", dependencies = \"X\", quadorder = 0)\n    interpolate!(TestFunction[1], ON_FACES, lifttest; items = xBFaceFaces)\n    lift = evaluate(DLIntegrator,[Solution[1],Solution[1],Solution[2],TestFunction[1],TestFunction[1]])\n\n    return [drag,lift]\nend\n\n# grid generator script using SimplexGridBuilder/Triangulate\nfunction make_grid(W,H; n=20,maxvol=0.1)\n\tbuilder=SimplexGridBuilder(Generator=Triangulate)\n    function circlehole!(builder, center, radius; n=20)\n        points=[point!(builder, center[1]+radius*sin(t),center[2]+radius*cos(t)) for t in range(0,2π,length=n)]\n        for i=1:n-1\n            facet!(builder,points[i],points[i+1])\n        end\n        facet!(builder,points[end],points[1])\n        holepoint!(builder,center)\n    end\n    p1=point!(builder,0,0)\n    p2=point!(builder,W,0)\n    p3=point!(builder,W,H)\n    p4=point!(builder,0,H)\n\n    # heuristic refinement around cylinder\n    refine_radius = 0.25\n    maxrefinefactor = 1//20\n    function unsuitable(x1,y1,x2,y2,x3,y3,area)\n        if area>maxvol*min(max(4*maxrefinefactor,abs((x1+x2+x3)/3 - 0.2)),1/maxrefinefactor)\n            return true\n        end\n        dist = sqrt( ( (x1+x2+x3)/3 - 0.2 )^2 + ( (y1+y2+y3)/3 - 0.2)^2) - 0.05\n        myarea= dist < refine_radius ? maxvol*max(maxrefinefactor,1-(refine_radius - dist)/refine_radius) : maxvol\n        if area>myarea\n           return true\n        else\n            return false\n        end\n    end\n\n    facetregion!(builder,1); facet!(builder,p1,p2)\n    facetregion!(builder,2); facet!(builder,p2,p3)\n    facetregion!(builder,3); facet!(builder,p3,p4)\n    facetregion!(builder,4); facet!(builder,p4,p1)\n    facetregion!(builder,5); circlehole!(builder, (0.2,0.2),0.05,n=n)\n\n    simplexgrid(builder,maxvolume=16*maxvol, unsuitable = unsuitable)\nend\n\nend","category":"page"},{"location":"examples/Example224_FlowAroundCylinder2D/","page":"224 : Flow around a cylinder 2D","title":"224 : Flow around a cylinder 2D","text":"","category":"page"},{"location":"examples/Example224_FlowAroundCylinder2D/","page":"224 : Flow around a cylinder 2D","title":"224 : Flow around a cylinder 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example224_FlowAroundCylinder2D/","page":"224 : Flow around a cylinder 2D","title":"224 : Flow around a cylinder 2D","text":"Default output:","category":"page"},{"location":"examples/Example224_FlowAroundCylinder2D/","page":"224 : Flow around a cylinder 2D","title":"224 : Flow around a cylinder 2D","text":"julia> Example224_FlowAroundCylinder2D.main()\n\nPDE-DESCRIPTION\n===============\n  system name = NSE problem (μ = 0.001)\n\n     id   | unknown name / equation name\n    [1]   | u / momentum equation \n    [2]   | p / incompressibility constraint \n\n  LHS block | PDEOperator(s)\n    [1,1]   | 0.001 (∇u,∇v) (APT = SymmetricBilinearForm, AT = ON_CELLS, regions = [0])\n            | ((R(u) ⋅ ∇) u, R(v)) [AD-Newton] [∂u] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n    [1,2]   | (div(v),q) (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n    [2,1]   | none\n    [2,2]   | none\n\n  RHS block | PDEOperator(s)\n     [1]    | ((R(u) ⋅ ∇) u, R(v)) [AD-Newton] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n     [2]    | none\n\n   BoundaryOperator[1] : BestapproxDirichletBoundary -> [4]\n                         HomogeneousDirichletBoundary -> [1, 3, 5]\n                          \n   BoundaryOperator[2] : \n\nProblem = \n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL  | TIME ASSEMBLY/SOLVE/TOTAL (s)\n\t-----------------------------------------------------------------------\n\t      1   | 2.682423e-17 | 1.899986e-03 | 1.06e+00/3.77e-01/1.45e+00\n\t      2   | 2.678785e-17 | 5.392003e-04 | 1.07e+00/3.03e-01/1.38e+00\n\t      3   | 2.665237e-17 | 2.926551e-05 | 1.07e+00/2.71e-01/1.34e+00\n\t      4   | 2.641507e-17 | 1.060798e-07 | 1.06e+00/3.06e-01/1.37e+00\n\t      5   | 2.702123e-17 | 1.119313e-12 | 1.06e+00/2.78e-01/1.34e+00\n\n[drag, lift] = [5.558270082490449, 0.010488569316220343]\np difference = [0.11865484048663101]","category":"page"},{"location":"examples/Example224_FlowAroundCylinder2D/","page":"224 : Flow around a cylinder 2D","title":"224 : Flow around a cylinder 2D","text":"(Image: )","category":"page"},{"location":"examples/Example215_ObstacleProblem2D/#:-Obstacle-Problem-2D","page":"215 : Obstacle Problem 2D","title":"215 : Obstacle Problem 2D","text":"","category":"section"},{"location":"examples/Example215_ObstacleProblem2D/","page":"215 : Obstacle Problem 2D","title":"215 : Obstacle Problem 2D","text":"(source code)","category":"page"},{"location":"examples/Example215_ObstacleProblem2D/","page":"215 : Obstacle Problem 2D","title":"215 : Obstacle Problem 2D","text":"This example computes the solution u of the nonlinear obstacle problem that seeks the minimiser of the energy functional","category":"page"},{"location":"examples/Example215_ObstacleProblem2D/","page":"215 : Obstacle Problem 2D","title":"215 : Obstacle Problem 2D","text":"beginaligned\n    E(u) = int_Omega lvert nabla u rvert^2 dx - int_Omega f u dx\nendaligned","category":"page"},{"location":"examples/Example215_ObstacleProblem2D/","page":"215 : Obstacle Problem 2D","title":"215 : Obstacle Problem 2D","text":"with some right-hand side f within the set of admissible functions that lie above an obstacle  chi","category":"page"},{"location":"examples/Example215_ObstacleProblem2D/","page":"215 : Obstacle Problem 2D","title":"215 : Obstacle Problem 2D","text":"beginaligned\n    mathcalK = lbrace u in H^1_0(Omega)  u geq chi rbrace\nendaligned","category":"page"},{"location":"examples/Example215_ObstacleProblem2D/","page":"215 : Obstacle Problem 2D","title":"215 : Obstacle Problem 2D","text":"The obstacle constraint is realised via a penalty term that is automatically differentiated for a Newton scheme.","category":"page"},{"location":"examples/Example215_ObstacleProblem2D/","page":"215 : Obstacle Problem 2D","title":"215 : Obstacle Problem 2D","text":"module Example215_ObstacleProblem2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# define obstacle and penalty kernel\nconst f = DataFunction([-1])\nconst χ! = (result,x) -> (result[1] = (cos(4*x[1]*π)*cos(4*x[2]*π) - 1)/20)\nfunction obstacle_penalty_kernel!(result, input, x)\n    χ!(result,x)\n    result[1] = min(0, input[1] - result[1])\n    return nothing\nend\n\nfunction main(; Plotter = nothing, verbosity = 0, penalty = 1e4, nrefinements = 6, FEType = H1P1{1})\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # choose initial mesh\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D),nrefinements)\n\n    # generate problem description\n    Problem = PDEDescription(\"obstacle problem\")\n    add_unknown!(Problem; unknown_name = \"u\", equation_name = \"obstacle problem\")\n    add_operator!(Problem, [1,1], LaplaceOperator(1.0; store = true))\n    add_operator!(Problem, [1,1], NonlinearForm([Identity], [1], Identity, obstacle_penalty_kernel!, [1,1]; name = \"eps^{-1} ||(u-χ)_||\", dependencies = \"X\", factor = penalty, quadorder = 2, ADnewton = true) )\n    add_boundarydata!(Problem, 1, [1,2,3,4], HomogeneousDirichletBoundary)\n    add_rhsdata!(Problem, 1, RhsOperator(Identity, [0], f; store = true))\n\n    # create finite element space and solution vector\n    FES = FESpace{FEType}(xgrid)\n    Solution = FEVector(\"u_h\",FES)\n\n    # solve\n    @show Problem Solution\n    solve!(Solution, Problem; maxiterations = 20)\n\n    # plot\n    p = GridVisualizer(; Plotter = Plotter, layout = (1,2), clear = true, resolution = (1000,500))\n    scalarplot!(p[1,1], xgrid, nodevalues_view(Solution[1])[1], levels = 6, title = \"u_h\")\n    scalarplot!(p[1,2], xgrid, view(nodevalues(Solution[1], Gradient; abs = true),1,:), levels = 0)\n    vectorplot!(p[1,2], xgrid, evaluate(PointEvaluator(Solution[1], Gradient)), spacing = 0.1, clear = false, title = \"∇u_h (abs + quiver)\")\nend\nend","category":"page"},{"location":"examples/Example215_ObstacleProblem2D/","page":"215 : Obstacle Problem 2D","title":"215 : Obstacle Problem 2D","text":"","category":"page"},{"location":"examples/Example215_ObstacleProblem2D/","page":"215 : Obstacle Problem 2D","title":"215 : Obstacle Problem 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example215_ObstacleProblem2D/","page":"215 : Obstacle Problem 2D","title":"215 : Obstacle Problem 2D","text":"Default output:","category":"page"},{"location":"examples/Example215_ObstacleProblem2D/","page":"215 : Obstacle Problem 2D","title":"215 : Obstacle Problem 2D","text":"julia> Example215_ObstacleProblem2D.main()\n\nPDE-DESCRIPTION\n===============\n  system name = obstacle problem\n\n     id   | unknown name / equation name\n    [1]   | u / obstacle problem \n\n  LHS block | PDEOperator(s)\n    [1,1]   | (∇u,∇v) (APT = SymmetricBilinearForm, AT = ON_CELLS, regions = [0])\n            | eps^{-1} ||(u-χ)_|| [AD-Newton] [∂u] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n\n  RHS block | PDEOperator(s)\n     [1]    | eps^{-1} ||(u-χ)_|| [AD-Newton] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n            | (Constant([-1]), id(v)) (APT = LinearForm, AT = ON_CELLS, regions = [0])\n\n   BoundaryOperator[1] : HomogeneousDirichletBoundary -> [1, 2, 3, 4]\n                          \n\nProblem = \nSolution = \nFEVector information\n====================\n   block  |  ndofs  | name (FEType) \n [    1]  |    8321 | u_h (H1P1{1})\n\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 1.322219e-15 | 1.741424e+00\n\t      2   | 1.200640e-15 | 6.066034e-02\n\t      3   | 9.375277e-16 | 4.055005e-02\n\t      4   | 7.607357e-16 | 2.849054e-02\n\t      5   | 5.438943e-16 | 1.826753e-02\n\t      6   | 5.204425e-16 | 9.343813e-03\n\t      7   | 4.949265e-16 | 3.137573e-03\n\t      8   | 4.910458e-16 | 3.914447e-04\n\t      9   | 4.962132e-16 | 1.034667e-05\n\t     10   | 4.875343e-16 | 4.875343e-16\n","category":"page"},{"location":"examples/Example215_ObstacleProblem2D/","page":"215 : Obstacle Problem 2D","title":"215 : Obstacle Problem 2D","text":"(Image: )","category":"page"},{"location":"examples/ExampleA05_DiffEQ/#A05-:-Comparison-with-DifferentialEquations.jl","page":"A05 : Comparison with DifferentialEquations.jl","title":"A05 : Comparison with DifferentialEquations.jl","text":"","category":"section"},{"location":"examples/ExampleA05_DiffEQ/","page":"A05 : Comparison with DifferentialEquations.jl","title":"A05 : Comparison with DifferentialEquations.jl","text":"(source code)","category":"page"},{"location":"examples/ExampleA05_DiffEQ/","page":"A05 : Comparison with DifferentialEquations.jl","title":"A05 : Comparison with DifferentialEquations.jl","text":"This example computes a transient velocity mathbfu solution of the nonlinear Poisson problem","category":"page"},{"location":"examples/ExampleA05_DiffEQ/","page":"A05 : Comparison with DifferentialEquations.jl","title":"A05 : Comparison with DifferentialEquations.jl","text":"beginaligned\nmathbfu_t - mathrmdiv((1+betamathbfu^2) nabla mathbfu)  = mathbff\nendaligned","category":"page"},{"location":"examples/ExampleA05_DiffEQ/","page":"A05 : Comparison with DifferentialEquations.jl","title":"A05 : Comparison with DifferentialEquations.jl","text":"with (some time-dependent) exterior force mathbff. The parameter beta steers the strength of the nonlinearity.","category":"page"},{"location":"examples/ExampleA05_DiffEQ/","page":"A05 : Comparison with DifferentialEquations.jl","title":"A05 : Comparison with DifferentialEquations.jl","text":"The time integration will be performed by a solver from DifferentialEquations.jl or by the iternal backward Euler method of GradientRobustMultiPhysics.","category":"page"},{"location":"examples/ExampleA05_DiffEQ/","page":"A05 : Comparison with DifferentialEquations.jl","title":"A05 : Comparison with DifferentialEquations.jl","text":"Note: To run this example the DifferentialEquations.jl package has to be installed.","category":"page"},{"location":"examples/ExampleA05_DiffEQ/","page":"A05 : Comparison with DifferentialEquations.jl","title":"A05 : Comparison with DifferentialEquations.jl","text":"module ExampleA05_DiffEQ\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing DifferentialEquations\n\n# problem data\nfunction exact_solution!(result,x, t)\n    result[1] = x[1]*x[2]*(1-t)\n    return nothing\nend\nfunction exact_gradient!(result,x, t)\n    result[1] = x[2]\n    result[2] = x[1]\n    result .*= 1-t\n    return nothing\nend\nfunction rhs!(beta)\n    function closure(result,x,t)\n        result[1] = -2*beta*(x[1]^3*x[2] + x[2]^3*x[1]) # = -div(beta*u^2*grad(u))\n        result .*= (1-t)^3\n        result[1] += -x[1]*x[2] ## = u_t\n        return nothing\n    end\nend\n\n# everything is wrapped in a main function\n# the last four parametes steer the solver from DifferentialEquations.jl\n# for beta = 0, abstol and reltol can be choosen much larger\nfunction main(; verbosity = 0, Plotter = nothing, nlevels = 3, timestep = 1e-1, T = 0.5, FEType = H1P1{1}, beta = 1,\n    use_diffeq::Bool = true, solver = Rosenbrock23(autodiff = false), adaptive_timestep = true,  abstol = 1e-3, reltol = 1e-3, testmode = false)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # initial grid and final time\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D),1);\n\n    # negotiate data functions to the package\n    u = DataFunction(exact_solution!, [1,1]; name = \"u\", dependencies = \"XT\", quadorder = 5)\n    ∇u = DataFunction(exact_gradient!, [2,1]; name = \"∇u\", dependencies = \"XT\", quadorder = 4)\n    u_rhs = DataFunction(rhs!(beta), [1,1]; name = \"f\", dependencies = \"XT\", quadorder = 5)\n\n    # prepare nonlinear expression (1+u^2)*grad(u)\n    function diffusion_kernel!(result, input)\n        # input = [u, grad(u)]\n        result[1] = (1+beta*input[1]^2)*input[2]\n        result[2] = (1+beta*input[1]^2)*input[3]\n        return nothing\n    end\n    nonlin_diffusion = NonlinearForm([Identity, Gradient], [1,1], Gradient, diffusion_kernel!, [2,3]; name = \"(1+ βu^2) ∇u ⋅ ∇v\", quadorder = 2, ADnewton = true)\n\n    # generate problem description and assign nonlinear operator and data\n    Problem = PDEDescription(beta == 0 ? \"linear Poisson problem\" : \"nonlinear Poisson problem\")\n    add_unknown!(Problem; unknown_name = \"u\", equation_name = beta == 0 ? \"linear Poisson problem\" : \"nonlinear Poisson equation\")\n    add_operator!(Problem, [1,1], beta == 0 ? LaplaceOperator() : nonlin_diffusion)\n    add_boundarydata!(Problem, 1, [1,2,3,4], BestapproxDirichletBoundary; data = u)\n    add_rhsdata!(Problem, 1,  RhsOperator(Identity, [0], u_rhs))\n\n    # define error evaluators\n    L2Error = L2ErrorIntegrator(Float64, u, Identity; time = T)\n    H1Error = L2ErrorIntegrator(Float64, ∇u, Gradient; time = T)\n    Results = zeros(Float64, nlevels, 2); NDofs = zeros(Int, nlevels)\n\n    # loop over levels\n    for level = 1 : nlevels\n\n        # refine grid\n        xgrid = uniform_refine(xgrid)\n\n        # generate FESpace and solution vector\n        FES = FESpace{FEType}(xgrid)\n        Solution = FEVector(\"u_h\",FES)\n\n        # set initial solution\n        interpolate!(Solution[1], u)\n\n        # generate time-dependent solver\n        sys = TimeControlSolver(Problem, Solution, BackwardEuler; timedependent_equations = [1], skip_update = [beta == 0 ? -1 : 1], nonlinear_iterations = beta == 0 ? 1 : 5)\n\n        if use_diffeq == true\n            # use time integration by DifferentialEquations\n            advance_until_time!(DifferentialEquations, sys, timestep, T; solver = solver, abstol = abstol, reltol = reltol, adaptive = adaptive_timestep)\n        else\n            # use time control solver by GradientRobustMultiPhysics\n            advance_until_time!(sys, timestep, T)\n        end\n\n        # compute L2 and H1 errors and save data\n        NDofs[level] = length(Solution.entries)\n        Results[level,1] = sqrt(evaluate(L2Error,Solution[1]))\n        Results[level,2] = sqrt(evaluate(H1Error,Solution[1]))\n    end\n\n    # print/plot convergence history\n    print_convergencehistory(NDofs, Results; X_to_h = X -> X.^(-1/2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\"])\n    plot_convergencehistory(NDofs, Results; add_h_powers = [1,2], X_to_h = X -> X.^(-1/2), Plotter = Plotter, ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\"])\nend\n\nfunction test()\n    return main(; use_diffeq = false, nlevels = 1, testmode = true)\nend\n\n\nend","category":"page"},{"location":"examples/ExampleA05_DiffEQ/","page":"A05 : Comparison with DifferentialEquations.jl","title":"A05 : Comparison with DifferentialEquations.jl","text":"","category":"page"},{"location":"examples/ExampleA05_DiffEQ/","page":"A05 : Comparison with DifferentialEquations.jl","title":"A05 : Comparison with DifferentialEquations.jl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/ExampleA05_DiffEQ/","page":"A05 : Comparison with DifferentialEquations.jl","title":"A05 : Comparison with DifferentialEquations.jl","text":"(Image: )","category":"page"},{"location":"examples/Example205_PlanarLatticeFlow2D/#:-Planar-Lattice-Flow-2D","page":"205 : Planar Lattice Flow 2D","title":"205 : Planar Lattice Flow 2D","text":"","category":"section"},{"location":"examples/Example205_PlanarLatticeFlow2D/","page":"205 : Planar Lattice Flow 2D","title":"205 : Planar Lattice Flow 2D","text":"(source code)","category":"page"},{"location":"examples/Example205_PlanarLatticeFlow2D/","page":"205 : Planar Lattice Flow 2D","title":"205 : Planar Lattice Flow 2D","text":"This example computes an approximation to the planar lattice flow test problem of the Stokes equations","category":"page"},{"location":"examples/Example205_PlanarLatticeFlow2D/","page":"205 : Planar Lattice Flow 2D","title":"205 : Planar Lattice Flow 2D","text":"beginaligned\n- nu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = mathbff\nmathrmdiv(mathbfu)  = 0\nendaligned","category":"page"},{"location":"examples/Example205_PlanarLatticeFlow2D/","page":"205 : Planar Lattice Flow 2D","title":"205 : Planar Lattice Flow 2D","text":"with an exterior force mathbff and some viscosity parameter nu and Dirichlet boundary data for mathbfu.","category":"page"},{"location":"examples/Example205_PlanarLatticeFlow2D/","page":"205 : Planar Lattice Flow 2D","title":"205 : Planar Lattice Flow 2D","text":"Here the exact data for the planar lattice flow","category":"page"},{"location":"examples/Example205_PlanarLatticeFlow2D/","page":"205 : Planar Lattice Flow 2D","title":"205 : Planar Lattice Flow 2D","text":"beginaligned\nmathbfu(xyt)  = exp(-8 pi^2 nu t) beginpmatrix sin(2 pi x) sin(2 pi y)  cos(2 pi x) cos(2 pi y) endpmatrix\np(xyt)  = exp(-8 pi^2 nu t) ( cos(4 pi x) - cos(4 pi y))  4\nendaligned","category":"page"},{"location":"examples/Example205_PlanarLatticeFlow2D/","page":"205 : Planar Lattice Flow 2D","title":"205 : Planar Lattice Flow 2D","text":"is prescribed at fixed time t = 0 with mathbff = mathbfu_t - nu Delta mathbfu.","category":"page"},{"location":"examples/Example205_PlanarLatticeFlow2D/","page":"205 : Planar Lattice Flow 2D","title":"205 : Planar Lattice Flow 2D","text":"In this example the Navier-Stokes equations are solved with a pressure-robust variant of the Bernardi–Raugel finite element method and the nonlinear convection term (that involves reconstruction operators) is automatically differentiated for a Newton iteration.","category":"page"},{"location":"examples/Example205_PlanarLatticeFlow2D/","page":"205 : Planar Lattice Flow 2D","title":"205 : Planar Lattice Flow 2D","text":"module Example205_PlanarLatticeFlow2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# exact solution\nfunction exact_velocity!(ν)\n    function closure(result,x,t)\n        result[1] = exp(-8*pi*pi*ν*t)*sin(2*pi*x[1])*sin(2*pi*x[2]);\n        result[2] = exp(-8*pi*pi*ν*t)*cos(2*pi*x[1])*cos(2*pi*x[2]);\n    end\nend\nfunction exact_pressure!(ν)\n    function closure(result,x, t)\n        result[1] = exp(-8*pi*pi*ν*t)*(cos(4*pi*x[1])-cos(4*pi*x[2])) / 4\n    end\nend\nfunction rhs!(ν)\n    function closure(result,x,t)\n        result[1] = 8*pi*pi*ν*exp(-8*pi*pi*ν*t)*sin(2*pi*x[1])*sin(2*pi*x[2]);\n        result[2] = 8*pi*pi*ν*exp(-8*pi*pi*ν*t)*cos(2*pi*x[1])*cos(2*pi*x[2]);\n    end\nend\n\n# everything is wrapped in a main function\nfunction main(; ν = 1e-3, nrefinements = 5, verbosity = 0, Plotter = nothing)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # generate a unit square mesh and refine\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D),nrefinements)\n\n    # negotiate data\n    u = DataFunction(exact_velocity!(ν), [2,2]; name = \"u\", dependencies = \"XT\", quadorder = 6)\n    p = DataFunction(exact_pressure!(ν), [1,2]; name = \"p\", dependencies = \"XT\", quadorder = 4)\n    f = DataFunction(rhs!(ν), [2,2]; name = \"f\", dependencies = \"XT\", quadorder = 4)\n\n    # set finite element and reconstruction operator\n    FEType = [H1BR{2}, H1P0{1}]; IdentityV = ReconstructionIdentity{HDIVBDM1{2}};\n\n    # setup a bestapproximation problem via a predefined prototype\n    Problem = PDEDescription(\"planar lattice flow problem\")\n    add_unknown!(Problem; equation_name = \"momentum equation\", unknown_name = \"velocity\")\n    add_unknown!(Problem; equation_name = \"incompressibility constraint\", unknown_name = \"pressure\")\n    add_operator!(Problem, [1,1], LaplaceOperator(ν; store = true))\n    add_operator!(Problem, [1,2], LagrangeMultiplier(Divergence))\n    add_operator!(Problem, [1,1], ConvectionOperator(1, IdentityV, 2, 2; testfunction_operator = IdentityV, auto_newton = true))\n    add_constraint!(Problem, FixedIntegralMean(2,0))\n    add_boundarydata!(Problem, 1, [1,2,3,4], BestapproxDirichletBoundary; data = u)\n    add_rhsdata!(Problem, 1, RhsOperator(IdentityV, [1], f))\n    @show Problem\n\n    # create finite element spaces and solve\n    FES = [FESpace{FEType[1]}(xgrid),FESpace{FEType[2]}(xgrid)]\n    Solution = FEVector([\"u_h\",\"p_h\"],FES)\n    solve!(Solution, Problem)\n\n    # calculate L2 errors for u and p\n    L2errorV = L2ErrorIntegrator(Float64, u, Identity)\n    L2errorP = L2ErrorIntegrator(Float64, p, Identity)\n    println(\"|| u - u_h || = $(sqrt(evaluate(L2errorV,Solution[1])))\")\n    println(\"|| p - p_h || = $(sqrt(evaluate(L2errorP,Solution[2])))\")\n\n    # plot\n    p = GridVisualizer(; Plotter = Plotter, layout = (1,2), clear = true, resolution = (1000,500))\n    scalarplot!(p[1,1],xgrid,view(nodevalues(Solution[1]; abs = true),1,:), levels = 5)\n    vectorplot!(p[1,1],xgrid,evaluate(PointEvaluator(Solution[1], Identity)), spacing = 0.05, clear = false, title = \"u_h (abs + quiver)\")\n    scalarplot!(p[1,2],xgrid,view(nodevalues(Solution[2]),1,:), levels = 11, title = \"p_h\")\nend\n\nend","category":"page"},{"location":"examples/Example205_PlanarLatticeFlow2D/","page":"205 : Planar Lattice Flow 2D","title":"205 : Planar Lattice Flow 2D","text":"","category":"page"},{"location":"examples/Example205_PlanarLatticeFlow2D/","page":"205 : Planar Lattice Flow 2D","title":"205 : Planar Lattice Flow 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example205_PlanarLatticeFlow2D/","page":"205 : Planar Lattice Flow 2D","title":"205 : Planar Lattice Flow 2D","text":"Default output:","category":"page"},{"location":"examples/Example205_PlanarLatticeFlow2D/","page":"205 : Planar Lattice Flow 2D","title":"205 : Planar Lattice Flow 2D","text":"julia> Example205_PlanarLatticeFlow2D.main()\n\nPDE-DESCRIPTION\n===============\n  system name = planar lattice flow problem\n\n     id   | unknown name / equation name\n    [1]   | velocity / momentum equation \n    [2]   | pressure / incompressibility constraint \n\n  LHS block | PDEOperator(s)\n    [1,1]   | 0.001 (∇u,∇v) (APT = SymmetricBilinearForm, AT = ON_CELLS, regions = [0])\n            | ((R(u) ⋅ ∇) u, R(v)) [AD-Newton] [∂velocity] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n    [1,2]   | (div(v),q) (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n    [2,1]   | none\n    [2,2]   | none\n\n  RHS block | PDEOperator(s)\n     [1]    | ((R(u) ⋅ ∇) u, R(v)) [AD-Newton] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n            | (f, R(v)) (APT = LinearForm, AT = ON_CELLS, regions = [1])\n     [2]    | none\n\n   BoundaryOperator[1] : BestapproxDirichletBoundary -> [1, 2, 3, 4]\n                         \n   BoundaryOperator[2] : \n\n  GlobalConstraints[1] : Mean[2] != 0 \nProblem = \n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 4.640580e-17 | 9.171721e-02\n\t      2   | 1.062347e-16 | 1.005659e-06\n\t      3   | 1.040192e-16 | 2.431843e-10\n\t      4   | 1.056636e-16 | 1.469293e-16\n\n|| u - u_h || = 0.002188090113223546\n|| p - p_h || = 0.016419949166049","category":"page"},{"location":"examples/Example205_PlanarLatticeFlow2D/","page":"205 : Planar Lattice Flow 2D","title":"205 : Planar Lattice Flow 2D","text":"(Image: )","category":"page"},{"location":"","page":"Index","title":"Index","text":"Modules = [GradientRobustMultiPhysics]\nOrder   = [:function, :type]","category":"page"},{"location":"examples/Example250_LevelSetMethod2D/#:-Level-Set-Method-2D","page":"250 : Level Set Method 2D","title":"250 : Level Set Method 2D","text":"","category":"section"},{"location":"examples/Example250_LevelSetMethod2D/","page":"250 : Level Set Method 2D","title":"250 : Level Set Method 2D","text":"(source code)","category":"page"},{"location":"examples/Example250_LevelSetMethod2D/","page":"250 : Level Set Method 2D","title":"250 : Level Set Method 2D","text":"This example studies the level-set method of some level function mathbfphi convected in time via the equation","category":"page"},{"location":"examples/Example250_LevelSetMethod2D/","page":"250 : Level Set Method 2D","title":"250 : Level Set Method 2D","text":"beginaligned\nphi_t + mathbfu cdot nabla phi  = 0\nendaligned","category":"page"},{"location":"examples/Example250_LevelSetMethod2D/","page":"250 : Level Set Method 2D","title":"250 : Level Set Method 2D","text":"Here this is tested with the (conservative) initial level set function phi(x) = 05*tanh((lvert x - (025025) rvert - 01)(2ϵ) + 1) such that the level phi equiv 05 forms a circle which is then convected by the velocity mathbfu = (051)^T. No reinitialisation step is performed.","category":"page"},{"location":"examples/Example250_LevelSetMethod2D/","page":"250 : Level Set Method 2D","title":"250 : Level Set Method 2D","text":"In each couple of timestep the plot is updated (where an upscaled P1 interpolation of the higher order solution is used).","category":"page"},{"location":"examples/Example250_LevelSetMethod2D/","page":"250 : Level Set Method 2D","title":"250 : Level Set Method 2D","text":"module Example250_LevelSetMethod2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\nconst convection = DataFunction([0.5,1])\nconst ϵ = 0.05\nconst ϕ_0 = DataFunction((result,x) -> (result[1] = 1/2 * (tanh((sqrt((x[1]-0.25)^2 + (x[2]-0.25)^2) - 0.1)/(2*ϵ))+1)), [1, 2]; dependencies = \"X\", quadorder = 3)\nconst ϕ_bnd = DataFunction([1])\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, Plotter = nothing, timestep = 1//500, T = 3//10, FEType = H1P3{1,2}, nref = 3, time_integration_rule = CrankNicolson)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # initial grid and final time\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D),nref)\n\n    # define main level set problem\n    Problem = PDEDescription(\"level set problem\")\n    add_unknown!(Problem; unknown_name = \"ϕ\", equation_name = \"convection equation\")\n    add_operator!(Problem, [1,1], ConvectionOperator(convection,1))\n    add_boundarydata!(Problem, 1, [1,2,3,4], InterpolateDirichletBoundary; data = ϕ_bnd)\n\n    # generate FESpace and solution vector and interpolate initial state\n    Solution = FEVector(\"u_h\",FESpace{FEType}(xgrid))\n    interpolate!(Solution[1], ϕ_0)\n\n    # generate time-dependent solver\n    TProblem = TimeControlSolver(Problem, Solution, time_integration_rule; timedependent_equations = [1], skip_update = [-1], T_time = typeof(timestep))\n\n    # init plot ans upscaling\n    p = GridVisualizer(; Plotter = Plotter, layout = (1,3), clear = true, resolution = (1200,400))\n    xgrid_upscale = uniform_refine(xgrid,5-nref)\n    SolutionUpscaled = FEVector{Float16}(\"u_h (upscaled)\",FESpace{H1P1{1}}(xgrid_upscale))\n    nodevals = nodevalues_view(SolutionUpscaled[1])\n    gridplot!(p[1,1], xgrid, linewidth = 1, title = \"compute grid\")\n\n    # setup timestep-wise plot as a do_after_timestep callback function\n    plot_every::Int = ceil(1//100 / timestep)\n    function do_after_each_timestep(step, statistics)\n        if step % plot_every == 0\n            interpolate!(SolutionUpscaled[1],Solution[1])\n            scalarplot!((step == 0) ? p[1,2] : p[1,3], xgrid_upscale, nodevals[1], levels = [0.5], flimits = [-0.05,1.05], colorbarticks = [0, 0.25, 0.5, 0.75, 1], title = \"ϕ (t = $(Float64(TProblem.ctime)))\")\n        end\n    end\n\n    # plot initial state\n    do_after_each_timestep(0,nothing)\n\n    # use time control solver by GradientRobustMultiPhysics\n    advance_until_time!(TProblem, timestep, T; do_after_each_timestep = do_after_each_timestep)\nend\n\nend","category":"page"},{"location":"examples/Example250_LevelSetMethod2D/","page":"250 : Level Set Method 2D","title":"250 : Level Set Method 2D","text":"","category":"page"},{"location":"examples/Example250_LevelSetMethod2D/","page":"250 : Level Set Method 2D","title":"250 : Level Set Method 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example250_LevelSetMethod2D/","page":"250 : Level Set Method 2D","title":"250 : Level Set Method 2D","text":"Default output:","category":"page"},{"location":"examples/Example250_LevelSetMethod2D/","page":"250 : Level Set Method 2D","title":"250 : Level Set Method 2D","text":"julia> Example250_LevelSetMethod2D.main()\n\n\t  STEP  |    TIME    | LSRESIDUAL |  RUNTIME  |   CHANGE        \n\t        |            |  (total)   |    (s)          ϕ     \n\t     1  | 2.0000e-03 | 7.9447e-15 | 2.324e+00 | 7.2315e-02 \n\t     2  | 4.0000e-03 | 8.0081e-15 | 2.197e-02 | 7.2223e-02 \n\t     3  | 6.0000e-03 | 7.5385e-15 | 6.601e-04 | 7.2140e-02 \n\t     4  | 8.0000e-03 | 8.2707e-15 | 6.285e-04 | 7.2067e-02 \n\t     5  | 1.0000e-02 | 7.7563e-15 | 8.160e-04 | 7.2003e-02 \n\t     6  | 1.2000e-02 | 8.0045e-15 | 7.292e-04 | 7.1944e-02 \n\t     7  | 1.4000e-02 | 8.1248e-15 | 6.344e-04 | 7.1888e-02 \n\t     8  | 1.6000e-02 | 7.8961e-15 | 6.472e-04 | 7.1832e-02 \n\t     9  | 1.8000e-02 | 7.5633e-15 | 6.653e-04 | 7.1775e-02 \n\t    10  | 2.0000e-02 | 8.3904e-15 | 6.306e-04 | 7.1715e-02 \n\t    11  | 2.2000e-02 | 8.1157e-15 | 7.334e-04 | 7.1652e-02 \n\t    12  | 2.4000e-02 | 8.7160e-15 | 6.567e-04 | 7.1589e-02 \n\t    13  | 2.6000e-02 | 8.1493e-15 | 6.503e-04 | 7.1528e-02 \n\t    14  | 2.8000e-02 | 8.1410e-15 | 6.390e-04 | 7.1473e-02 \n\t    15  | 3.0000e-02 | 8.7403e-15 | 6.293e-04 | 7.1429e-02 \n\t    16  | 3.2000e-02 | 8.1281e-15 | 6.929e-04 | 7.1398e-02 \n\t    17  | 3.4000e-02 | 8.3912e-15 | 6.437e-04 | 7.1384e-02 \n\t    18  | 3.6000e-02 | 8.4184e-15 | 8.245e-04 | 7.1388e-02 \n\t    19  | 3.8000e-02 | 8.1205e-15 | 6.720e-04 | 7.1409e-02 \n\t    20  | 4.0000e-02 | 8.7943e-15 | 6.635e-04 | 7.1446e-02 \n\t    21  | 4.2000e-02 | 8.0984e-15 | 7.232e-04 | 7.1494e-02 \n\t    22  | 4.4000e-02 | 8.4689e-15 | 6.307e-04 | 7.1547e-02 \n\t    23  | 4.6000e-02 | 8.8098e-15 | 6.767e-04 | 7.1600e-02 \n\t    24  | 4.8000e-02 | 8.2034e-15 | 6.231e-04 | 7.1646e-02 \n\t    25  | 5.0000e-02 | 8.3167e-15 | 6.555e-04 | 7.1679e-02 \n\t    26  | 5.2000e-02 | 9.0804e-15 | 7.703e-04 | 7.1695e-02 \n\t    27  | 5.4000e-02 | 8.1710e-15 | 6.298e-04 | 7.1691e-02 \n\t    28  | 5.6000e-02 | 8.3550e-15 | 6.401e-04 | 7.1667e-02 \n\t    29  | 5.8000e-02 | 7.9653e-15 | 8.253e-04 | 7.1624e-02 \n\t    30  | 6.0000e-02 | 8.2667e-15 | 6.274e-04 | 7.1566e-02 \n\t    31  | 6.2000e-02 | 8.2035e-15 | 7.667e-04 | 7.1498e-02 \n\t    32  | 6.4000e-02 | 8.5020e-15 | 6.542e-04 | 7.1425e-02 \n\t    33  | 6.6000e-02 | 8.0852e-15 | 6.495e-04 | 7.1353e-02 \n\t    34  | 6.8000e-02 | 8.0404e-15 | 6.396e-04 | 7.1287e-02 \n\t    35  | 7.0000e-02 | 8.6666e-15 | 6.285e-04 | 7.1231e-02 \n\t    36  | 7.2000e-02 | 8.5441e-15 | 6.850e-04 | 7.1187e-02 \n\t    37  | 7.4000e-02 | 8.0739e-15 | 6.477e-04 | 7.1157e-02 \n\t    38  | 7.6000e-02 | 7.9193e-15 | 8.239e-04 | 7.1141e-02 \n\t    39  | 7.8000e-02 | 7.9846e-15 | 9.760e-04 | 7.1137e-02 \n\t    40  | 8.0000e-02 | 7.8732e-15 | 8.290e-04 | 7.1144e-02 \n\t    41  | 8.2000e-02 | 8.3198e-15 | 6.799e-04 | 7.1159e-02 \n\t    42  | 8.4000e-02 | 8.1315e-15 | 6.552e-04 | 7.1182e-02 \n\t    43  | 8.6000e-02 | 7.9631e-15 | 7.148e-04 | 7.1211e-02 \n\t    44  | 8.8000e-02 | 8.0321e-15 | 6.347e-04 | 7.1246e-02 \n\t    45  | 9.0000e-02 | 8.4156e-15 | 6.429e-04 | 7.1288e-02 \n\t    46  | 9.2000e-02 | 8.2103e-15 | 7.124e-04 | 7.1339e-02 \n\t    47  | 9.4000e-02 | 8.0073e-15 | 9.635e-04 | 7.1398e-02 \n\t    48  | 9.6000e-02 | 8.0860e-15 | 6.520e-04 | 7.1468e-02 \n\t    49  | 9.8000e-02 | 7.9644e-15 | 6.489e-04 | 7.1547e-02 \n\t    50  | 1.0000e-01 | 8.2562e-15 | 6.689e-04 | 7.1634e-02 \n\t    51  | 1.0200e-01 | 8.3451e-15 | 7.445e-04 | 7.1727e-02 \n\t    52  | 1.0400e-01 | 8.3198e-15 | 6.687e-04 | 7.1821e-02 \n\t    53  | 1.0600e-01 | 8.2382e-15 | 8.246e-04 | 7.1911e-02 \n\t    54  | 1.0800e-01 | 7.8487e-15 | 6.580e-04 | 7.1991e-02 \n\t    55  | 1.1000e-01 | 8.0819e-15 | 6.853e-04 | 7.2055e-02 \n\t    56  | 1.1200e-01 | 8.2387e-15 | 9.260e-04 | 7.2098e-02 \n\t    57  | 1.1400e-01 | 8.1048e-15 | 6.966e-04 | 7.2116e-02 \n\t    58  | 1.1600e-01 | 8.4979e-15 | 6.272e-04 | 7.2107e-02 \n\t    59  | 1.1800e-01 | 8.1788e-15 | 9.120e-04 | 7.2071e-02 \n\t    60  | 1.2000e-01 | 8.9663e-15 | 6.560e-04 | 7.2010e-02 \n\t    61  | 1.2200e-01 | 8.1448e-15 | 7.303e-04 | 7.1928e-02 \n\t    62  | 1.2400e-01 | 8.3592e-15 | 6.319e-04 | 7.1831e-02 \n\t    63  | 1.2600e-01 | 9.0216e-15 | 6.335e-04 | 7.1724e-02 \n\t    64  | 1.2800e-01 | 8.7479e-15 | 6.223e-04 | 7.1614e-02 \n\t    65  | 1.3000e-01 | 7.7560e-15 | 6.801e-04 | 7.1507e-02 \n\t    66  | 1.3200e-01 | 8.4804e-15 | 9.662e-04 | 7.1407e-02 \n\t    67  | 1.3400e-01 | 8.8491e-15 | 6.398e-04 | 7.1317e-02 \n\t    68  | 1.3600e-01 | 8.1500e-15 | 8.455e-04 | 7.1238e-02 \n\t    69  | 1.3800e-01 | 7.6066e-15 | 6.884e-04 | 7.1172e-02 \n\t    70  | 1.4000e-01 | 8.7340e-15 | 6.442e-04 | 7.1116e-02 \n\t    71  | 1.4200e-01 | 8.0282e-15 | 7.060e-04 | 7.1069e-02 \n\t    72  | 1.4400e-01 | 8.3316e-15 | 7.037e-04 | 7.1029e-02 \n\t    73  | 1.4600e-01 | 8.6942e-15 | 6.400e-04 | 7.0995e-02 \n\t    74  | 1.4800e-01 | 8.2648e-15 | 6.365e-04 | 7.0966e-02 \n\t    75  | 1.5000e-01 | 8.3351e-15 | 6.232e-04 | 7.0941e-02 \n\t    76  | 1.5200e-01 | 8.4013e-15 | 6.756e-04 | 7.0924e-02 \n\t    77  | 1.5400e-01 | 7.6411e-15 | 6.284e-04 | 7.0915e-02 \n\t    78  | 1.5600e-01 | 8.3194e-15 | 6.636e-04 | 7.0916e-02 \n\t    79  | 1.5800e-01 | 8.2039e-15 | 6.168e-04 | 7.0931e-02 \n\t    80  | 1.6000e-01 | 8.6203e-15 | 6.280e-04 | 7.0960e-02 \n\t    81  | 1.6200e-01 | 8.4791e-15 | 7.339e-04 | 7.1003e-02 \n\t    82  | 1.6400e-01 | 8.2530e-15 | 6.281e-04 | 7.1060e-02 \n\t    83  | 1.6600e-01 | 8.1489e-15 | 6.500e-04 | 7.1128e-02 \n\t    84  | 1.6800e-01 | 8.5268e-15 | 6.469e-04 | 7.1203e-02 \n\t    85  | 1.7000e-01 | 7.6637e-15 | 8.610e-04 | 7.1280e-02 \n\t    86  | 1.7200e-01 | 8.0367e-15 | 6.776e-04 | 7.1354e-02 \n\t    87  | 1.7400e-01 | 8.2147e-15 | 6.556e-04 | 7.1421e-02 \n\t    88  | 1.7600e-01 | 7.8506e-15 | 6.240e-04 | 7.1476e-02 \n\t    89  | 1.7800e-01 | 7.9956e-15 | 6.661e-04 | 7.1517e-02 \n\t    90  | 1.8000e-01 | 7.9286e-15 | 7.000e-04 | 7.1543e-02 \n\t    91  | 1.8200e-01 | 8.3988e-15 | 7.547e-04 | 7.1555e-02 \n\t    92  | 1.8400e-01 | 8.6335e-15 | 6.680e-04 | 7.1554e-02 \n\t    93  | 1.8600e-01 | 8.5869e-15 | 6.348e-04 | 7.1544e-02 \n\t    94  | 1.8800e-01 | 7.6448e-15 | 8.527e-04 | 7.1528e-02 \n\t    95  | 1.9000e-01 | 8.7315e-15 | 7.209e-04 | 7.1510e-02 \n\t    96  | 1.9200e-01 | 7.9731e-15 | 7.094e-04 | 7.1494e-02 \n\t    97  | 1.9400e-01 | 8.5374e-15 | 6.431e-04 | 7.1482e-02 \n\t    98  | 1.9600e-01 | 8.0398e-15 | 7.200e-04 | 7.1475e-02 \n\t    99  | 1.9800e-01 | 8.0401e-15 | 6.501e-04 | 7.1473e-02 \n\t   100  | 2.0000e-01 | 7.6005e-15 | 6.242e-04 | 7.1475e-02 \n\t   101  | 2.0200e-01 | 8.5212e-15 | 7.223e-04 | 7.1479e-02 \n\t   102  | 2.0400e-01 | 8.0605e-15 | 8.432e-04 | 7.1483e-02 \n\t   103  | 2.0600e-01 | 7.8212e-15 | 8.619e-04 | 7.1485e-02 \n\t   104  | 2.0800e-01 | 8.3670e-15 | 8.513e-04 | 7.1485e-02 \n\t   105  | 2.1000e-01 | 8.4407e-15 | 6.313e-04 | 7.1480e-02 \n\t   106  | 2.1200e-01 | 8.2272e-15 | 7.295e-04 | 7.1473e-02 \n\t   107  | 2.1400e-01 | 8.3183e-15 | 6.420e-04 | 7.1464e-02 \n\t   108  | 2.1600e-01 | 7.9198e-15 | 6.318e-04 | 7.1454e-02 \n\t   109  | 2.1800e-01 | 8.0262e-15 | 6.232e-04 | 7.1448e-02 \n\t   110  | 2.2000e-01 | 7.8739e-15 | 6.306e-04 | 7.1446e-02 \n\t   111  | 2.2200e-01 | 8.1606e-15 | 9.051e-04 | 7.1451e-02 \n\t   112  | 2.2400e-01 | 8.1884e-15 | 6.624e-04 | 7.1462e-02 \n\t   113  | 2.2600e-01 | 8.7440e-15 | 6.372e-04 | 7.1479e-02 \n\t   114  | 2.2800e-01 | 8.0946e-15 | 6.365e-04 | 7.1501e-02 \n\t   115  | 2.3000e-01 | 8.0410e-15 | 6.649e-04 | 7.1524e-02 \n\t   116  | 2.3200e-01 | 8.0339e-15 | 6.889e-04 | 7.1547e-02 \n\t   117  | 2.3400e-01 | 8.3388e-15 | 6.805e-04 | 7.1564e-02 \n\t   118  | 2.3600e-01 | 8.6610e-15 | 6.675e-04 | 7.1575e-02 \n\t   119  | 2.3800e-01 | 7.9890e-15 | 6.255e-04 | 7.1576e-02 \n\t   120  | 2.4000e-01 | 8.2867e-15 | 6.245e-04 | 7.1567e-02 \n\t   121  | 2.4200e-01 | 8.2348e-15 | 6.918e-04 | 7.1548e-02 \n\t   122  | 2.4400e-01 | 8.0110e-15 | 6.456e-04 | 7.1522e-02 \n\t   123  | 2.4600e-01 | 8.3296e-15 | 6.613e-04 | 7.1492e-02 \n\t   124  | 2.4800e-01 | 8.9489e-15 | 7.047e-04 | 7.1461e-02 \n\t   125  | 2.5000e-01 | 7.8819e-15 | 6.774e-04 | 7.1433e-02 \n\t   126  | 2.5200e-01 | 8.1185e-15 | 6.919e-04 | 7.1412e-02 \n\t   127  | 2.5400e-01 | 8.4607e-15 | 6.299e-04 | 7.1401e-02 \n\t   128  | 2.5600e-01 | 7.8934e-15 | 8.358e-04 | 7.1402e-02 \n\t   129  | 2.5800e-01 | 8.1987e-15 | 6.589e-04 | 7.1415e-02 \n\t   130  | 2.6000e-01 | 8.1591e-15 | 8.236e-04 | 7.1438e-02 \n\t   131  | 2.6200e-01 | 8.2343e-15 | 7.910e-04 | 7.1470e-02 \n\t   132  | 2.6400e-01 | 8.2967e-15 | 8.351e-04 | 7.1508e-02 \n\t   133  | 2.6600e-01 | 8.4078e-15 | 6.422e-04 | 7.1548e-02 \n\t   134  | 2.6800e-01 | 8.5883e-15 | 6.722e-04 | 7.1588e-02 \n\t   135  | 2.7000e-01 | 9.2341e-15 | 6.872e-04 | 7.1624e-02 \n\t   136  | 2.7200e-01 | 7.4751e-15 | 7.074e-04 | 7.1654e-02 \n\t   137  | 2.7400e-01 | 8.3896e-15 | 6.511e-04 | 7.1679e-02 \n\t   138  | 2.7600e-01 | 8.0399e-15 | 6.783e-04 | 7.1698e-02 \n\t   139  | 2.7800e-01 | 8.3174e-15 | 8.570e-04 | 7.1711e-02 \n\t   140  | 2.8000e-01 | 7.8139e-15 | 6.459e-04 | 7.1720e-02 \n\t   141  | 2.8200e-01 | 8.3219e-15 | 8.240e-04 | 7.1725e-02 \n\t   142  | 2.8400e-01 | 8.2889e-15 | 6.367e-04 | 7.1729e-02 \n\t   143  | 2.8600e-01 | 8.4622e-15 | 6.814e-04 | 7.1731e-02 \n\t   144  | 2.8800e-01 | 8.6145e-15 | 6.229e-04 | 7.1730e-02 \n\t   145  | 2.9000e-01 | 8.4573e-15 | 6.736e-04 | 7.1726e-02 \n\t   146  | 2.9200e-01 | 8.2438e-15 | 7.130e-04 | 7.1717e-02 \n\t   147  | 2.9400e-01 | 8.4210e-15 | 6.733e-04 | 7.1701e-02 \n\t   148  | 2.9600e-01 | 8.5110e-15 | 6.541e-04 | 7.1676e-02 \n\t   149  | 2.9800e-01 | 7.9287e-15 | 8.258e-04 | 7.1641e-02 \n\t   150  | 3.0000e-01 | 8.1808e-15 | 8.647e-04 | 7.1595e-02 ","category":"page"},{"location":"examples/Example250_LevelSetMethod2D/","page":"250 : Level Set Method 2D","title":"250 : Level Set Method 2D","text":"(Image: )","category":"page"},{"location":"userdata/#User-Data-and-Actions","page":"User Data and Actions","title":"User Data and Actions","text":"","category":"section"},{"location":"userdata/","page":"User Data and Actions","title":"User Data and Actions","text":"There is a variety of different user data, like scalar- and vector-valued constants, time-dependent data, region-dependent data or plain functions that depend on the the space coordinates. Also dependency on the item number of the reference coordinates of the quadrature point in the quadrature item are sometimes desireable. To allow for flexible user-specified data, all functions have to be negotiated by the UserData interface that fixes the order and number of the arguments in the interface via a user-given substring of \"XTRIL\" where each character stands for a dependency. The following table explains the meaning of each character.","category":"page"},{"location":"userdata/","page":"User Data and Actions","title":"User Data and Actions","text":"Character Explanation\nX depends on (vector-valued) space coordinates\nT depends on time coordinate\nR depends on region number\nI depends on item number\nL depends on local coordinates in reference geometry of item","category":"page"},{"location":"userdata/","page":"User Data and Actions","title":"User Data and Actions","text":"Also note that all functions are expected to write their result into the first argument.","category":"page"},{"location":"userdata/#Data-Function","page":"User Data and Actions","title":"Data Function","text":"","category":"section"},{"location":"userdata/","page":"User Data and Actions","title":"User Data and Actions","text":"The simplest form of user data is called DataFunction which allows additional dependencies on space or time coordinates. The following tables lists all allowed substrings of \"XTRIL\" and the expected interface of the function provided by the user.","category":"page"},{"location":"userdata/","page":"User Data and Actions","title":"User Data and Actions","text":"dependency string Expected interface\n\"\" function f!(result) ... end  (constant data)\n\"X\" function f!(result,x) ... end  (space-dependent data)\n\"T\" function f!(result,t) ... end  (time-dependent constant-in-space data)\n\"XT\" function f!(result,x,t) ... end  (space and time-dependent data)","category":"page"},{"location":"userdata/","page":"User Data and Actions","title":"User Data and Actions","text":"DataFunctions can be used to define boundary data, right-hand side functions and can be interpolated by the finite element standard interpolations.","category":"page"},{"location":"userdata/","page":"User Data and Actions","title":"User Data and Actions","text":"DataFunction","category":"page"},{"location":"userdata/#GradientRobustMultiPhysics.DataFunction","page":"User Data and Actions","title":"GradientRobustMultiPhysics.DataFunction","text":"function DataFunction(\n    f::Function,                    # user function with interface f(result, _other dependencies_)\n    dimensions::Array{Int,1};       # [length(result), length(x)]\n    name = \"user data function\",\n    dependencies::String = \"\",      # substring of \"XT\" encoding other dependencies in f interface\n    quadorder::Int = 0)             # quadrature order added to operator's quadorder that evalute f\n\nProvides a negotation interface for some user-defined function that  can be used in integrate! and boundary or right-hand side data assignments. The function f has to obey the interface\n\nf(result, [X, T])\n\nwhere the parameters X (= space coordinates) and T ( = time) are optional. Which of them are used has to be specified in the  String dependencies. The array dimensions specifies the expected length of result and input and quadorder determines the additional quadrature order to be used if this function is involved in some quadrature-requireing procedure.\n\n\n\n\n\nfunction DataFunction(c::Array{<:Real,1}; name = \"constant user data\", quadorder::Int = 0)\n\nDirectly generates a DataFunction from a given array c, i.e. a DataFunction that is constant and has no dependencies on x or t.\n\n\n\n\n\n","category":"function"},{"location":"userdata/#Extended-Data-Function","page":"User Data and Actions","title":"Extended Data Function","text":"","category":"section"},{"location":"userdata/","page":"User Data and Actions","title":"User Data and Actions","text":"There are also ExtendedDataFunction that allow the additional dependencies R (region), I (item number) and L (local coordinates). The dependencies are stated via a string in the constructor that should be a substring of \"XTRIL\". However, extended data functions cannot be used everywhere.","category":"page"},{"location":"userdata/","page":"User Data and Actions","title":"User Data and Actions","text":"ExtendedDataFunction","category":"page"},{"location":"userdata/#GradientRobustMultiPhysics.ExtendedDataFunction","page":"User Data and Actions","title":"GradientRobustMultiPhysics.ExtendedDataFunction","text":"function ExtendedDataFunction(\n    f::Function,                    # user function with interface f(result, _other dependencies_)\n    dimensions::Array{Int,1};       # [length(result), length(x)]\n    name = \"user data function\",\n    dependencies::String = \"\",      # substring of \"XTRIL\" encoding other dependencies in f interface\n    quadorder::Int = 0)             # quadrature order added to operator's quadorder that evalute f\n\nProvides a negotation interface for some data function with extended dependencies (region number, item number and local coordinates) that can be used in integrate!. The function f has to obey the interface\n\nf(result, [X, T, R, I, L])\n\nwhere the parameters X (= space coordinates) and T ( = time) are optional. Which of them are used has to be specified in the  String dependencies. The array dimensions specifies the expected length of result and X (if X-depdendent, otherwise will be ignored) and quadorder determines the additional quadrature order to be used if this function is involved in some quadrature-requireing procedure.\n\n\n\n\n\n","category":"function"},{"location":"userdata/#Action-Kernel","page":"User Data and Actions","title":"Action Kernel","text":"","category":"section"},{"location":"userdata/","page":"User Data and Actions","title":"User Data and Actions","text":"Another form of user data are action kernels that are used to define an AbstractAction. Actions modify (usually a subset of) arguments of Assembly Patterns and so allow parameter-dependent assemblies.  Also, a trilinear form always needs an action that holds instructions how to prepare the first two arguments such that it can be evaluated with the testfunction operator. To use them, the user defines some kernel function for the action that has the interface. Kernel functions also allow the full range of dependencies, hence any substring of \"XTRIL\".","category":"page"},{"location":"userdata/","page":"User Data and Actions","title":"User Data and Actions","text":"However, between the result argument and the further dependencies they get an input argument which (during assembly) carries the operator-evaluations of the arguments that go into the action. Hence the usual interface of a action kernel function looks like this:","category":"page"},{"location":"userdata/","page":"User Data and Actions","title":"User Data and Actions","text":"function action_kernel!(result,input,[X,T,R,I,L])\n    # result = modified input, e.g.\n    # multiplication with some parameter that can depend on\n    # X = space coordinates\n    # T = time\n    # R = region number\n    # I = item number (cell, face or edge number depending on assembly type)\n    # L = local coordinates on item reference domain\nend","category":"page"},{"location":"userdata/","page":"User Data and Actions","title":"User Data and Actions","text":"During assembly, input (in general) takes the role of all non-testfunction arguments and the result vector will be the one that is multiplied with the testfunctions. Additionally, the kernel function can depend on X, T, R, I and L as specified above. Once again note, that time-dependency of the kernel function is inherited to the action and later to the whole PDEOperator and so triggers reassembly of the associated PDEoperator in each time step.","category":"page"},{"location":"userdata/","page":"User Data and Actions","title":"User Data and Actions","text":"ActionKernel","category":"page"},{"location":"userdata/#GradientRobustMultiPhysics.ActionKernel","page":"User Data and Actions","title":"GradientRobustMultiPhysics.ActionKernel","text":"function ActionKernel(\n    f::Function,                    # user function with interface f(result, _other dependencies_)\n    dimensions::Array{Int,1};       # [length(result), length(input)]\n    name = \"user action kernel\",\n    dependencies::String = \"\",      # substring of \"XTRIL\" encoding other dependencies in f interface\n    quadorder::Int = 0)             # quadrature order added to actions/operators that evaluate this action kernel\n\nProvides a negotation interface for some function that can be used in the Action constructor to define a user-defined operator action. The function has to obey the interface\n\nf(result, input, [X, T, R, I, L])\n\nwhere the parameters X (= space coordinates), T ( = time), R (= region number), I (= item number), L (= local coordinates) are optional. Which of them are used has to be specified in the String dependencies.\n\nThe input vector usually provides the FunctionOperator evaluations of (a subset of) the ansatz arguments of the assembly pattern where the action is used. The array dimensions specifies the expected length of result and input and quadorder determines the additional quadrature order to be used if this function (or its derived action) is involved in an assembly process.\n\n\n\n\n\n","category":"function"},{"location":"userdata/#Action","page":"User Data and Actions","title":"Action","text":"","category":"section"},{"location":"userdata/","page":"User Data and Actions","title":"User Data and Actions","text":"Actions are used by abstract user-defined PDEOperators and consist of an action kernel plus some additional infrastructure. To generate an action from an action kernel or directly from a function works via the following constructors.","category":"page"},{"location":"userdata/","page":"User Data and Actions","title":"User Data and Actions","text":"Action","category":"page"},{"location":"userdata/#GradientRobustMultiPhysics.Action","page":"User Data and Actions","title":"GradientRobustMultiPhysics.Action","text":"function Action(\n    T::Type{<:Real},\n    kernel::UserData{<:AbstractActionKernel};\n    name::String = \"user action\")\n\nCreates an Action from a given specified action kernel that then can be used in an assembly pattern. T specifies the number format that should match the number format of the used quadrature rules and grid coordinates in the mesh (usually T).\n\n\n\n\n\nfunction Action{T <: Real}(\n    kernel_function::Function,\n    dimensions::Array{Int,1};\n    name = \"user action\",\n    dependencies = \"\",\n    quadorder = 0)\n\nCreates an Action directly from a kernel function (plus additional information to complement the action kernel) that then can be used in an assembly pattern. T specifies the number format that should match the number format of the used quadrature rules and grid coordinates in the mesh (default if omitted: T = Float64).\n\n\n\n\n\n","category":"type"},{"location":"userdata/#NLAction-Kernel","page":"User Data and Actions","title":"NLAction Kernel","text":"","category":"section"},{"location":"userdata/","page":"User Data and Actions","title":"User Data and Actions","text":"For the manual linearisation (=without automatic differentiation) of Nonlinear Operators assembly pattern, the user can also insert nonlinear action kernels that have a second input argument for the operator-evaluations of the current solution. But since this feature is still experimental, it will not explained in more detail, yet.","category":"page"},{"location":"userdata/","page":"User Data and Actions","title":"User Data and Actions","text":"NLActionKernel","category":"page"},{"location":"userdata/#GradientRobustMultiPhysics.NLActionKernel","page":"User Data and Actions","title":"GradientRobustMultiPhysics.NLActionKernel","text":"function NLActionKernel(\n    f::Function,\n    dimensions::Array{Int,1};\n    name = \"nonlinear user action kernel\",\n    dependencies::String = \"\",\n    quadorder::Int = 0)\n\nProvides a negotation interface for some function to be used as a nonlinear action kernel that can be used in the NonlinearOperator constructor without automatic differentiation. The function f has to obey the interface\n\nf(result, input_current, input_ansatz)\n\nand can be seen as a linearisation of a nonlinearity that can depend on the operator evaluation of the current iterate (inputcurrent) and, as usual, the operator evaluations of the ansatz function (inputansatz).\n\nNo further dependencies are allowed currently. Note, that this is a work-in-progress feature.\n\n\n\n\n\n","category":"function"},{"location":"home/","page":"Home","title":"Home","text":"(Image: Build status) (Image: ) (Image: ) (Image: DOI)","category":"page"},{"location":"home/#GradientRobustMultiPhysics.jl","page":"Home","title":"GradientRobustMultiPhysics.jl","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"This package offers (mostly low-order) finite element methods for multiphysics problems in Julia that focus on the preservation of structural and qualitative properties, in particular the gradient-robustness property for the discretisation of (nearly) incompressible flows and resulting qualitative properties in coupled processes. The code therefore offers several classical and novel non-standard finite element discretisations to play and compare with in these applications and a toolkit to setup multi-physics problems by defining PDE systems and generating fixed-point iterations to solve them.","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"The implementation is based on ExtendableGrids.jl that allows to have unstructured grids with mixed element geometries in it, e.g. triangles and quads in the same mesh.","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"Also note, that this package is part of the meta-package PDELIB.jl","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"note: Note\nThe focus is (at least currently) not on high-performance, high-order or parallel-computing. Also, this package is still in an early development stage and features and interfaces might change in future updates.","category":"page"},{"location":"home/#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"via Julia package manager in Julia 1.5 or above:","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"# latest stable version\n(@v1.5) pkg> add GradientRobustMultiPhysics\n# latest version\n(@v1.5) pkg> add GradientRobustMultiPhysics#master","category":"page"},{"location":"home/#Dependencies-on-other-Julia-packages","page":"Home","title":"Dependencies on other Julia packages","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"ExtendableGrids.jl\nGridVisualize.jl\nExtendableSparse.jl\nDocStringExtensions.jl\nForwardDiff.jl\nDiffResults.jl\nWriteVTK.jl\n","category":"page"},{"location":"home/#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"The general work-flow is as follows:","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"Mesh the domain of computation, possibly using one of the constructors by ExtendableGrid.jl or via mesh generators in SimplexGridFactory.jl.\nDescribe your PDE system with the help of the PDE Description and PDE Operators. User parameters and customised operator actions are framed with the help of User Data and Actions.\nDiscretise, i.e. choose suitable finite element ansatz spaces for the unknowns of your PDE system.\nSolve (stationary, time-dependent, iteratively?)\nPostprocess (compute stuff, plot, export data)","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"Please have a look at the Examples.","category":"page"},{"location":"home/#What-is-gradient-robustness?","page":"Home","title":"What is gradient-robustness?","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"Gradient-robustness is a feature of discretisations that exactly balance gradient forces in the momentum balance. In the case of the incompressible Navier–Stokes equations this means that the discrete velocity does not depend on the exact pressure. Divergence-free finite element methods have this property but are usually expensive and difficult to contruct. However, also non-divergence-free classical finite element methods can be made pressure-robust with the help of reconstruction operators applied to testfuntions in certain terms of the momentum balance, see e.g. references [1,2] below.","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"Recently gradient-robustness was also connected to the design of well-balanced schemes e.g. in the context of (nearly) compressible flows, see e.g. reference [3] below.","category":"page"},{"location":"home/#References","page":"Home","title":"References","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"[1]   \"On the divergence constraint in mixed finite element methods for incompressible flows\",\n      V. John, A. Linke, C. Merdon, M. Neilan and L. Rebholz,\n      SIAM Review 59(3) (2017), 492–544,\n      >Journal-Link<,       >Preprint-Link<\n[2]   \"Pressure-robustness and discrete Helmholtz projectors in mixed finite element methods for the incompressible Navier–Stokes equations\",\n      A. Linke and C. Merdon,       Computer Methods in Applied Mechanics and Engineering 311 (2016), 304–326,\n      >Journal-Link<       >Preprint-Link<\n[3]   \"A gradient-robust well-balanced scheme for the compressible isothermal Stokes problem\",\n      M. Akbas, T. Gallouet, A. Gassmann, A. Linke and C. Merdon,\n      Computer Methods in Applied Mechanics and Engineering 367 (2020),\n      >Journal-Link<       >Preprint-Link<","category":"page"},{"location":"examples/ExampleA02_CommutingInterpolators2D/#A02-:-Commuting-Interpolators-2D","page":"A02 : Commuting Interpolators 2D","title":"A02 : Commuting Interpolators 2D","text":"","category":"section"},{"location":"examples/ExampleA02_CommutingInterpolators2D/","page":"A02 : Commuting Interpolators 2D","title":"A02 : Commuting Interpolators 2D","text":"(source code)","category":"page"},{"location":"examples/ExampleA02_CommutingInterpolators2D/","page":"A02 : Commuting Interpolators 2D","title":"A02 : Commuting Interpolators 2D","text":"This example verifies a structural property of the H1 and Hdiv finite element spaces and their interpolators which is","category":"page"},{"location":"examples/ExampleA02_CommutingInterpolators2D/","page":"A02 : Commuting Interpolators 2D","title":"A02 : Commuting Interpolators 2D","text":"mathrmCurl(I_mathrmP_kpsi) = I_mathrmRT_k-1(mathrmCurl(psi))","category":"page"},{"location":"examples/ExampleA02_CommutingInterpolators2D/","page":"A02 : Commuting Interpolators 2D","title":"A02 : Commuting Interpolators 2D","text":"for the H_1 interpolator I_mathrmP_k and the standard Raviart-Thomas interpolator I_mathrmRT_k-1 for k  0. In this example we verify this identity for k=1 and k=2. Note, that the H_1 interpolator only does nodal interpolations at the vertices but not in the additional degrees of freedom. For k=2, the interpolator also preserves the moments along the edges.","category":"page"},{"location":"examples/ExampleA02_CommutingInterpolators2D/","page":"A02 : Commuting Interpolators 2D","title":"A02 : Commuting Interpolators 2D","text":"module ExampleA02_CommutingInterpolators2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\n\n# define some function\nfunction exact_function!(result,x)\n    result[1] = x[1]^2-x[2]^4 + 1\nend\n# and its CurlScalar = (-dy,dx)\nfunction exact_curl!(result,x)\n    result[1] = 4*x[2]^3\n    result[2] = 2*x[1]\nend\n\n# everything is wrapped in a main function\nfunction main(;order::Int = 2, testmode = false)\n\n    # choose some grid\n    xgrid = uniform_refine(reference_domain(Triangle2D),2)\n\n    # negotiate exact_function! and exact_curl! to the package\n    u = DataFunction(exact_function!, [1,2]; name = \"u_exact\", dependencies = \"X\", quadorder = 4)\n    u_curl = DataFunction(exact_curl!, [2,2]; name = \"Curl(u_exact)\", dependencies = \"X\", quadorder = 3)\n\n    # choose commuting interpolators pair\n    if order == 1\n        FE = [H1P1{1},HDIVRT0{2}]; testFE = H1P0{2}\n    elseif order == 2\n        FE = [H1P2{1,2},HDIVRT1{2}]; testFE = H1P1{2}\n    end\n\n    # do the H1 interpolation of the function\n    FESH1 = FESpace{FE[1]}(xgrid)\n    H1Interpolation = FEVector(\"H1-Interpolation\",FESH1)\n    interpolate!(H1Interpolation[1], u)\n\n    # do the Hdiv interpolation of the Curl of the function\n    # since integrals over faces have to be computed exactly we need to tune the quadrature order\n    FESHdiv = FESpace{FE[2]}(xgrid)\n    HdivCurlInterpolation = FEVector(\"Hdiv-Interpolation\",FESHdiv)\n    interpolate!(HdivCurlInterpolation[1], u_curl)\n\n    # Checking the identity:\n    # Both sides of the identity are finite element function of FEtype testFE\n    # Hence, we evaluate the error by testing the identity by all basisfunctions of this type\n\n    # first: generate the test space and some matching FEVector\n    FEStest = FESpace{testFE}(xgrid; broken = true)\n    error = FEVector(\"ErrorVector\",FEStest)\n\n    # Define bilinear forms that represents testing each side of the identity with the testspace functions\n    BLF1 = BilinearForm(Float64, ON_CELLS, [FEStest, FESHdiv], [Identity, Identity])\n    BLF2 = BilinearForm(Float64, ON_CELLS, [FEStest, FESH1], [Identity, CurlScalar])\n\n    # evaluate the bilinear forms in the respective interpolations and subtract them from each other\n    # note that in these calls always the second argument of the bilinearform is fixed by the given FEVectorBlock\n    assemble!(error[1], BLF1, HdivCurlInterpolation[1]; fixed_arguments = [2])\n    assemble!(error[1], BLF2, H1Interpolation[1]; factor = -1, fixed_arguments = [2])\n\n    # do some norm that recognizes a nonzero in the vector\n    error = sqrt(sum(error[1][:].^2, dims = 1)[1])\n    if testmode == true\n        return error\n    else\n        println(\"error(Curl(I_$(FE[1])(psi) - I_$(FE[2])(Curl(psi))) = $error\")\n    end\nend\n\n# test function that is called by test unit\nfunction test()\n    error = []\n    for order in [1,2]\n        push!(error, max(main(order = order, testmode = true)))\n    end\n    return maximum(error)\nend\n\nend","category":"page"},{"location":"examples/ExampleA02_CommutingInterpolators2D/","page":"A02 : Commuting Interpolators 2D","title":"A02 : Commuting Interpolators 2D","text":"","category":"page"},{"location":"examples/ExampleA02_CommutingInterpolators2D/","page":"A02 : Commuting Interpolators 2D","title":"A02 : Commuting Interpolators 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/ExampleA02_CommutingInterpolators2D/","page":"A02 : Commuting Interpolators 2D","title":"A02 : Commuting Interpolators 2D","text":"Default output:","category":"page"},{"location":"examples/ExampleA02_CommutingInterpolators2D/","page":"A02 : Commuting Interpolators 2D","title":"A02 : Commuting Interpolators 2D","text":"julia> ExampleA02_CommutingInterpolators2D.main()\nerror(Curl(I_H1P2{1,2}(psi) - I_HDIVRT1{2}(Curl(psi))) = 1.9676241093433825e-16","category":"page"},{"location":"examples/Example201_PoissonProblem2D/#:-Poisson-Problem-2D","page":"201 : Poisson-Problem 2D","title":"201 : Poisson-Problem 2D","text":"","category":"section"},{"location":"examples/Example201_PoissonProblem2D/","page":"201 : Poisson-Problem 2D","title":"201 : Poisson-Problem 2D","text":"(source code)","category":"page"},{"location":"examples/Example201_PoissonProblem2D/","page":"201 : Poisson-Problem 2D","title":"201 : Poisson-Problem 2D","text":"This example computes the solution u of the Poisson problem","category":"page"},{"location":"examples/Example201_PoissonProblem2D/","page":"201 : Poisson-Problem 2D","title":"201 : Poisson-Problem 2D","text":"beginaligned\n-Delta u  = f quad textin  Omega\nendaligned","category":"page"},{"location":"examples/Example201_PoissonProblem2D/","page":"201 : Poisson-Problem 2D","title":"201 : Poisson-Problem 2D","text":"with some right-hand side f on the unit cube domain Omega on a given grid.","category":"page"},{"location":"examples/Example201_PoissonProblem2D/","page":"201 : Poisson-Problem 2D","title":"201 : Poisson-Problem 2D","text":"module Example201_PoissonProblem2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# right-hand side function\nconst f = DataFunction([1]; name = \"f\")\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, μ = 1, order = 2, Plotter = nothing)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # build/load any grid (here: a uniform-refined 2D unit square into triangles)\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D),4)\n\n    # create empty PDE description\n    Problem = PDEDescription(\"Poisson problem\")\n\n    # add unknown(s) (here: \"u\" that gets id 1 for later reference)\n    add_unknown!(Problem; unknown_name = \"u\", equation_name = \"Poisson equation\")\n\n    # add left-hand side PDEoperator(s) (here: only Laplacian)\n    add_operator!(Problem, [1,1], LaplaceOperator(μ))\n\n    # add right-hand side data (here: f = [1] in region(s) [1])\n    add_rhsdata!(Problem, 1, RhsOperator(Identity, [1], f))\n\n    # add boundary data (here: zero data for boundary regions 1:4)\n    add_boundarydata!(Problem, 1, [1,2,3,4], HomogeneousDirichletBoundary)\n\n    # discretise = choose FEVector with appropriate FESpaces\n    FEType = H1Pk{1,2,order}\n    Solution = FEVector(\"u_h\",FESpace{FEType}(xgrid))\n\n    # show problem and Solution structure\n    @show Problem Solution\n\n    # solve for chosen Solution vector\n    solve!(Solution, Problem)\n\n    # plot solution (for e.g. Plotter = PyPlot)\n    p = GridVisualizer(; Plotter = Plotter, layout = (1,2), clear = true, resolution = (1000,500))\n    scalarplot!(p[1,1], xgrid, view(nodevalues(Solution[1]),1,:), levels = 11, title = \"u_h\")\n    scalarplot!(p[1,2], xgrid, view(nodevalues(Solution[1], Gradient; abs = true),1,:), levels=7)\n    vectorplot!(p[1,2], xgrid, evaluate(PointEvaluator(Solution[1], Gradient)), spacing = 0.1, clear = false, title = \"∇u_h (abs + quiver)\")\nend\n\nend","category":"page"},{"location":"examples/Example201_PoissonProblem2D/","page":"201 : Poisson-Problem 2D","title":"201 : Poisson-Problem 2D","text":"","category":"page"},{"location":"examples/Example201_PoissonProblem2D/","page":"201 : Poisson-Problem 2D","title":"201 : Poisson-Problem 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example201_PoissonProblem2D/","page":"201 : Poisson-Problem 2D","title":"201 : Poisson-Problem 2D","text":"Default output:","category":"page"},{"location":"examples/Example201_PoissonProblem2D/","page":"201 : Poisson-Problem 2D","title":"201 : Poisson-Problem 2D","text":"julia> Example201_PoissonProblem2D.main()\n\nPDE-DESCRIPTION\n===============\n  system name = Poisson problem\n\n     id   | unknown name / equation name\n    [1]   | u / Poisson equation \n\n  LHS block | PDEOperator(s)\n    [1,1]   | (∇u,∇v) (APT = SymmetricBilinearForm, AT = ON_CELLS, regions = [0])\n\n  RHS block | PDEOperator(s)\n     [1]    | (f, id(v)) (APT = LinearForm, AT = ON_CELLS, regions = [1])\n\n   BoundaryOperator[1] : HomogeneousDirichletBoundary -> [1, 2, 3, 4]\n                          \n\nProblem = \nSolution = \nFEVector information\n====================\n   block  |  ndofs  | name (FEType) \n [    1]  |    2113 | u_h (H1Pk{1,2,2})\n","category":"page"},{"location":"examples/Example201_PoissonProblem2D/","page":"201 : Poisson-Problem 2D","title":"201 : Poisson-Problem 2D","text":"(Image: )","category":"page"},{"location":"examples/Example225_CompressibleStokes2D/#:-Compressible-Stokes-2D","page":"225 : Compressible Stokes 2D","title":"225 : Compressible Stokes 2D","text":"","category":"section"},{"location":"examples/Example225_CompressibleStokes2D/","page":"225 : Compressible Stokes 2D","title":"225 : Compressible Stokes 2D","text":"(source code)","category":"page"},{"location":"examples/Example225_CompressibleStokes2D/","page":"225 : Compressible Stokes 2D","title":"225 : Compressible Stokes 2D","text":"This example solves the compressible Stokes equations where one seeks a (vector-valued) velocity mathbfu, a density varrho and a pressure p such that","category":"page"},{"location":"examples/Example225_CompressibleStokes2D/","page":"225 : Compressible Stokes 2D","title":"225 : Compressible Stokes 2D","text":"beginaligned\n- mu Delta mathbfu + lambda nabla(mathrmdiv(mathbfu)) + nabla p  = mathbff + varrho mathbfg\nmathrmdiv(varrho mathbfu)  = 0\n        p  = eos(varrho)\n        int_Omega varrho  dx  = M\n        varrho  geq 0\nendaligned","category":"page"},{"location":"examples/Example225_CompressibleStokes2D/","page":"225 : Compressible Stokes 2D","title":"225 : Compressible Stokes 2D","text":"Here eos eos is some equation of state function that describes the dependence of the pressure on the density (and further physical quantities like temperature in a more general setting). Moreover, mu and lambda are Lame parameters and mathbff and mathbfg are given right-hand side data.","category":"page"},{"location":"examples/Example225_CompressibleStokes2D/","page":"225 : Compressible Stokes 2D","title":"225 : Compressible Stokes 2D","text":"In this example we solve a analytical toy problem with the prescribed solution","category":"page"},{"location":"examples/Example225_CompressibleStokes2D/","page":"225 : Compressible Stokes 2D","title":"225 : Compressible Stokes 2D","text":"beginaligned\nmathbfu(mathbfx)  =0\nvarrho(mathbfx)  = 1 - (x_2 - 05)c\np = eos(varrho) = c varrho^gamma\nendaligned","category":"page"},{"location":"examples/Example225_CompressibleStokes2D/","page":"225 : Compressible Stokes 2D","title":"225 : Compressible Stokes 2D","text":"such that mathbff = 0 and mathbfg nonzero to match the prescribed solution. This example is designed to study the well-balanced property of a discretisation. Note that a gradient-robust discretisation (set reconstruct = true below) has a much smaller L2 velocity error (i.e. approximatse the well-balanced state much better). For larger c the problem gets more incompressible which reduces the error further as then the right-hand side is a perfect gradient also when evaluated with the (now closer to a constant) discrete density. See reference below for more details.","category":"page"},{"location":"examples/Example225_CompressibleStokes2D/","page":"225 : Compressible Stokes 2D","title":"225 : Compressible Stokes 2D","text":"reference: Reference\n\"A gradient-robust well-balanced scheme for the compressible isothermal Stokes problem\",\nM. Akbas, T. Gallouet, A. Gassmann, A. Linke and C. Merdon,\nComputer Methods in Applied Mechanics and Engineering 367 (2020),\n>Journal-Link< >Preprint-Link<","category":"page"},{"location":"examples/Example225_CompressibleStokes2D/","page":"225 : Compressible Stokes 2D","title":"225 : Compressible Stokes 2D","text":"module Example225_CompressibleStokes2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# the equation of state\nfunction equation_of_state!(c,γ)\n    function closure(pressure,density)\n        for j = 1 : length(density)\n            pressure[j] = c*density[j]^γ\n        end\n    end\nend\n\n# the exact density (used for initial value of density if configured so)\nfunction ϱ_exact!(M,c)\n    function closure(result,x)\n        result[1] = M*(1.0 - (x[2] - 0.5)/c)\n    end\nend\n\n# gravity right-hand side (just gravity but with opposite sign!)\nfunction gravity!(γ,c)\n    function closure(result,x)\n        result[2] = - (1.0 - (x[2] - 0.5)/c)^(γ-2) * γ # = - ϱ^(γ-2) * γ\n    end\nend\n# gravity right-hand side (just gravity but with opposite sign!)\nfunction rhs!(γ,c)\n    function closure(result,x)\n        result[2] = - (1.0 - (x[2] - 0.5)/c)^(γ-1) * γ # = - ϱ^(γ-2) * γ\n    end\nend\n\n# everything is wrapped in a main function\nfunction main(; use_gravity = true, verbosity = 0, c = 10, γ = 1.4, M = 1, μ = 1e-3, λ = -2/3*μ, Plotter = nothing, nlevels = 3)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # load mesh and exact solution\n    xgrid = simplexgrid(\"assets/2d_mountainrange.sg\")\n    u = DataFunction([0,0]; name = \"u\")\n    ∇u = DataFunction([0,0,0,0]; name = \"∇u\")\n    ϱ = DataFunction(ϱ_exact!(M,c), [1,2]; name = \"ϱ\", dependencies = \"X\", quadorder = 2)\n\n    # compute mass of exact density on grid (bit smaller than M due to mountains)\n    Mreal = integrate(xgrid, ON_CELLS, ϱ, 1)\n\n    # prepare error calculation\n    VeloError = L2ErrorIntegrator(Float64, u, Identity; quadorder = 4)\n    VeloGradError = L2ErrorIntegrator(Float64, ∇u, Gradient; quadorder = 2)\n    DensityError = L2ErrorIntegrator(Float64, ϱ, Identity; quadorder = 2)\n    Results = zeros(Float64,6,nlevels)\n    NDoFs = zeros(Int,nlevels)\n\n    # set finite element types [velocity, density,  pressure]\n    FETypes = [H1BR{2}, H1P0{1}, H1P0{1}] # Bernardi--Raugel x P0\n\n    # solve\n    Solution = [nothing, nothing]\n    for lvl = 1 : nlevels\n        if lvl > 1\n            xgrid = uniform_refine(xgrid)\n        end\n\n        # generate FESpaces and solution vector\n        FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid), FESpace{FETypes[3]}(xgrid)]\n        Solution = [FEVector([\"u_h (BR)\", \"ϱ_h (BR)\", \"p_h (BR)\"],FES),FEVector([\"u_h (BR+)\", \"ϱ_h (BR+)\", \"p_h (BR+)\"],FES)]\n        NDoFs[lvl] = length(Solution[1].entries)\n\n        # solve with and without reconstruction\n        for reconstruct in [true, false]\n            Target = Solution[reconstruct+1]\n            setup_and_solve!(Target, xgrid; use_gravity = use_gravity, reconstruct = reconstruct, c = c, M = Mreal, λ = λ, μ = μ, γ = γ)\n            Results[reconstruct ? 2 : 1,lvl] = sqrt(evaluate(VeloError,Target[1]))\n            Results[reconstruct ? 4 : 3,lvl] = sqrt(evaluate(VeloGradError,Target[1]))\n            Results[reconstruct ? 6 : 5,lvl] = sqrt(evaluate(DensityError,Target[2]))\n\n            # check error in mass constraint\n            Md = sum(Target[2][:] .* xgrid[CellVolumes])\n            println(\"\\tmass_error = $Mreal - $Md = $(abs(Mreal-Md))\")\n        end\n    end\n\n    # print convergence history tables\n    print_convergencehistory(NDoFs, Results[1:2,:]'; X_to_h = X -> X.^(-1/2), ylabels = [\"||u-u_h|| (BR)\",\"||u-u_h|| (BR+)\"], xlabel = \"ndof\")\n    print_convergencehistory(NDoFs, Results[3:4,:]'; X_to_h = X -> X.^(-1/2), ylabels = [\"||∇(u-u_h)|| (BR)\",\"||∇(u-u_h)|| (BR+)\"], xlabel = \"ndof\")\n    print_convergencehistory(NDoFs, Results[5:6,:]'; X_to_h = X -> X.^(-1/2), ylabels = [\"||ϱ-ϱ_h|| (BR)\",\"||ϱ-ϱ_h|| (BR+)\"], xlabel = \"ndof\")\n\n    # plot everything\n    p = GridVisualizer(; Plotter = Plotter, layout = (2,2), clear = true, resolution = (1000,1000))\n    scalarplot!(p[1,1],xgrid,view(nodevalues(Solution[1][1]; abs = true),1,:), levels = 0)\n    vectorplot!(p[1,1],xgrid,evaluate(PointEvaluator(Solution[1][1], Identity)), spacing = 0.1, clear = false, title = \"u_h (BR) (abs + quiver)\")\n    scalarplot!(p[1,2],xgrid,view(nodevalues(Solution[1][2]),1,:), levels = 11, title = \"p_h (BR)\")\n    scalarplot!(p[2,1],xgrid,view(nodevalues(Solution[2][1]; abs = true),1,:), levels = 0)\n    vectorplot!(p[2,1],xgrid,evaluate(PointEvaluator(Solution[2][1], Identity)), spacing = 0.1, clear = false, title = \"u_h (BR+) (abs + quiver)\")\n    scalarplot!(p[2,2],xgrid,view(nodevalues(Solution[2][2]),1,:), levels = 11, title = \"p_h (BR+)\")\nend\n\nfunction setup_and_solve!(Solution, xgrid;\n    c = 1, γ = 1, M = 1, μ = 1, λ = 0,\n    use_gravity = true,\n    reconstruct = true,\n    timestep = μ / (M*c),\n    maxTimeSteps = 500,\n    stationarity_threshold = c*1e-14/μ)\n\n    # generate empty PDEDescription for three unknowns (u, ϱ. p)\n    Problem = PDEDescription(\"compressible Stokes problem\")\n    add_unknown!(Problem; unknown_name = \"v\", equation_name = \"momentum equation\")\n    add_unknown!(Problem; unknown_name = \"ϱ\", equation_name = \"continuity equation\")\n    add_unknown!(Problem; unknown_name = \"p\", equation_name = \"equation of state\")\n    add_boundarydata!(Problem, 1,  [1,2,3,4], HomogeneousDirichletBoundary)\n\n    # momentum equation\n    hdiv_space = HDIVBDM1{2} # HDIVRT0{2} also works\n    VeloIdentity = reconstruct ? ReconstructionIdentity{hdiv_space} : Identity\n    VeloDivergence = reconstruct ? ReconstructionDivergence{hdiv_space} : Divergence\n    add_operator!(Problem, [1,1], LaplaceOperator(2*μ; store = true))\n    if λ != 0\n        add_operator!(Problem, [1,1], BilinearForm([VeloDivergence,VeloDivergence]; name = \"λ (div(u),div(v))\", factor = λ, store = true))\n    end\n    add_operator!(Problem, [1,3], BilinearForm([Divergence,Identity]; name = \"(div(v),p)\", factor = -1, store = true))\n\n    if use_gravity\n        # discrete gravity term for right-hand side (assembled as bilinearform for faster evaluation in fixpoint iteration)\n        g = DataFunction(gravity!(γ,c), [2,2]; name = \"g\", dependencies = \"X\", quadorder = 4)\n        add_operator!(Problem, [1,2], BilinearForm([VeloIdentity,Identity], fdot_action(Float64, g); factor = -1, name = \"(g ⋅ v) ϱ\", store = true))\n    else\n        # exact gravity term for right-hand side\n        f = DataFunction(rhs!(γ,c), [2,2]; name = \"f\", dependencies = \"X\", quadorder = 4)\n        add_rhsdata!(Problem, 1,  RhsOperator(VeloIdentity, [0], f; store = true))\n    end\n\n    # continuity equation (by FV upwind on triangles)\n    add_operator!(Problem, [2,2], FVConvectionDiffusionOperator(1))\n\n    # equation of state (by best-approximation, P0 mass matrix is diagonal)\n    eos_action = Action( equation_of_state!(c,γ),[1,1]; dependencies = \"\", quadorder = 1)\n    add_operator!(Problem, [3,2], BilinearForm([Identity,Identity],eos_action; name = \"(p,eos(ϱ))\", apply_action_to = [2])) # cannot be stored if eos is nonlinear!\n    add_operator!(Problem, [3,3], BilinearForm([Identity,Identity]; name = \"(p,q)\", factor = -1, store = true))\n\n    # initial values for density (constant) and pressure (by equation of state)\n    fill!(Solution[2], M/sum(xgrid[CellVolumes]))\n    equation_of_state!(c,γ)(Solution[3],Solution[2])\n\n    # time-dependent solver with three equations [1] velocity, [2] density, [3] pressure\n    # solved iteratively [1] => [2] => [3] in each pseudo time step until stationarity\n    TCS = TimeControlSolver(Problem, Solution, BackwardEuler;\n                                        subiterations = [[1],[2],[3]], # solve [1], then [2], then [3]\n                                        skip_update = [-1,1,-1], # only matrix of eq [2] changes\n                                        timedependent_equations = [2], # only eq [2] is time-dependent\n                                        maxiterations = 1,\n                                        check_nonlinear_residual = false,\n                                        show_iteration_details = false)\n    advance_until_stationarity!(TCS, timestep; maxTimeSteps = maxTimeSteps, stationarity_threshold = stationarity_threshold)\nend\nend","category":"page"},{"location":"examples/Example225_CompressibleStokes2D/","page":"225 : Compressible Stokes 2D","title":"225 : Compressible Stokes 2D","text":"","category":"page"},{"location":"examples/Example225_CompressibleStokes2D/","page":"225 : Compressible Stokes 2D","title":"225 : Compressible Stokes 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example225_CompressibleStokes2D/","page":"225 : Compressible Stokes 2D","title":"225 : Compressible Stokes 2D","text":"Default output:","category":"page"},{"location":"examples/Example225_CompressibleStokes2D/","page":"225 : Compressible Stokes 2D","title":"225 : Compressible Stokes 2D","text":"julia> Example225_CompressibleStokes2D.main()\n\tmass_error = 0.8902625 - 0.8902625000000025 = 2.55351295663786e-15\n\tmass_error = 0.8902625 - 0.8902625000000034 = 3.4416913763379853e-15\n\tmass_error = 0.8902625 - 0.8902625000000007 = 7.771561172376096e-16\n\tmass_error = 0.8902625 - 0.890262500000001 = 9.992007221626409e-16\n\tmass_error = 0.8902625 - 0.8902624999999936 = 6.328271240363392e-15\n\tmass_error = 0.8902625 - 0.8902624999999933 = 6.661338147750939e-15\n\n    ndof    |   ||u-u_h|| (BR)     order  |   ||u-u_h|| (BR+)    order  |\n============|=============================|=============================|\n       167  |     4.71437e-01      0.000  |     1.28783e-03      0.000  |\n       602  |     1.63767e-01      1.649  |     3.84703e-04      1.885  |\n      2282  |     4.54389e-02      1.924  |     9.32730e-05      2.127  |\n\n    ndof    |  ||∇(u-u_h)|| (BR)   order  | ||∇(u-u_h)|| (BR+)   order  |\n============|=============================|=============================|\n       167  |     9.53773e+00      0.000  |     2.47878e-02      0.000  |\n       602  |     6.81732e+00      0.524  |     9.94591e-03      1.424  |\n      2282  |     3.77126e+00      0.889  |     2.46695e-03      2.092  |\n\n    ndof    |   ||ϱ-ϱ_h|| (BR)     order  |   ||ϱ-ϱ_h|| (BR+)    order  |\n============|=============================|=============================|\n       167  |     6.24901e-03      0.000  |     5.64017e-03      0.000  |\n       602  |     2.94689e-03      1.172  |     2.82008e-03      1.081  |\n      2282  |     1.44808e-03      1.066  |     1.41004e-03      1.040  |","category":"page"},{"location":"examples/Example225_CompressibleStokes2D/","page":"225 : Compressible Stokes 2D","title":"225 : Compressible Stokes 2D","text":"(Image: )","category":"page"},{"location":"examples/Example222_NavierStokesAnderson2D/#:-Navier-Stokes-Lid-driven-cavity-Anderson-Acceleration","page":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","title":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","text":"","category":"section"},{"location":"examples/Example222_NavierStokesAnderson2D/","page":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","title":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","text":"(source code)","category":"page"},{"location":"examples/Example222_NavierStokesAnderson2D/","page":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","title":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","text":"This example solves the lid-driven cavity problem where one seeks a velocity mathbfu and pressure mathbfp of the incompressible Navier–Stokes problem","category":"page"},{"location":"examples/Example222_NavierStokesAnderson2D/","page":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","title":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","text":"beginaligned\n- mu Delta mathbfu + (mathbfu cdot nabla) mathbfu + nabla p  = 0\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"examples/Example222_NavierStokesAnderson2D/","page":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","title":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","text":"where mathbfu = (10) along the top boundary of a square domain.","category":"page"},{"location":"examples/Example222_NavierStokesAnderson2D/","page":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","title":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","text":"For small viscosities (where a Newton and a classical Picard iteration do not converge anymore), Anderson acceleration might help which can be tested with this script. Here, we use Anderson acceleration until the residual is small enough for the Newton to take over.","category":"page"},{"location":"examples/Example222_NavierStokesAnderson2D/","page":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","title":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","text":"module Example222_NavierStokesAnderson2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\nusing Printf\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, Plotter = nothing, μ = 5e-4, anderson_iterations = 10, target_residual = 1e-12, maxiterations = 50, switch_to_newton_tolerance = 1e-4)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # grid\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D), 5);\n\n    # finite element type\n    FETypes = [H1P2{2,2}, H1P1{1}] # Taylor--Hood\n\n    # load Navier-Stokes problem prototype and assign data\n    Problem = IncompressibleNavierStokesProblem(2; viscosity = μ, nonlinear = true, auto_newton = false, store = false)\n    add_boundarydata!(Problem, 1, [1,2,4], HomogeneousDirichletBoundary)\n    add_boundarydata!(Problem, 1, [3], BestapproxDirichletBoundary; data = DataFunction([1,0]))\n    @show Problem\n\n    # generate FESpaces\n    FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid)]\n    Solution = FEVector([\"u_h\", \"p_h\"],FES)\n\n    # solve with anderson iterations until 1e-4\n    solve!(Solution, Problem; anderson_iterations = anderson_iterations, anderson_metric = \"l2\", anderson_unknowns = [1], maxiterations = maxiterations, target_residual = switch_to_newton_tolerance, show_statistics = true)\n\n    # solve rest with Newton\n    Problem = IncompressibleNavierStokesProblem(2; viscosity = μ, nonlinear = true, auto_newton = true, store = true)\n    add_boundarydata!(Problem, 1, [1,2,4], HomogeneousDirichletBoundary)\n    add_boundarydata!(Problem, 1, [3], BestapproxDirichletBoundary; data = DataFunction([1,0]))\n    @show Problem\n    solve!(Solution, Problem; anderson_iterations = anderson_iterations, maxiterations = maxiterations, target_residual = target_residual, show_statistics = true)\n\n    # plot\n    p = GridVisualizer(; Plotter = Plotter, layout = (1,2), clear = true, resolution = (1000,500))\n    scalarplot!(p[1,1],xgrid,view(nodevalues(Solution[1]; abs = true),1,:), levels = 3)\n    vectorplot!(p[1,1],xgrid,evaluate(PointEvaluator(Solution[1], Identity)), spacing = 0.1, clear = false, title = \"u_h (abs + quiver)\")\n    scalarplot!(p[1,2],xgrid,view(nodevalues(Solution[2]),1,:), levels = 11, title = \"p_h\")\nend\n\nend","category":"page"},{"location":"examples/Example222_NavierStokesAnderson2D/","page":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","title":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","text":"","category":"page"},{"location":"examples/Example222_NavierStokesAnderson2D/","page":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","title":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example222_NavierStokesAnderson2D/","page":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","title":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","text":"Default output:","category":"page"},{"location":"examples/Example222_NavierStokesAnderson2D/","page":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","title":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","text":"julia> Example222_NavierStokesAnderson2D.main()\n\nPDE-DESCRIPTION\n===============\n  system name = incompressible Navier-Stokes-Problem\n\n     id   | unknown name / equation name\n    [1]   | u / momentum equation \n    [2]   | p / incompressibility constraint \n\n  LHS block | PDEOperator(s)\n    [1,1]   | 0.0005 (∇u,∇v) (APT = SymmetricBilinearForm, AT = ON_CELLS, regions = [0])\n            | ((id(a) ⋅ ∇) u, id(v)) (APT = TrilinearForm, AT = ON_CELLS, regions = [0])\n    [1,2]   | (div(v),q) (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n    [2,1]   | none\n    [2,2]   | none\n\n  RHS block | PDEOperator(s)\n     [1]    | none\n     [2]    | none\n\n   BoundaryOperator[1] : BestapproxDirichletBoundary -> [3]\n                         HomogeneousDirichletBoundary -> [1, 2, 4]\n                          \n   BoundaryOperator[2] : \n\n  GlobalConstraints[1] : Mean[2] != 0 \nProblem = \n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL  | TIME ASSEMBLY/SOLVE/TOTAL (s)\n\t-----------------------------------------------------------------------\n\t      1   | 2.229626e-17 | 8.063241e-03 | 2.56e-01/4.64e-01/7.23e-01\n\t      2   | 2.495442e-17 | 4.186558e-03 | 2.63e-01/5.89e-01/8.55e-01\n\t      3   | 3.152474e-17 | 2.062310e-03 | 2.54e-01/5.41e-01/8.00e-01\n\t      4   | 2.792102e-17 | 6.651686e-04 | 2.57e-01/3.25e-01/5.87e-01\n\t      5   | 2.938241e-17 | 5.562696e-04 | 2.52e-01/3.29e-01/5.86e-01\n\t      6   | 2.972427e-17 | 3.504737e-04 | 2.56e-01/3.31e-01/5.95e-01\n\t      7   | 2.964430e-17 | 3.225783e-04 | 2.54e-01/3.36e-01/5.97e-01\n\t      8   | 2.917878e-17 | 1.990759e-04 | 2.52e-01/3.22e-01/5.82e-01\n\t      9   | 2.929608e-17 | 8.282842e-05 | 2.50e-01/3.23e-01/5.82e-01\n\n\nPDE-DESCRIPTION\n===============\n  system name = incompressible Navier-Stokes-Problem\n\n     id   | unknown name / equation name\n    [1]   | u / momentum equation \n    [2]   | p / incompressibility constraint \n\n  LHS block | PDEOperator(s)\n    [1,1]   | 0.0005 (∇u,∇v) (APT = SymmetricBilinearForm, AT = ON_CELLS, regions = [0])\n            | ((id(u) ⋅ ∇) u, id(v)) [AD-Newton] [∂u] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n    [1,2]   | (div(v),q) (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n    [2,1]   | none\n    [2,2]   | none\n\n  RHS block | PDEOperator(s)\n     [1]    | ((id(u) ⋅ ∇) u, id(v)) [AD-Newton] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n     [2]    | none\n\n   BoundaryOperator[1] : BestapproxDirichletBoundary -> [3]\n                         HomogeneousDirichletBoundary -> [1, 2, 4]\n                          \n   BoundaryOperator[2] : \n\n  GlobalConstraints[1] : Mean[2] != 0 \nProblem = \n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL  | TIME ASSEMBLY/SOLVE/TOTAL (s)\n\t-----------------------------------------------------------------------\n\t      1   | 2.885892e-17 | 8.735238e-07 | 6.31e-01/4.30e-01/1.07e+00\n\t      2   | 2.871616e-17 | 4.117803e-10 | 6.12e-01/3.53e-01/9.68e-01\n\t      3   | 2.854354e-17 | 6.582104e-16 | 6.13e-01/3.44e-01/9.61e-01\n","category":"page"},{"location":"examples/Example222_NavierStokesAnderson2D/","page":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","title":"222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration","text":"(Image: )","category":"page"},{"location":"quadrature/#Quadrature","page":"Quadrature","title":"Quadrature","text":"","category":"section"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"Usually quadrature is a hidden layer as quadrature rules are chosen automatically based on the polynomial degree of the ansatz functions and the specified quadorder of the user data.","category":"page"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"Hence, quadrature rules are only needed if the user wants write his own low-level assembly.","category":"page"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"Quadrature rules consist of points (coordinates of evauation points with respect to reference geometry) and weights. There are constructors for several AbstractElementGeometries (from ExtendableGrids) and different order (some have generic formulas for abitrary order), see below for a detailed list.","category":"page"},{"location":"quadrature/","page":"Quadrature","title":"Quadrature","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"quadrature.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"abstract type QuadratureRule{T<:Real, ET<:AbstractElementGeometry}\n\nA struct that contains the name of the quadrature rule, the reference points and the weights for the parameter-determined element geometry.\n\n\n\n\n\n","category":"type"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:AbstractElementGeometry0D}","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: AbstractElementGeometry0D}\n\nConstructs 0D quadrature rule of specified order (always point evaluation).\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:AbstractElementGeometry1D}","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: AbstractElementGeometry1D}\n\nConstructs 1D quadrature rule of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:Parallelepiped3D}","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Parallelepiped3D}\n\nConstructs quadrature rule on Parallelepiped3D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:Parallelogram2D}","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Parallelogram2D}\n\nConstructs quadrature rule on Parallelogram2D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:Tetrahedron3D}","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Tetrahedron3D}\n\nConstructs quadrature rule on Tetrahedron3D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.QuadratureRule-Union{Tuple{Int64}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:Triangle2D}","page":"Quadrature","title":"GradientRobustMultiPhysics.QuadratureRule","text":"function QuadratureRule{T,ET}(order::Int) where {T<:Real, ET <: Triangle2D}\n\nConstructs quadrature rule on Triangle2D of specified order.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#Base.eltype-Union{Tuple{QuadratureRule{T, ET}}, Tuple{ET}, Tuple{T}} where {T<:Real, ET<:AbstractElementGeometry}","page":"Quadrature","title":"Base.eltype","text":"eltype(_::QuadratureRule{T<:Real, ET<:AbstractElementGeometry}) -> Vector\n\n\nCustom eltype function for QuadratureRule{T,ET}.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#Base.show-Tuple{IO, QuadratureRule}","page":"Quadrature","title":"Base.show","text":"show(io::IO, Q::QuadratureRule)\n\n\nCustom show function for QuadratureRule{T,ET} that prints some information.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.integrate!-Union{Tuple{T}, Tuple{AbstractArray{T}, ExtendableGrid, Type{<:AssemblyType}, UserData{<:AbstractDataFunction}}} where T","page":"Quadrature","title":"GradientRobustMultiPhysics.integrate!","text":"integrate!(integral4items::AbstractArray{T}, grid::ExtendableGrid, AT::Type{<:AssemblyType}, integrand::UserData{<:AbstractDataFunction}; index_offset, time, items, force_quadrature_rule)\n\n\nIntegration that writes result on every item into integral4items.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.integrate-Tuple{ExtendableGrid, Type{<:AssemblyType}, UserData{<:AbstractDataFunction}, Int64}","page":"Quadrature","title":"GradientRobustMultiPhysics.integrate","text":"integrate(grid::ExtendableGrid, AT::Type{<:AssemblyType}, integrand!::UserData{<:AbstractDataFunction}, resultdim::Int64; T, items, force_quadrature_rule) -> Union{Float64, Vector{Float64}}\n\n\nIntegration that returns total integral.\n\n\n\n\n\n","category":"method"},{"location":"quadrature/#GradientRobustMultiPhysics.ref_integrate!-Tuple{AbstractArray, Type{<:AbstractElementGeometry}, Int64, Function}","page":"Quadrature","title":"GradientRobustMultiPhysics.ref_integrate!","text":"ref_integrate!(integral::AbstractArray, EG::Type{<:AbstractElementGeometry}, order::Int64, integrand::Function)\n\n\nIntegration for reference basis functions on reference domains (merely for testing stuff).\n\nNote: area of reference geometry is not multiplied\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#PDE-Description","page":"PDE Description","title":"PDE Description","text":"","category":"section"},{"location":"pdedescription/#Purpose","page":"PDE Description","title":"Purpose","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"The following flow chart visualizes the typical work flow for solving a PDE.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"(Image: Assembly Flowchart) ","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Central object is the PDEDescription which is given as a weak form of your problem (without time derivatives that are added separately by a TimeControlSolver) and usually does not need any information on the discretisation at this point (but of course can depend on region numbers).","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Separately the user provides a mesh and selects suitable finite element spaces on it. The PDEDescription and the Finite Element information is passed to the solver which (after an inspection of all the problem features) descides on a solver strategy (directly or fixed-point). In each iteration a linear system of equations is assembled and then solved by a linear solver.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Automatic differentiation enters on the PDEDescription level. Nonlinear operators can be triggered to be differentiated automatically which causes during their assignment to the PDEDescription that the necessary terms for a Newton iteration (related to the partial derivatives with respect to each unknown and modifications to the right-hand side) automatically enter the PDEDescription, such that a call of solve! returns the next Newton iterate. (Fixed damping factors or function-based damping is also possible via optional arguments, but currently no lagged update of the derivatives.)","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Also, if preferred or needed, a low-level assembly of the linear system is possible as each operator can be assembled separately.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Below the PDEDescription type is detailed. Its ingredients (PDEOperators, boundary conditions, global constraints) are explained on the next pages.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"PDEDescription\nBase.show(io::IO, PDE::PDEDescription)","category":"page"},{"location":"pdedescription/#GradientRobustMultiPhysics.PDEDescription","page":"PDE Description","title":"GradientRobustMultiPhysics.PDEDescription","text":"mutable struct PDEDescription\n    name::String\n    equation_names::Array{String,1}\n    unknown_names::Array{String,1}\n    algebraic_constraint::Array{Bool,1}\n    LHS::Array{Array{AbstractPDEOperator,1},2}\n    RHS::Array{Array{AbstractPDEOperator,1},1}\n    BoundaryOperators::Array{BoundaryOperator,1}\n    GlobalConstraints::Array{AbstractGlobalConstraint,1}\nend\n\nstruct that describes a PDE system with n equations and n unknowns\n\nA PDE system is described by\n\nits name\nthe names of its equations\nthe names of its unknowns\nis the variable related to an algebraic constraint? (e.g. pressure in incompressible CFD, this has implications e.g. for the time discretisation)\na size n x n array of Array{AbstractPDEOperator,1} LHS that describes the left-hand sides\na length n array of Array{AbstractPDEOperator,1} RHS that describes the right-hand sides\na length n array of BoundaryOperators that describes the boundary conditions for each unknown\nan array of GlobalConstraints that describes additional global constraints\n\nA PDEDescription mainly is a set of PDEOperators arranged in a quadratic n by n matrix (LHS). Every matrix row refers to one equation and the positioning of the PDEOperators (e.g. a bilinearform) immediately sets the information which unknowns have to be used to evaluate the operator. Also  nonlinear PDEOperators are possible where extra information on the further involved uknowns have to be specified. UserData is also assigned to the PDEDescription depending on their type. Operator coefficients are assigned directly to the PDEOperators (in form of AbstractActions or a constant factor), right-hand side data is assigned to the right-hand side array of PDEOperators (RHS) and boundary data is assigned to the BoundaryOperators of the PDEDescription. Additionaly global constraints (like a global zero integral mean) can be assigned as a GlobalConstraint.\n\n\n\n\n\n","category":"type"},{"location":"pdedescription/#Base.show-Tuple{IO, PDEDescription}","page":"PDE Description","title":"Base.show","text":"show(io::IO, PDE::PDEDescription)\n\n\nCustom show function for PDEDescription that prints the PDE systems and all assigned operators\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#Creating/Extending-a-PDEDescription","page":"PDE Description","title":"Creating/Extending a PDEDescription","text":"","category":"section"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Several add...! functions allow to extend a ProblemDescription at any stage. There are some very basic PDE Prototypes and several Examples that can be used as a point of departure. Below is a list of functions that allows to initialise and extend a PDEDescription.","category":"page"},{"location":"pdedescription/","page":"PDE Description","title":"PDE Description","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"pdedescription.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"pdedescription/#GradientRobustMultiPhysics.PDEDescription-Tuple{String, Int64}","page":"PDE Description","title":"GradientRobustMultiPhysics.PDEDescription","text":"PDEDescription(name::String, nunknowns::Int64; algebraic, unknown_names, equation_names) -> PDEDescription\n\n\nCreate empty PDEDescription for a specified number of unknowns.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.PDEDescription-Tuple{String}","page":"PDE Description","title":"GradientRobustMultiPhysics.PDEDescription","text":"PDEDescription(name::String) -> PDEDescription\n\n\nCreate empty PDEDescription with no unknowns.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_boundarydata!-Tuple{PDEDescription, Int64, Any, Type{<:AbstractBoundaryType}}","page":"PDE Description","title":"GradientRobustMultiPhysics.add_boundarydata!","text":"add_boundarydata!(PDE::PDEDescription, position::Int64, regions, btype::Type{<:AbstractBoundaryType}; data)\n\n\nAdds the given boundary data with the specified AbstractBoundaryType at the specified position in the BoundaryOperator of the PDEDescription.\n\nNote: If the data function is time-dependent (see User Data documentation) it is evaluated in any advance! step of a TimeControlSolver.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_constraint!-Tuple{PDEDescription, AbstractGlobalConstraint}","page":"PDE Description","title":"GradientRobustMultiPhysics.add_constraint!","text":"add_constraint!(PDE::PDEDescription, GC::AbstractGlobalConstraint)\n\n\nAdds the given global constraint to the PDEDescription.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_operator!-Tuple{PDEDescription, Vector{Int64}, AbstractPDEOperator}","page":"PDE Description","title":"GradientRobustMultiPhysics.add_operator!","text":"add_operator!(PDE::PDEDescription, position::Vector{Int64}, O::AbstractPDEOperator; equation_name) -> Union{Nothing, Int64}\n\n\nAdds the given abstract PDEOperator to the left-hand side of the PDEDescription at the specified position. The id of the operator in the coressponding LHS block of PDEDescription is returned.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_operator!-Tuple{PDEDescription, Vector{Int64}, GradientRobustMultiPhysics.PDEOperator}","page":"PDE Description","title":"GradientRobustMultiPhysics.add_operator!","text":"add_operator!(PDE::PDEDescription, position::Vector{Int64}, O::GradientRobustMultiPhysics.PDEOperator; equation_name) -> Union{Nothing, Int64}\n\n\nAdds the given linear PDEOperator to the left-hand side of the PDEDescription at the specified position. Optionally, the name of the equation can be changed. The id of the operator in the coressponding LHS block of PDEDescription is returned.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_operator!-Union{Tuple{APT}, Tuple{T}, Tuple{PDEDescription, Int64, GradientRobustMultiPhysics.PDEOperator{T, APT}}} where {T, APT<:NonlinearForm}","page":"PDE Description","title":"GradientRobustMultiPhysics.add_operator!","text":"add_operator!(PDE::PDEDescription, equation::Int64, O::GradientRobustMultiPhysics.PDEOperator{T, APT<:NonlinearForm}; equation_name)\n\n\nAdds the given nonlinear PDEOperator to the specified equation of the PDEDescription. Optionally, the name of the equation can be changed.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_rhsdata!-Tuple{PDEDescription, Int64, AbstractPDEOperator}","page":"PDE Description","title":"GradientRobustMultiPhysics.add_rhsdata!","text":"add_rhsdata!(PDE::PDEDescription, position::Int64, O::AbstractPDEOperator) -> Int64\n\n\nAdds the given PDEOperator to the right-hand side of the PDEDescription at the specified position. The id of the operator in the coressponding RHS block of PDEDescription is returned.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.add_unknown!-Tuple{PDEDescription}","page":"PDE Description","title":"GradientRobustMultiPhysics.add_unknown!","text":"add_unknown!(PDE::PDEDescription; equation_name, unknown_name, algebraic_constraint)\n\n\nAdds another unknown to the PDEDescription. With the optional argument algebraic_constraint = true the unknown and the related equation can be mask as an algebraic constraint. (Currently this only has a consequence if the system is integrated in time with the Crank-Nicolson rule.)\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.replace_operator!-Tuple{PDEDescription, Vector{Int64}, Int64, AbstractPDEOperator}","page":"PDE Description","title":"GradientRobustMultiPhysics.replace_operator!","text":"replace_operator!(PDE::PDEDescription, position::Vector{Int64}, id::Int64, O::AbstractPDEOperator; equation_name)\n\n\nReplaces the operator at position[id] of the left-hand side of the PDEDescription with the given PDEOperator.\n\n\n\n\n\n","category":"method"},{"location":"pdedescription/#GradientRobustMultiPhysics.replace_rhsdata!-Tuple{PDEDescription, Int64, Int64, AbstractPDEOperator}","page":"PDE Description","title":"GradientRobustMultiPhysics.replace_rhsdata!","text":"replace_rhsdata!(PDE::PDEDescription, position::Int64, id::Int64, O::AbstractPDEOperator)\n\n\nReplaces the operator at position[id] of the right-hand side of the PDEDescription with the given PDEOperator.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Finite-Element-Spaces-and-Arrays","page":"Finite Element Spaces and Arrays","title":"Finite Element Spaces and Arrays","text":"","category":"section"},{"location":"fespace/","page":"Finite Element Spaces and Arrays","title":"Finite Element Spaces and Arrays","text":"This page describes the structure FESpace that acts as a finite element space on a given grid and provides the associated degree of freedom maps DofMaps on demand. See Implemented Finite Elements for a list of available finite element types.","category":"page"},{"location":"fespace/","page":"Finite Element Spaces and Arrays","title":"Finite Element Spaces and Arrays","text":"Moreover, there are special arrays FEVector and FEMatrix that carry coefficients and discretised PDEOperators.","category":"page"},{"location":"fespace/#FESpace","page":"Finite Element Spaces and Arrays","title":"FESpace","text":"","category":"section"},{"location":"fespace/","page":"Finite Element Spaces and Arrays","title":"Finite Element Spaces and Arrays","text":"To generate a finite element space only a finite element type and a grid is needed, dofmaps are generated automatically on demand.","category":"page"},{"location":"fespace/","page":"Finite Element Spaces and Arrays","title":"Finite Element Spaces and Arrays","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"finiteelements.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fespace/#GradientRobustMultiPhysics.FESpace","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.FESpace","text":"struct FESpace{Tv, Ti, FEType<:AbstractFiniteElement,AT<:AssemblyType}\n    name::String                          # full name of finite element space (used in messages)\n    broken::Bool                          # if true, broken dofmaps are generated\n    ndofs::Int                            # total number of dofs\n    coffset::Int                          # offset for component dofs\n    xgrid::ExtendableGrid[Tv,Ti}          # link to xgrid \n    dofmaps::Dict{Type{<:AbstractGridComponent},Any} # backpack with dofmaps\nend\n\nA struct that has a finite element type as parameter and carries dofmaps (CellDofs, FaceDofs, BFaceDofs) plus additional grid information and access to arrays holding coefficients if needed.\n\n\n\n\n\n","category":"type"},{"location":"fespace/#GradientRobustMultiPhysics.FESpace-Union{Tuple{ExtendableGrid{Tv, Ti}}, Tuple{AT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, FEType<:AbstractFiniteElement, AT<:AssemblyType}","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.FESpace","text":"function FESpace{FEType<:AbstractFiniteElement,AT<:AssemblyType}(\n    xgrid::ExtendableGrid{Tv,Ti};\n    name = \"\",\n    broken::Bool = false)\n\nConstructor for FESpace of the given FEType, AT = ONCELLS/ONFACES/ONEDGES generates a finite elements space on the cells/faces/edges of the provided xgrid (if omitted ONCELLS is used as default). The broken switch allows to generate a broken finite element space (that is piecewise H1/Hdiv/HCurl). If no name is provided it is generated automatically from FEType. If no AT is provided, the space is generated ON_CELLS.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.eltype-Union{Tuple{FESpace{Tv, Ti, FEType, APT}}, Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, FEType<:AbstractFiniteElement, APT}","page":"Finite Element Spaces and Arrays","title":"Base.eltype","text":"eltype(_::FESpace{Tv, Ti, FEType<:AbstractFiniteElement, APT}) -> Type{FEType} where FEType<:AbstractFiniteElement\n\n\nCustom eltype function for FESpace returns the finite element type parameter of the finite element space.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.get!-Tuple{FESpace, Type{<:DofMap}}","page":"Finite Element Spaces and Arrays","title":"Base.get!","text":"get!(FES::FESpace, DM::Type{<:DofMap}) -> Any\n\n\nTo be called by getindex. This triggers lazy creation of  non-existing dofmaps\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.getindex-Tuple{FESpace, Type{<:DofMap}}","page":"Finite Element Spaces and Arrays","title":"Base.getindex","text":"Base.getindex(FES::FESpace,DM::Type{<:DofMap})\n\nGeneric method for obtaining dofmap. This method is mutating in the sense that non-existing dofmaps are created on demand. Due to the fact that components are stored as Any the return value triggers type instability.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.setindex!-Tuple{FESpace, Any, Type{<:DofMap}}","page":"Finite Element Spaces and Arrays","title":"Base.setindex!","text":"setindex!(FES::FESpace, v, DM::Type{<:DofMap}) -> Any\n\n\nSet new dofmap\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.show-Union{Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}, Tuple{IO, FESpace{Tv, Ti, FEType, APT}}} where {Tv, Ti, FEType<:AbstractFiniteElement, APT}","page":"Finite Element Spaces and Arrays","title":"Base.show","text":"show(io::IO, FES::FESpace{Tv, Ti, FEType<:AbstractFiniteElement, APT})\n\n\nCustom show function for FESpace that prints some information and all available dofmaps.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.assemblytype-Union{Tuple{FESpace{Tv, Ti, FEType, APT}}, Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti, FEType<:AbstractFiniteElement, APT}","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.assemblytype","text":"returns the assembly type parameter of the finite element space, i.e. on which entities of the grid the finite element is defined.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#DofMaps","page":"Finite Element Spaces and Arrays","title":"DofMaps","text":"","category":"section"},{"location":"fespace/","page":"Finite Element Spaces and Arrays","title":"Finite Element Spaces and Arrays","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"dofmaps.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fespace/#GradientRobustMultiPhysics.DofMap","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.DofMap","text":"abstract type DofMap <: AbstractGridAdjacency\n\nDofmaps are stored as an ExtendableGrids.AbstractGridAdjacency in the finite element space and collect information with respect to different AssemblyTypes. They are generated automatically on demand and the dofmaps associated to each subtype can be accessed via FESpace[DofMap].\n\n\n\n\n\n","category":"type"},{"location":"fespace/","page":"Finite Element Spaces and Arrays","title":"Finite Element Spaces and Arrays","text":"The following DofMap subtypes are available and are used as keys to access the dofmap via FESpace[DofMap] (which is equivalent to FESpace.dofmaps[DofMap]).","category":"page"},{"location":"fespace/","page":"Finite Element Spaces and Arrays","title":"Finite Element Spaces and Arrays","text":"DofMap Explanation\nCellDofs degrees of freedom for on each cell\nFaceDofs degrees of freedom for each face\nEdgeDofs degrees of freedom for each edge (in 3D)\nBFaceDofs degrees of freedom for each boundary face\nBEdgeDofs degrees of freedom for each boundary edge (in 3D)","category":"page"},{"location":"fespace/#FEVector","page":"Finite Element Spaces and Arrays","title":"FEVector","text":"","category":"section"},{"location":"fespace/","page":"Finite Element Spaces and Arrays","title":"Finite Element Spaces and Arrays","text":"A FEVector consists of FEVectorBlocks that share a common one-dimensional array. Each block is associated to a FESpace and can only write into a region of the common array specified by offsets. It also acts as a one-dimensional AbstractArray itself.","category":"page"},{"location":"fespace/","page":"Finite Element Spaces and Arrays","title":"Finite Element Spaces and Arrays","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"fevector.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fespace/#GradientRobustMultiPhysics.FEVector","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.FEVector","text":"struct FEVector{T, Tv, Ti}\n\na plain array but with an additional layer of several FEVectorBlock subdivisions each carrying coefficients for their associated FESpace\n\n\n\n\n\n","category":"type"},{"location":"fespace/#GradientRobustMultiPhysics.FEVector-Union{Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}, Tuple{String, FESpace{Tv, Ti, FEType, APT}}} where {Tv, Ti, FEType, APT}","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.FEVector","text":"FEVector{T}(name::String, FES::FESpace) where T <: Real\n\nCreates FEVector that has one block.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.FEVector-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Any, Vector{<:FESpace{Tv, Ti}}}} where {Tv, Ti}","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.FEVector","text":"FEVector{T}(name::String, FES::Array{FESpace,1}) where T <: Real\n\nCreates FEVector that has one block for each FESpace in FES.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.FEVectorBlock","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.FEVectorBlock","text":"struct FEVectorBlock{T, Tv, Ti, FEType, APT} <: AbstractArray{T, 1}\n\nblock of an FEVector that carries coefficients for an associated FESpace and can be assigned as an AbstractArray (getindex, setindex, size, length)\n\n\n\n\n\n","category":"type"},{"location":"fespace/#Base.append!-Union{Tuple{APT}, Tuple{FEType}, Tuple{Ti}, Tuple{Tv}, Tuple{T}, Tuple{FEVector{T}, String, FESpace{Tv, Ti, FEType, APT}}} where {T, Tv, Ti, FEType, APT}","page":"Finite Element Spaces and Arrays","title":"Base.append!","text":"append!(FEF::FEVector{T}, name::String, FES::FESpace{Tv, Ti, FEType, APT})\n\n\nCustom append function for FEVector that adds a FEVectorBlock at the end.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.fill!-Tuple{FEVectorBlock, Any}","page":"Finite Element Spaces and Arrays","title":"Base.fill!","text":"fill!(b::FEVectorBlock, value)\n\n\nCustom fill function for FEVectorBlock (only fills the block, not the complete FEVector).\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.length-Tuple{FEVectorBlock}","page":"Finite Element Spaces and Arrays","title":"Base.length","text":"length(FEB::FEVectorBlock) -> Int64\n\n\nCustom length function for FEVectorBlock that gives the coressponding number of degrees of freedoms of the associated FESpace\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.length-Tuple{FEVector}","page":"Finite Element Spaces and Arrays","title":"Base.length","text":"length(FEF::FEVector) -> Int64\n\n\nCustom length function for FEVector that gives the number of defined FEMatrixBlocks in it\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.show-Tuple{IO, FEVector}","page":"Finite Element Spaces and Arrays","title":"Base.show","text":"show(io::IO, FEF::FEVector)\n\n\nCustom show function for FEVector that prints some information on its blocks.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.addblock!-Tuple{FEVectorBlock, AbstractVector}","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.addblock!","text":"addblock!(a::FEVectorBlock, b::AbstractVector; factor)\n\n\nAdds Array b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.addblock!-Tuple{FEVectorBlock, FEVectorBlock}","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.addblock!","text":"addblock!(a::FEVectorBlock, b::FEVectorBlock; factor)\n\n\nAdds FEVectorBlock b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#FEMatrix","page":"Finite Element Spaces and Arrays","title":"FEMatrix","text":"","category":"section"},{"location":"fespace/","page":"Finite Element Spaces and Arrays","title":"Finite Element Spaces and Arrays","text":"A FEMatrix consists of FEMatrixBlocks that share a common ExtendableSparseMatrix. Each block is associated to two FESpaces and can only write into a submatrix of the common sparse matrix specified by offsets. It also acts as a two-dimensional AbstractArray itself.","category":"page"},{"location":"fespace/","page":"Finite Element Spaces and Arrays","title":"Finite Element Spaces and Arrays","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"fematrix.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"fespace/#GradientRobustMultiPhysics.FEMatrix","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.FEMatrix","text":"struct FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}\n\nan AbstractMatrix (e.g. an ExtendableSparseMatrix) with an additional layer of several FEMatrixBlock subdivisions each carrying coefficients for their associated pair of FESpaces\n\n\n\n\n\n","category":"type"},{"location":"fespace/#GradientRobustMultiPhysics.FEMatrix-Union{Tuple{APTX}, Tuple{FETypeX}, Tuple{TiG}, Tuple{TvG}, Tuple{TvM}, Tuple{String, FESpace{TvG, TiG, FETypeX, APTX}}} where {TvM, TvG, TiG, FETypeX, APTX}","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.FEMatrix","text":"FEMatrix{TvM,TiM}(name::String, FES::FESpace{TvG,TiG,FETypeX,APTX}) where {TvG,TiG,FETypeX,APTX}\n\nCreates FEMatrix with one square block (FES,FES).\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.FEMatrix-Union{Tuple{APTY}, Tuple{APTX}, Tuple{FETypeY}, Tuple{FETypeX}, Tuple{TiG}, Tuple{TvG}, Tuple{TvM}, Tuple{String, FESpace{TvG, TiG, FETypeX, APTX}, FESpace{TvG, TiG, FETypeY, APTY}}} where {TvM, TvG, TiG, FETypeX, FETypeY, APTX, APTY}","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.FEMatrix","text":"FEMatrix{TvM,TiM}(name::String, FESX::FESpace{TvG,TiG,FETypeX,APTX}, FESY::FESpace{TvG,TiG,FETypeY,APTY}) where {TvG,TiG,FETypeX,FETypeY,APTX,APTY}\n\nCreates FEMatrix with one rectangular block (FESX,FESY).\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.FEMatrix-Union{Tuple{TiG}, Tuple{TvG}, Tuple{TvM}, Tuple{String, Vector{<:FESpace{TvG, TiG}}}} where {TvM, TvG, TiG}","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.FEMatrix","text":"FEMatrix{T}(name::String, FES::Array{FESpace,1}) where T <: Real\n\nCreates FEMatrix with blocks (FESX[i],FESY[j]) (enumerated row-wise).\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.FEMatrixBlock","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.FEMatrixBlock","text":"struct FEMatrixBlock{TvM, TiM, TvG, TiG, FETypeX, FETypeY, APTX, APTY} <: AbstractArray{TvM, 2}\n\nblock of an FEMatrix that carries coefficients for an associated pair of FESpaces and can be assigned as an two-dimensional AbstractArray (getindex, setindex, size)\n\n\n\n\n\n","category":"type"},{"location":"fespace/#Base.fill!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock{Tv, Ti}, Any}} where {Tv, Ti}","page":"Finite Element Spaces and Arrays","title":"Base.fill!","text":"fill!(B::FEMatrixBlock{Tv, Ti}, value)\n\n\nCustom fill function for FEMatrixBlock (only fills the block, not the complete FEMatrix).\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.length-Union{Tuple{FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}}, Tuple{nbtotal}, Tuple{nbcol}, Tuple{nbrow}, Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}} where {TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}","page":"Finite Element Spaces and Arrays","title":"Base.length","text":"Custom length function for FEMatrix that gives the total number of defined FEMatrixBlocks in it\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.show-Union{Tuple{nbtotal}, Tuple{nbcol}, Tuple{nbrow}, Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}, Tuple{IO, FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}}} where {TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}","page":"Finite Element Spaces and Arrays","title":"Base.show","text":"show(io::IO, FEM::FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal})\n\n\nCustom show function for FEMatrix that prints some information on its blocks.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.size-Tuple{FEMatrixBlock}","page":"Finite Element Spaces and Arrays","title":"Base.size","text":"size(FEB::FEMatrixBlock) -> Vector{Int64}\n\n\nCustom size function for FEMatrixBlock that gives the size of the block (that coressponds to the number of degrees of freedoms in X and Y)\n\n\n\n\n\n","category":"method"},{"location":"fespace/#Base.size-Union{Tuple{FEMatrix{TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}}, Tuple{nbtotal}, Tuple{nbcol}, Tuple{nbrow}, Tuple{TiG}, Tuple{TvG}, Tuple{TiM}, Tuple{TvM}} where {TvM, TiM, TvG, TiG, nbrow, nbcol, nbtotal}","page":"Finite Element Spaces and Arrays","title":"Base.size","text":"Custom size function for FEMatrix that gives the number of rows and columns of the FEBlock overlay\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.add!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrix{Tv, Ti}, FEMatrix{Tv, Ti}}} where {Tv, Ti}","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.add!","text":"add!(A::FEMatrix{Tv, Ti}, B::FEMatrix{Tv, Ti}; factor, transpose)\n\n\nAdds FEMatrix B to FEMatrix A.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.addblock!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock{Tv, Ti}, FEMatrixBlock{Tv, Ti}}} where {Tv, Ti}","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.addblock!","text":"addblock!(A::FEMatrixBlock{Tv, Ti}, B::FEMatrixBlock{Tv, Ti}; factor, transpose)\n\n\nAdds FEMatrixBlock B to FEMatrixBlock A.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.addblock!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEMatrixBlock{Tv}, ExtendableSparseMatrix{Tv, Ti}}} where {Tv, Ti<:Integer}","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.addblock!","text":"addblock!(A::FEMatrixBlock{Tv}, B::ExtendableSparseMatrix{Tv, Ti<:Integer}; factor, transpose)\n\n\nAdds ExtendableSparseMatrix B to FEMatrixBlock A.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.addblock_matmul!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractVector{Tv}, FEMatrixBlock{Tv, Ti}, AbstractVector{Tv}}} where {Tv, Ti}","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.addblock_matmul!","text":"addblock_matmul!(a::AbstractArray{Tv, 1}, B::FEMatrixBlock{Tv, Ti}, b::AbstractArray{Tv, 1}; factor, transposed)\n\n\nAdds matrix-vector product B times b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.addblock_matmul!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEVectorBlock{Tv}, ExtendableSparseMatrix{Tv, Ti}, FEVectorBlock{Tv}}} where {Tv, Ti<:Integer}","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.addblock_matmul!","text":"addblock_matmul!(a::FEVectorBlock{Tv}, B::ExtendableSparseMatrix{Tv, Ti<:Integer}, b::FEVectorBlock{Tv}; factor)\n\n\nAdds matrix-vector product B times b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.addblock_matmul!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{FEVectorBlock{Tv}, FEMatrixBlock{Tv, Ti}, FEVectorBlock{Tv}}} where {Tv, Ti}","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.addblock_matmul!","text":"addblock_matmul!(a::FEVectorBlock{Tv}, B::FEMatrixBlock{Tv, Ti}, b::FEVectorBlock{Tv}; factor, transposed)\n\n\nAdds matrix-vector product B times b to FEVectorBlock a.\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.ldrdmatmul-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractVector{Tv}, AbstractVector{Tv}, ExtendableSparseMatrix{Tv, Ti}, AbstractVector{Tv}, AbstractVector{Tv}}} where {Tv, Ti<:Integer}","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.ldrdmatmul","text":"ldrdmatmul(a1::AbstractArray{Tv, 1}, a2::AbstractArray{Tv, 1}, B::ExtendableSparseMatrix{Tv, Ti<:Integer}, b1::AbstractArray{Tv, 1}, b2::AbstractArray{Tv, 1}; factor) -> Any\n\n\nComputes vector'-matrix-vector product (a1-a2)'B(b1-b2).\n\n\n\n\n\n","category":"method"},{"location":"fespace/#GradientRobustMultiPhysics.lrmatmul-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractVector{Tv}, ExtendableSparseMatrix{Tv, Ti}, AbstractVector{Tv}}} where {Tv, Ti<:Integer}","page":"Finite Element Spaces and Arrays","title":"GradientRobustMultiPhysics.lrmatmul","text":"lrmatmul(a::AbstractArray{Tv, 1}, B::ExtendableSparseMatrix{Tv, Ti<:Integer}, b::AbstractArray{Tv, 1}; factor) -> Any\n\n\nComputes vector'-matrix-vector product a'Bb.\n\n\n\n\n\n","category":"method"},{"location":"examples/Example211_NonlinearElasticityBimetal2D/#:-Nonlinear-Elasticity-Bimetal-2D","page":"211 : Nonlinear Elasticity Bimetal 2D","title":"211 : Nonlinear Elasticity Bimetal 2D","text":"","category":"section"},{"location":"examples/Example211_NonlinearElasticityBimetal2D/","page":"211 : Nonlinear Elasticity Bimetal 2D","title":"211 : Nonlinear Elasticity Bimetal 2D","text":"(source code)","category":"page"},{"location":"examples/Example211_NonlinearElasticityBimetal2D/","page":"211 : Nonlinear Elasticity Bimetal 2D","title":"211 : Nonlinear Elasticity Bimetal 2D","text":"This example computes the displacement field u of the nonlinear elasticity problem","category":"page"},{"location":"examples/Example211_NonlinearElasticityBimetal2D/","page":"211 : Nonlinear Elasticity Bimetal 2D","title":"211 : Nonlinear Elasticity Bimetal 2D","text":"beginaligned\n-mathrmdiv(mathbbC (epsilon(u)-epsilon_T))  = 0 quad textin  Omega\nendaligned","category":"page"},{"location":"examples/Example211_NonlinearElasticityBimetal2D/","page":"211 : Nonlinear Elasticity Bimetal 2D","title":"211 : Nonlinear Elasticity Bimetal 2D","text":"where an isotropic stress tensor mathbbC is applied to the nonlinear strain epsilon(u) = frac12(nabla u + (nabla u)^T + (nabla u)^T nabla u) and a misfit strain  epsilon_T = Delta T alpha due to thermal load caused by temperature(s) Delta T and thermal expansion coefficients alpha (that may be different) in the two regions of the bimetal.","category":"page"},{"location":"examples/Example211_NonlinearElasticityBimetal2D/","page":"211 : Nonlinear Elasticity Bimetal 2D","title":"211 : Nonlinear Elasticity Bimetal 2D","text":"This example demonstrates how to setup a nonlinear expression with automatic differentiation and how to assign it to the problem description.","category":"page"},{"location":"examples/Example211_NonlinearElasticityBimetal2D/","page":"211 : Nonlinear Elasticity Bimetal 2D","title":"211 : Nonlinear Elasticity Bimetal 2D","text":"Note: For the mesh generation the additional packages SimplexGridFactory and Triangulate are needed.","category":"page"},{"location":"examples/Example211_NonlinearElasticityBimetal2D/","page":"211 : Nonlinear Elasticity Bimetal 2D","title":"211 : Nonlinear Elasticity Bimetal 2D","text":"module Example211_NonlinearElasticityBimetal2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing SimplexGridFactory\nusing Triangulate\nusing GridVisualize\n\n# kernel for nonlinear operator\nfunction nonlinear_operator_kernel!(λ,μ,ΔT,α)\n\n    # thermal misfit strain\n    ϵT::Float64 = ΔT*α\n\n    function closure(result, input)\n        # input = grad(u) written as a vector\n        # compute linear part of strain, subtract thermal strain (all in Voigt notation)\n        result[1] = input[1] - ϵT\n        result[2] = input[4] - ϵT\n        result[3] = input[2] + input[3]\n\n        # add nonlinear part of the strain 1/2 * (grad(u)'*grad(u))\n        result[1] += 1//2 * (input[1]^2 + input[3]^2)\n        result[2] += 1//2 * (input[2]^2 + input[4]^2)\n        result[3] += input[1]*input[2] + input[3]*input[4]\n\n        # multiply with isotropic stress tensor\n        # (stored in input[5:7] using Voigt notation)\n        input[5] = λ*(result[1]+result[2]) + 2*μ*result[1]\n        input[6] = λ*(result[1]+result[2]) + 2*μ*result[2]\n        input[7] = 2*μ*result[3]\n\n        # write strain into result\n        result[1] = input[5]\n        result[2] = input[7]\n        result[3] = input[7]\n        result[4] = input[6]\n\n        return nothing\n    end\n    return closure\nend\n\n# everything is wrapped in a main function\nfunction main(; ν = [0.3,0.3], E = [2.1,1.1], ΔT = [580,580], α = [1.3e-5,2.4e-5], scale = [20,500], nrefinements = 1, material_border = 0.5, verbosity = 0, Plotter = nothing)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # compute Lame' coefficients μ and λ from ν and E\n    μ = E ./ (2  .* (1 .+ ν.^(-1)))\n    λ = E .* ν ./ ( (1 .- 2*ν) .* (1 .+ ν))\n\n    # generate bimetal mesh\n    xgrid = bimetal_strip2D(; material_border = material_border, scale = scale)\n    xgrid = uniform_refine(xgrid,nrefinements)\n\n    # prepare nonlinear operator (one for each bimetal region)\n    nonlin_operator_1 = NonlinearForm([Gradient], [1], Gradient, nonlinear_operator_kernel!(λ[1],μ[1],ΔT[1],α[1]), [4,4,7]; name = \"C(ϵ(u)-ϵT):∇v\", regions = [1], quadorder = 3, ADnewton = true)\n    nonlin_operator_2 = NonlinearForm([Gradient], [1], Gradient, nonlinear_operator_kernel!(λ[2],μ[2],ΔT[2],α[2]), [4,4,7]; name = \"C(ϵ(u)-ϵT):∇v\", regions = [2], quadorder = 3, ADnewton = true)\n\n    # generate problem description and assign nonlinear operators\n    Problem = PDEDescription(\"nonlinear elasticity problem\")\n    add_unknown!(Problem; unknown_name = \"u\", equation_name = \"displacement equation\")\n    add_operator!(Problem, 1, nonlin_operator_1)\n    add_operator!(Problem, 1, nonlin_operator_2)\n    add_boundarydata!(Problem, 1, [1,11], HomogeneousDirichletBoundary)\n    @show Problem\n\n    # create finite element space and solution vector\n    FEType = H1P2{2,2}\n    FES = FESpace{FEType}(xgrid)\n    Solution = FEVector(\"u_h\",FES)\n\n    # solve\n    solve!(Solution, Problem; maxiterations = 10, target_residual = 1e-9, show_statistics = true)\n\n    # displace mesh and plot\n    p = GridVisualizer(; Plotter = Plotter, layout = (2,1), clear = true, resolution = (800,600))\n    scalarplot!(p[1,1], xgrid, view(nodevalues(Solution[1]; abs = true),1,:), levels = 0, colorbarticks = 7, xlimits = [0, scale[2]+10], ylimits = [-100,scale[1]])\n    vectorplot!(p[1,1], xgrid, evaluate(PointEvaluator(Solution[1], Identity)), spacing = [50,25], clear = false, title = \"u_h (abs + quiver)\")\n    displace_mesh!(xgrid, Solution[1])\n    gridplot!(p[2,1], xgrid, linewidth = \"1\", title = \"displaced mesh\")\nend\n\n\nfunction bimetal_strip2D(; material_border = 0.5, scale = [1,1], maxvol = prod(scale)/4)\n    builder=SimplexGridBuilder(Generator=Triangulate)\n    @info \"Generating 2d bimetal grid for scale = $scale\"\n\n    p1=point!(builder,0,0)\n    p2=point!(builder,scale[2],0)\n    p3=point!(builder,scale[2],scale[1])\n    p4=point!(builder,0,scale[1])\n    p5=point!(builder,0,material_border*scale[1])\n    p6=point!(builder,scale[2],material_border*scale[1])\n\n    facetregion!(builder,1) # left (material A)\n    facet!(builder,p5 ,p1)\n    facetregion!(builder,11) # left (material B)\n    facet!(builder,p4,p5)\n    facetregion!(builder,2) # bottom\n    facet!(builder,p1 ,p2)\n    facetregion!(builder,3) # top\n    facet!(builder,p3, p4)\n    facetregion!(builder,4) # right\n    facet!(builder,p2, p6)\n    facet!(builder,p6, p3)\n    facetregion!(builder,99) # interior facet to split regions\n    facet!(builder,p5, p6)\n\n    cellregion!(builder,1)\n    maxvolume!(builder,maxvol)\n    regionpoint!(builder,(0.5*scale[2],0.5*material_border*scale[1]))\n    cellregion!(builder,2)\n    maxvolume!(builder,maxvol)\n    regionpoint!(builder,(0.5*scale[2],0.5*(material_border+1)*scale[1]))\n\n    xgrid = simplexgrid(builder)\n    return xgrid\nend\n\nend","category":"page"},{"location":"examples/Example211_NonlinearElasticityBimetal2D/","page":"211 : Nonlinear Elasticity Bimetal 2D","title":"211 : Nonlinear Elasticity Bimetal 2D","text":"","category":"page"},{"location":"examples/Example211_NonlinearElasticityBimetal2D/","page":"211 : Nonlinear Elasticity Bimetal 2D","title":"211 : Nonlinear Elasticity Bimetal 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example211_NonlinearElasticityBimetal2D/","page":"211 : Nonlinear Elasticity Bimetal 2D","title":"211 : Nonlinear Elasticity Bimetal 2D","text":"Default output:","category":"page"},{"location":"examples/Example211_NonlinearElasticityBimetal2D/","page":"211 : Nonlinear Elasticity Bimetal 2D","title":"211 : Nonlinear Elasticity Bimetal 2D","text":"julia> Example211_NonlinearElasticityBimetal2D.main()\n\nPDE-DESCRIPTION\n===============\n  system name = nonlinear elasticity problem\n\n     id   | unknown name / equation name\n    [1]   | u / displacement equation \n\n  LHS block | PDEOperator(s)\n    [1,1]   | C(ϵ(u)-ϵT):∇v [AD-Newton] [∂u] (APT = NonlinearForm, AT = ON_CELLS, regions = [1])\n            | C(ϵ(u)-ϵT):∇v [AD-Newton] [∂u] (APT = NonlinearForm, AT = ON_CELLS, regions = [2])\n\n  RHS block | PDEOperator(s)\n     [1]    | C(ϵ(u)-ϵT):∇v [AD-Newton] (APT = NonlinearForm, AT = ON_CELLS, regions = [1])\n            | C(ϵ(u)-ϵT):∇v [AD-Newton] (APT = NonlinearForm, AT = ON_CELLS, regions = [2])\n\n   BoundaryOperator[1] : HomogeneousDirichletBoundary -> [1, 11]\n                          \n\nProblem = \n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL  | TIME ASSEMBLY/SOLVE/TOTAL (s)\n\t-----------------------------------------------------------------------\n\t      1   | 6.727900e-13 | 2.097176e+00 | 9.03e-02/1.34e-02/1.13e-01\n\t      2   | 7.654010e-13 | 2.059942e-02 | 9.04e-02/1.13e-02/1.02e-01\n\t      3   | 7.383097e-13 | 2.699072e-06 | 9.18e-02/1.16e-02/1.04e-01\n\t      4   | 7.342283e-13 | 1.086384e-12 | 8.94e-02/1.20e-02/1.02e-01\n","category":"page"},{"location":"examples/Example211_NonlinearElasticityBimetal2D/","page":"211 : Nonlinear Elasticity Bimetal 2D","title":"211 : Nonlinear Elasticity Bimetal 2D","text":"(Image: )","category":"page"},{"location":"febasisevaluators/#FE-Basis-Evaluators","page":"FE Basis Evaluators","title":"FE Basis Evaluators","text":"","category":"section"},{"location":"febasisevaluators/","page":"FE Basis Evaluators","title":"FE Basis Evaluators","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"febasisevaluator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"febasisevaluators/#GradientRobustMultiPhysics.FEBasisEvaluator-Union{Tuple{FEAT}, Tuple{AT}, Tuple{FEOP}, Tuple{EG}, Tuple{FEType}, Tuple{TiG}, Tuple{TvG}, Tuple{T}, Tuple{FESpace{TvG, TiG, FEType, FEAT}, QuadratureRule}} where {T, TvG, TiG, FEType, EG, FEOP, AT, FEAT}","page":"FE Basis Evaluators","title":"GradientRobustMultiPhysics.FEBasisEvaluator","text":"FEBasisEvaluator{T,EG,FEOP,AT}(FE::FESpace, qf::QuadratureRule; mutable = false) where {T <: Real, EG <: AbstractElementGeometry, FEOP <: AbstractFunctionOperator, AT <: AssemblyType}\n\nConstructor for an evaluator for the basis of the FESpace FES evaluated with the function operator FEOP on the given element geometry EG with AssemblyType AT at the points of the quadrature rule qf.\n\n\n\n\n\n","category":"method"},{"location":"febasisevaluators/#GradientRobustMultiPhysics.eval_febe!-Union{Tuple{ndofs}, Tuple{ncomponents}, Tuple{edim}, Tuple{AT}, Tuple{EG}, Tuple{FEOP}, Tuple{FEType}, Tuple{TiG}, Tuple{TvG}, Tuple{T}, Tuple{Vector{T}, FEBasisEvaluator{T, TvG, TiG, FEType, EG, FEOP, AT, edim, ncomponents, ndofs}, Int64, Int64}, Tuple{Vector{T}, FEBasisEvaluator{T, TvG, TiG, FEType, EG, FEOP, AT, edim, ncomponents, ndofs}, Int64, Int64, Int64}, Tuple{Vector{T}, FEBasisEvaluator{T, TvG, TiG, FEType, EG, FEOP, AT, edim, ncomponents, ndofs}, Int64, Int64, Int64, Any}} where {T, TvG, TiG, FEType, FEOP, EG, AT, edim, ncomponents, ndofs}","page":"FE Basis Evaluators","title":"GradientRobustMultiPhysics.eval_febe!","text":"    eval_febe!(result, FEBE::FEBasisEvaluator, j::Int, i::Int, offset::Int = 0, factor = 1)\n\nEvaluate the j-th basis function of the FEBasisEvaluator at the i-th quadrature point adn writes the (possibly vector-valued) evaluation into result (beginning at offset and with the specified factor).\n\n\n\n\n\n","category":"method"},{"location":"febasisevaluators/#GradientRobustMultiPhysics.eval_febe!-Union{Tuple{ndofs}, Tuple{ncomponents}, Tuple{edim}, Tuple{AT}, Tuple{EG}, Tuple{FEOP}, Tuple{FEType}, Tuple{TiG}, Tuple{TvG}, Tuple{T}, Tuple{Vector{T}, FEBasisEvaluator{T, TvG, TiG, FEType, EG, FEOP, AT, edim, ncomponents, ndofs}, Vector{T}, Int64}, Tuple{Vector{T}, FEBasisEvaluator{T, TvG, TiG, FEType, EG, FEOP, AT, edim, ncomponents, ndofs}, Vector{T}, Int64, Any}, Tuple{Vector{T}, FEBasisEvaluator{T, TvG, TiG, FEType, EG, FEOP, AT, edim, ncomponents, ndofs}, Vector{T}, Int64, Any, Any}} where {T, TvG, TiG, FEType, FEOP, EG, AT, edim, ncomponents, ndofs}","page":"FE Basis Evaluators","title":"GradientRobustMultiPhysics.eval_febe!","text":"    eval_febe!(result, FEBE::FEBasisEvaluator, j::Int, i::Int, offset::Int = 0, factor = 1)\n\nEvaluates the linear combination of the basisfunction with given coefficients at the i-th quadrature point and writes the (possibly vector-valued) evaluation into result (beginning at offset and with the specified factor).\n\n\n\n\n\n","category":"method"},{"location":"febasisevaluators/#GradientRobustMultiPhysics.update_febe!-Union{Tuple{ndofs}, Tuple{ncomponents}, Tuple{edim}, Tuple{TiG}, Tuple{TvG}, Tuple{T}, Tuple{GradientRobustMultiPhysics.StandardFEBasisEvaluator{T, TvG, TiG, <:AbstractH1FiniteElement, <:AbstractElementGeometry, <:id, <:AssemblyType, edim, ncomponents, ndofs}, Any}} where {T, TvG, TiG, edim, ncomponents, ndofs}","page":"FE Basis Evaluators","title":"GradientRobustMultiPhysics.update_febe!","text":"    update_febe!(FEBE::FEBasisEvaluator, item::Int)\n\nUpdate the FEBasisEvaluator on the given item number of the grid items associated to the AssemblyType. During the update the FEBasisevaluator computes all evaluations of all basis functions at all quadrature points and stores them in FEBE.cvals. From there they can be accessed directly or via the eval_febe! functions.\n\n\n\n\n\n","category":"method"},{"location":"itemintegrators/#Item-Integrators","page":"Item Integrators","title":"Item Integrators","text":"","category":"section"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"Item integrators are one of the Assembly Patterns that help to compute certain quantities of the Solution, like a posteriori errors estimators, norms, drag/lift coefficients or other statistics.","category":"page"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"ItemIntegrator\nL2ErrorIntegrator\nL2NormIntegrator\nL2DifferenceIntegrator","category":"page"},{"location":"itemintegrators/#GradientRobustMultiPhysics.ItemIntegrator","page":"Item Integrators","title":"GradientRobustMultiPhysics.ItemIntegrator","text":"function ItemIntegrator(\n    T::Type{<:Real},\n    AT::Type{<:AssemblyType},\n    operators::Array{DataType,1}, \n    action::AbstractAction; \n    name = \"ItemIntegrator\",\n    regions::Array{Int,1} = [0])\n\nCreates an ItemIntegrator assembly pattern with the given operators and action etc.\n\n\n\n\n\n","category":"function"},{"location":"itemintegrators/#GradientRobustMultiPhysics.L2ErrorIntegrator","page":"Item Integrators","title":"GradientRobustMultiPhysics.L2ErrorIntegrator","text":"function L2ErrorIntegrator(\n    T::Type{<:Real},\n    compare_data::UserData{AbstractDataFunction}, # can be omitted if zero\n    operator::Type{<:AbstractFunctionOperator};\n    quadorder = \"auto\",\n    name = \"auto\",\n    factor = 1,\n    AT::Type{<:AssemblyType} = ON_CELLS,\n    time = 0)\n\nCreates an ItemIntegrator that compares discrete FEVectorBlock operator-evaluations against the given comparedata and returns the L2-error || comparedata(x) - factor*discrete(x) ||. If quadorder is left on \"auto\" two times the quadorder of the data is used in the evaluation.\n\n\n\n\n\n","category":"function"},{"location":"itemintegrators/#GradientRobustMultiPhysics.L2NormIntegrator","page":"Item Integrators","title":"GradientRobustMultiPhysics.L2NormIntegrator","text":"L2NormIntegrator(\n    T::Type{<:Real},\n    ncomponents::Int,\n    operator::Type{<:AbstractFunctionOperator};\n    AT::Type{<:AssemblyType} = ON_CELLS,\n    name = \"L2 norm\",\n    quadorder = 2,\n    regions = [0])\n\nCreates an ItemIntegrator that computes the L2 norm of an operator evaluation where ncomponents is the expected length of the operator evaluation.\n\n\n\n\n\n","category":"function"},{"location":"itemintegrators/#GradientRobustMultiPhysics.L2DifferenceIntegrator","page":"Item Integrators","title":"GradientRobustMultiPhysics.L2DifferenceIntegrator","text":"function L2DifferenceIntegrator(\n    T::Type{<:Real},\n    ncomponents::Int,\n    operator::Union{Type{<:AbstractFunctionOperator},Array{DataType,1}};\n    AT::Type{<:AssemblyType} = ON_CELLS,\n    name = \"L2 difference\",\n    quadorder = 2,\n    regions = [0])\n\nCreates an ItemIntegrator that computes the L2 norm difference between two arguments evalauted with the same operator (or with different operators if operator is an array) where ncomponents is the expected length of each operator evaluation. Note that all arguments in an evaluation call need to be defined on the same grid !\n\n\n\n\n\n","category":"function"},{"location":"itemintegrators/#Evaluation","page":"Item Integrators","title":"Evaluation","text":"","category":"section"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"There are two possibilities to evaluate an ItemIntegrator, on each item (with evaluate!) or globally (with evaluate):","category":"page"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"evaluate!\nevaluate","category":"page"},{"location":"itemintegrators/#GradientRobustMultiPhysics.evaluate!","page":"Item Integrators","title":"GradientRobustMultiPhysics.evaluate!","text":"function evaluate!(\n    result,                     # target for result\n    PE::PointEvaluator,         \n    xref,                       # local coordinates inside item\n    item                        # item number\n    ) where  {T, Tv, Ti, FEType, FEOP, AT, ACT}\n\nEvaluates the PointEvaluator at the point with the given local coordinates insides the item with the specified item number. (To get the local coordinates, currently a CellFinder has to be maintained manually, this might change in future.)\n\n\n\n\n\nfunction evaluate!(\n    b::AbstractArray{T,2},\n    AP::AssemblyPattern{APT,T,AT},\n    FEB::Union{<:FEVector{T,Tv,Ti},<:FEVectorBlock{T,Tv,Ti},Array{<:FEVectorBlock{T,Tv,Ti},1}};\n    skip_preps::Bool = false) where {APT <: APT_ItemIntegrator, T<: Real, AT <: AssemblyType, Tv, Ti}\n\nEvaluation of an ItemIntegrator assembly pattern with given FEVectorBlock or FEVector FEB into given two-dimensional Array b.\n\n\n\n\n\n","category":"function"},{"location":"itemintegrators/#GradientRobustMultiPhysics.evaluate","page":"Item Integrators","title":"GradientRobustMultiPhysics.evaluate","text":"function evaluate(PE::PointEvaluator)\n\nReturns the function     (result,xref,cell) –> evaluate!(result,PE,xref,cell)\n\n(e.g. to be used as a callback function in vectorplot!)\n\n\n\n\n\nfunction evaluate(\n    AP::AssemblyPattern{APT,T,AT},\n    FEB::Union{<:FEVector{T,Tv,Ti},<:FEVectorBlock{T,Tv,Ti},Array{<:FEVectorBlock{T,Tv,Ti},1}};\n    skip_preps::Bool = false) where {APT <: APT_ItemIntegrator, T<: Real, AT <: AssemblyType, Tv, Ti}\n\n\nEvaluation of an ItemIntegrator assembly pattern with given FEVectorBlock or FEVector FEB, only returns accumulation over all items.\n\n\n\n\n\nassemble!(\n    AP::AssemblyPattern{APT,T,AT},         # NonlinearForm pattern\n    FEB::Array{<:FEVectorBlock,1};         # coefficients of current solution for each operator\n    FEBtest::FEVectorBlock;                # coefficients of test function for test function operator\n    factor = 1)                            # factor that is multiplied\n    where {APT <: APT_NonlinearForm, T, AT}\n\nEvaluation of a NonlinearForm AP for given coefficients of ansatz and test function.\n\n\n\n\n\n","category":"function"},{"location":"itemintegrators/#Noteworthy-Examples","page":"Item Integrators","title":"Noteworthy Examples","text":"","category":"section"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"Examples 204 and A06 use ItemIntegrators for a posteriori error estimation and refinement indicators.","category":"page"},{"location":"itemintegrators/","page":"Item Integrators","title":"Item Integrators","text":"Example 224 uses ItemIntegrators to calculate drag and lift coefficients.","category":"page"},{"location":"examples/Example207_StokesTransient2D/#:-Stokes-Transient-2D","page":"207 : Stokes Transient 2D","title":"207 : Stokes Transient 2D","text":"","category":"section"},{"location":"examples/Example207_StokesTransient2D/","page":"207 : Stokes Transient 2D","title":"207 : Stokes Transient 2D","text":"(source code)","category":"page"},{"location":"examples/Example207_StokesTransient2D/","page":"207 : Stokes Transient 2D","title":"207 : Stokes Transient 2D","text":"This example computes a velocity mathbfu and pressure mathbfp of the incompressible Navier–Stokes problem","category":"page"},{"location":"examples/Example207_StokesTransient2D/","page":"207 : Stokes Transient 2D","title":"207 : Stokes Transient 2D","text":"beginaligned\nmathbfu_t - mu Delta mathbfu + nabla p  = mathbff\nmathrmdiv(u)  = 0\nendaligned","category":"page"},{"location":"examples/Example207_StokesTransient2D/","page":"207 : Stokes Transient 2D","title":"207 : Stokes Transient 2D","text":"with (possibly time-dependent) exterior force mathbff and some viscosity parameter mu.","category":"page"},{"location":"examples/Example207_StokesTransient2D/","page":"207 : Stokes Transient 2D","title":"207 : Stokes Transient 2D","text":"In this example we solve an analytical toy problem with prescribed solution","category":"page"},{"location":"examples/Example207_StokesTransient2D/","page":"207 : Stokes Transient 2D","title":"207 : Stokes Transient 2D","text":"beginaligned\nmathbfu(mathbfxt)  = (1+t)(cos(x_2) sin(x_1))^T\np(mathbfx) = sin(x_1+x_2) - 2sin(1) + sin(2)\nendaligned","category":"page"},{"location":"examples/Example207_StokesTransient2D/","page":"207 : Stokes Transient 2D","title":"207 : Stokes Transient 2D","text":"with time-dependent right-hand side and inhomogeneous Dirichlet boundary data. The example showcases the benefits of pressure-robustness in time-dependent linear Stokes problem in presence of complicated pressures and small viscosities. The problem is solved on series of finer and finer unstructured simplex meshes and compares the error of the discrete Stokes solution, an interpolation into the same space and the best-approximations into the same space. While a pressure-robust variant shows optimally converging errors close to the best-approximations, a non pressure-robust discretisations show suboptimal (or no) convergence! Compare e.g. Bernardi–Raugel and Bernardi–Raugel pressure-robust by (un)commenting the responsible lines in this example.","category":"page"},{"location":"examples/Example207_StokesTransient2D/","page":"207 : Stokes Transient 2D","title":"207 : Stokes Transient 2D","text":"module Example207_StokesTransient2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\n\n# problem data\nfunction exact_pressure!(result,x)\n    result[1] = sin(x[1]+x[2]) - 2*sin(1)+sin(2)\nend\nfunction exact_velocity!(result,x,t)\n    result[1] = (1+t)*cos(x[2]);\n    result[2] = (1+t)*sin(x[1]);\nend\nfunction exact_velocity_gradient!(result,x,t)\n    result[1] = 0.0\n    result[2] = -(1+t)*sin(x[2]);\n    result[3] = (1+t)*cos(x[1]);\n    result[4] = 0.0;\nend\nfunction exact_rhs!(viscosity)\n    function closure(result,x,t)\n        result[1] = viscosity*(1+t)*cos(x[2]) + cos(x[1]+x[2]) + cos(x[2])\n        result[2] = viscosity*(1+t)*sin(x[1]) + cos(x[1]+x[2]) + sin(x[1])\n    end\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, Plotter = nothing, nlevels = 4, timestep = 1e-3, T = 1e-2, viscosity = 1e-6, graddiv = 0)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # initial grid\n    xgrid = grid_unitsquare(Triangle2D);\n\n    # choose one of these (inf-sup stable) finite element type pairs\n    reconstruct = false # do not change\n    broken_p = false # is pressure space broken ?\n    #FETypes = [H1P2{2,2}, H1P1{1}] # Taylor--Hood\n    #FETypes = [H1P2B{2,2}, H1P1{1}]; broken_p = true # P2-bubble\n    #FETypes = [H1CR{2}, H1P0{1}]; broken_p = true # Crouzeix--Raviart\n    #FETypes = [H1CR{2}, H1P0{1}]; broken_p = true; reconstruct = true # Crouzeix-Raviart gradient-robust\n    #FETypes = [H1MINI{2,2}, H1P1{1}] # MINI element on triangles only\n    #FETypes = [H1MINI{2,2}, H1CR{1}] # MINI element on triangles/quads\n    #FETypes = [H1BR{2}, H1P0{1}]; broken_p = true # Bernardi--Raugel\n    FETypes = [H1BR{2}, H1P0{1}]; broken_p = true; reconstruct = true # Bernardi--Raugel gradient-robust\n\n    #####################################################################################\n\n    # set testfunction operator for certain testfunctions\n    # (pressure-robustness chooses a reconstruction that can exploit the L2-orthogonality onto gradients)\n    testfunction_operator = reconstruct ? ReconstructionIdentity{HDIVBDM1{2}} : Identity\n\n    # negotiate data functions to the package\n    # note that dependencies \"XT\" marks the function to be x- and t-dependent\n    # that causes the solver to automatically reassemble associated operators in each time step\n    u = DataFunction(exact_velocity!, [2,2]; name = \"u\", dependencies = \"XT\", quadorder = 5)\n    p = DataFunction(exact_pressure!, [1,2]; name = \"p\", dependencies = \"X\", quadorder = 5)\n    ∇u = DataFunction(exact_velocity_gradient!, [4,2]; name = \"∇u\", dependencies = \"XT\", quadorder = 4)\n    user_function_rhs = DataFunction(exact_rhs!(viscosity), [2,2]; name = \"f\", dependencies = \"XT\", quadorder = 5)\n\n    # load Stokes problem prototype and assign data\n    Problem = IncompressibleNavierStokesProblem(2; viscosity = viscosity, nonlinear = false)\n    add_boundarydata!(Problem, 1, [1,2,3,4], BestapproxDirichletBoundary; data = u)\n    add_rhsdata!(Problem, 1, RhsOperator(testfunction_operator, [1], user_function_rhs))\n\n    # add grad-div stabilisation\n    if graddiv > 0\n        add_operator!(Problem, [1,1], BilinearForm(\"graddiv-stabilisation (div x div)\", Divergence, Divergence; factor = graddiv))\n    end\n\n    # define bestapproximation problems\n    BAP_L2_p = L2BestapproximationProblem(p; bestapprox_boundary_regions = [])\n    BAP_L2_u = L2BestapproximationProblem(u; bestapprox_boundary_regions = [1,2,3,4])\n    BAP_H1_u = H1BestapproximationProblem(∇u, u; bestapprox_boundary_regions = [1,2,3,4])\n\n    # define ItemIntegrators for L2/H1 error computation and arrays to store them\n    L2VelocityError = L2ErrorIntegrator(Float64, u, Identity; time = T)\n    L2PressureError = L2ErrorIntegrator(Float64, p, Identity)\n    H1VelocityError = L2ErrorIntegrator(Float64, ∇u, Gradient; time = T)\n    Results = zeros(Float64, nlevels, 6)\n    NDofs = zeros(Int, nlevels)\n\n    # loop over levels\n    for level = 1 : nlevels\n\n        # refine grid\n        xgrid = uniform_refine(xgrid)\n\n        # generate FESpaces\n        FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid; broken = broken_p)]\n\n        # generate solution fector\n        Solution = FEVector([\"u_h\", \"p_h\"],FES)\n\n        # set initial solution ( = bestapproximation at time 0)\n        BA_L2_u = FEVector(\"L2-Bestapproximation velocity\",FES[1])\n        solve!(BA_L2_u, BAP_L2_u; time = 0)\n        Solution[1][:] = BA_L2_u[1][:]\n\n        # generate time-dependent solver and chance rhs data\n        TCS = TimeControlSolver(Problem, Solution, CrankNicolson; timedependent_equations = [1], skip_update = [-1], dt_operator = [testfunction_operator])\n        advance_until_time!(TCS, timestep, T)\n\n        # solve bestapproximation problems at final time for comparison\n        BA_L2_p = FEVector(\"L2-Bestapproximation pressure\",FES[2])\n        BA_H1_u = FEVector(\"H1-Bestapproximation velocity\",FES[1])\n        solve!(BA_L2_u, BAP_L2_u; time = T)\n        solve!(BA_L2_p, BAP_L2_p)\n        solve!(BA_H1_u, BAP_H1_u; time = T)\n\n        # compute L2 and H1 errors and save data\n        NDofs[level] = length(Solution.entries)\n        Results[level,1] = sqrt(evaluate(L2VelocityError,Solution[1]))\n        Results[level,2] = sqrt(evaluate(L2VelocityError,BA_L2_u[1]))\n        Results[level,3] = sqrt(evaluate(L2PressureError,Solution[2]))\n        Results[level,4] = sqrt(evaluate(L2PressureError,BA_L2_p[1]))\n        Results[level,5] = sqrt(evaluate(H1VelocityError,Solution[1]))\n        Results[level,6] = sqrt(evaluate(H1VelocityError,BA_H1_u[1]))\n    end\n\n    # print convergence history\n    print_convergencehistory(NDofs, Results[:,1:2]; X_to_h = X -> X.^(-1/2), ylabels = [\"||u-u_h||\", \"||u-Πu||\"])\n    print_convergencehistory(NDofs, Results[:,3:4]; X_to_h = X -> X.^(-1/2), ylabels = [\"||p-p_h||\", \"||p-πp||\"])\n    print_convergencehistory(NDofs, Results[:,5:6]; X_to_h = X -> X.^(-1/2), ylabels = [\"||∇(u-u_h)||\", \"||∇(u-Su)||\"])\nend\n\nend","category":"page"},{"location":"examples/Example207_StokesTransient2D/","page":"207 : Stokes Transient 2D","title":"207 : Stokes Transient 2D","text":"","category":"page"},{"location":"examples/Example207_StokesTransient2D/","page":"207 : Stokes Transient 2D","title":"207 : Stokes Transient 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example207_StokesTransient2D/","page":"207 : Stokes Transient 2D","title":"207 : Stokes Transient 2D","text":"Default output:","category":"page"},{"location":"examples/Example207_StokesTransient2D/","page":"207 : Stokes Transient 2D","title":"207 : Stokes Transient 2D","text":"julia> Example207_StokesTransient2D.main()\n\n\t  STEP  |    TIME    | LSRESIDUAL |  RUNTIME  |   CHANGE               \n\t        |            |  (total)   |    (s)          u           p     \n\t     1  | 1.0000e-03 | 1.7542e-13 | 5.590e+00 | 4.9651e-03  3.0773e+00 \n\t     2  | 2.0000e-03 | 1.3729e-13 | 2.223e-02 | 3.6022e-03  2.3073e+00 \n\t     3  | 3.0000e-03 | 1.3709e-13 | 1.585e-03 | 3.6022e-03  1.1200e-10 \n\t     4  | 4.0000e-03 | 1.5478e-13 | 1.596e-03 | 3.6022e-03  1.1173e-10 \n\t     5  | 5.0000e-03 | 1.4118e-13 | 1.665e-03 | 3.6022e-03  1.1196e-10 \n\t     6  | 6.0000e-03 | 1.4735e-13 | 1.958e-03 | 3.6022e-03  1.1186e-10 \n\t     7  | 7.0000e-03 | 2.0185e-13 | 1.623e-03 | 3.6022e-03  1.1207e-10 \n\t     8  | 8.0000e-03 | 1.2199e-13 | 1.513e-03 | 3.6022e-03  1.1181e-10 \n\t     9  | 9.0000e-03 | 1.1606e-13 | 1.562e-03 | 3.6022e-03  1.1219e-10 \n\t    10  | 1.0000e-02 | 1.2636e-13 | 1.608e-03 | 3.6022e-03  1.1172e-10 \n\n\t  STEP  |    TIME    | LSRESIDUAL |  RUNTIME  |   CHANGE               \n\t        |            |  (total)   |    (s)          u           p     \n\t     1  | 1.0000e-03 | 7.5005e-14 | 7.698e-03 | 5.6703e-03  2.8195e+00 \n\t     2  | 2.0000e-03 | 9.0562e-14 | 4.112e-03 | 6.4012e-03  1.1598e+00 \n\t     3  | 3.0000e-03 | 7.8369e-14 | 4.005e-03 | 6.4012e-03  1.4686e-10 \n\t     4  | 4.0000e-03 | 8.7015e-14 | 3.914e-03 | 6.4012e-03  1.4500e-10 \n\t     5  | 5.0000e-03 | 8.0621e-14 | 4.070e-03 | 6.4012e-03  1.4620e-10 \n\t     6  | 6.0000e-03 | 8.3306e-14 | 3.948e-03 | 6.4012e-03  1.4580e-10 \n\t     7  | 7.0000e-03 | 7.6818e-14 | 3.939e-03 | 6.4012e-03  1.4587e-10 \n\t     8  | 8.0000e-03 | 7.7989e-14 | 4.120e-03 | 6.4012e-03  1.4592e-10 \n\t     9  | 9.0000e-03 | 9.4069e-14 | 4.111e-03 | 6.4012e-03  1.4617e-10 \n\t    10  | 1.0000e-02 | 7.3994e-14 | 3.979e-03 | 6.4012e-03  1.4539e-10 \n\n\t  STEP  |    TIME    | LSRESIDUAL |  RUNTIME  |   CHANGE               \n\t        |            |  (total)   |    (s)          u           p     \n\t     1  | 1.0000e-03 | 4.0528e-14 | 2.622e-02 | 1.1430e-02  4.0417e+00 \n\t     2  | 2.0000e-03 | 4.3346e-14 | 1.189e-02 | 1.2040e-02  5.7953e-01 \n\t     3  | 3.0000e-03 | 4.1370e-14 | 1.188e-02 | 1.2040e-02  9.5441e-11 \n\t     4  | 4.0000e-03 | 4.3294e-14 | 1.180e-02 | 1.2040e-02  9.4476e-11 \n\t     5  | 5.0000e-03 | 4.3706e-14 | 1.181e-02 | 1.2040e-02  9.5588e-11 \n\t     6  | 6.0000e-03 | 4.3860e-14 | 1.184e-02 | 1.2040e-02  9.4528e-11 \n\t     7  | 7.0000e-03 | 4.5028e-14 | 1.155e-02 | 1.2040e-02  9.5663e-11 \n\t     8  | 8.0000e-03 | 4.2883e-14 | 1.719e-02 | 1.2040e-02  9.4696e-11 \n\t     9  | 9.0000e-03 | 4.3717e-14 | 1.220e-02 | 1.2040e-02  9.5761e-11 \n\t    10  | 1.0000e-02 | 4.3582e-14 | 1.164e-02 | 1.2040e-02  9.4804e-11 \n\n\t  STEP  |    TIME    | LSRESIDUAL |  RUNTIME  |   CHANGE               \n\t        |            |  (total)   |    (s)          u           p     \n\t     1  | 1.0000e-03 | 2.2043e-14 | 1.140e-01 | 2.2994e-02  7.3187e+00 \n\t     2  | 2.0000e-03 | 2.2016e-14 | 5.223e-02 | 2.3341e-02  2.8899e-01 \n\t     3  | 3.0000e-03 | 2.2341e-14 | 4.641e-02 | 2.3341e-02  6.5743e-09 \n\t     4  | 4.0000e-03 | 2.1551e-14 | 4.310e-02 | 2.3341e-02  6.5545e-09 \n\t     5  | 5.0000e-03 | 2.1963e-14 | 4.437e-02 | 2.3341e-02  6.5249e-09 \n\t     6  | 6.0000e-03 | 2.2610e-14 | 4.331e-02 | 2.3341e-02  6.5035e-09 \n\t     7  | 7.0000e-03 | 2.2161e-14 | 4.657e-02 | 2.3341e-02  6.4757e-09 \n\t     8  | 8.0000e-03 | 2.1475e-14 | 4.416e-02 | 2.3341e-02  6.4542e-09 \n\t     9  | 9.0000e-03 | 2.2222e-14 | 4.697e-02 | 2.3341e-02  6.4237e-09 \n\t    10  | 1.0000e-02 | 2.2042e-14 | 6.617e-02 | 2.3341e-02  6.4065e-09 \n\n    ndofs   |      ||u-u_h||       order  |      ||u-Πu||        order  |\n============|=============================|=============================|\n        70  |     2.83479e-03      0.000  |     2.16474e-03      0.000  |\n       250  |     6.94501e-04      2.210  |     5.11118e-04      2.268  |\n       946  |     1.70437e-04      2.111  |     1.21282e-04      2.162  |\n      3682  |     4.22288e-05      2.053  |     2.92850e-05      2.091  |\n\n    ndofs   |      ||p-p_h||       order  |      ||p-πp||        order  |\n============|=============================|=============================|\n        70  |     6.98506e-02      0.000  |     6.98503e-02      0.000  |\n       250  |     3.49744e-02      1.087  |     3.49744e-02      1.087  |\n       946  |     1.74943e-02      1.041  |     1.74943e-02      1.041  |\n      3682  |     8.74806e-03      1.020  |     8.74806e-03      1.020  |\n\n    ndofs   |    ||∇(u-u_h)||      order  |     ||∇(u-Su)||      order  |\n============|=============================|=============================|\n        70  |     5.12836e-02      0.000  |     4.81476e-02      0.000  |\n       250  |     2.59216e-02      1.072  |     2.38875e-02      1.101  |\n       946  |     1.30868e-02      1.027  |     1.18665e-02      1.051  |\n      3682  |     6.52912e-03      1.023  |     5.90884e-03      1.026  |","category":"page"},{"location":"boundarydata/#Boundary-Data","page":"Boundary Data","title":"Boundary Data","text":"","category":"section"},{"location":"boundarydata/#Dirichlet-Boundary-Data","page":"Boundary Data","title":"Dirichlet Boundary Data","text":"","category":"section"},{"location":"boundarydata/","page":"Boundary Data","title":"Boundary Data","text":"BoundaryOperators carry the boundary data for each unknown. Each regions can have a different AbstractBoundaryType and an associated Data Function. This data function than will now if it depends on space or time variables and will assemble itself accordingly.","category":"page"},{"location":"boundarydata/","page":"Boundary Data","title":"Boundary Data","text":"AbstractBoundaryType Subtypes causes\nDirichletBoundary  \n BestapproxDirichletBoundary computation of Dirichlet data by bestapproximation along boundary faces\n InterpolateDirichletBoundary computation of Dirichlet data by interpolation along boundary faces\n HomogeneousDirichletBoundary zero Dirichlet data on all dofs","category":"page"},{"location":"boundarydata/","page":"Boundary Data","title":"Boundary Data","text":"BoundaryOperator\nadd_boundarydata!","category":"page"},{"location":"boundarydata/#GradientRobustMultiPhysics.BoundaryOperator","page":"Boundary Data","title":"GradientRobustMultiPhysics.BoundaryOperator","text":"mutable struct BoundaryOperator <: AbstractPDEOperator\n\ncollects boundary data for a component of the system and allows to specify a AbstractBoundaryType for each boundary region so far only DirichletBoundary types (see above)\n\n\n\n\n\n","category":"type"},{"location":"boundarydata/#GradientRobustMultiPhysics.add_boundarydata!","page":"Boundary Data","title":"GradientRobustMultiPhysics.add_boundarydata!","text":"add_boundarydata!(PDE::PDEDescription, position::Int64, regions, btype::Type{<:AbstractBoundaryType}; data)\n\n\nAdds the given boundary data with the specified AbstractBoundaryType at the specified position in the BoundaryOperator of the PDEDescription.\n\nNote: If the data function is time-dependent (see User Data documentation) it is evaluated in any advance! step of a TimeControlSolver.\n\n\n\n\n\n","category":"function"},{"location":"boundarydata/#Other-Boundary-Data","page":"Boundary Data","title":"Other Boundary Data","text":"","category":"section"},{"location":"boundarydata/","page":"Boundary Data","title":"Boundary Data","text":"NeumannBoundary can be implemented as a RhsOperator with AT = ON_BFACES and specified boundary regions","category":"page"},{"location":"boundarydata/","page":"Boundary Data","title":"Boundary Data","text":"PeriodicBoundary can be implemented as a CombineDofs <: AbstractGlobalConstraint","category":"page"},{"location":"boundarydata/","page":"Boundary Data","title":"Boundary Data","text":"SymmetryBoundary can be implemented by penalisation as an BilinearForm on AT = ON_BFACES and specified boundary regions with operator NormalFlux and some penalty factor.","category":"page"},{"location":"examples/ExampleA03_CommutingInterpolators3D/#A03-:-Commuting-Interpolators-3D","page":"A03 : Commuting Interpolators 3D","title":"A03 : Commuting Interpolators 3D","text":"","category":"section"},{"location":"examples/ExampleA03_CommutingInterpolators3D/","page":"A03 : Commuting Interpolators 3D","title":"A03 : Commuting Interpolators 3D","text":"(source code)","category":"page"},{"location":"examples/ExampleA03_CommutingInterpolators3D/","page":"A03 : Commuting Interpolators 3D","title":"A03 : Commuting Interpolators 3D","text":"This example verifies a structural property of the Hcurl and Hdiv finite element spaces and their interpolators which is","category":"page"},{"location":"examples/ExampleA03_CommutingInterpolators3D/","page":"A03 : Commuting Interpolators 3D","title":"A03 : Commuting Interpolators 3D","text":"mathrmCurl(I_mathrmN_k-1psi) = I_mathrmRT_k-1(mathrmCurl(psi))","category":"page"},{"location":"examples/ExampleA03_CommutingInterpolators3D/","page":"A03 : Commuting Interpolators 3D","title":"A03 : Commuting Interpolators 3D","text":"for the standard Nedelec interpolator I_mathrmN_k-1 and the standard Raviart-Thomas interpolator I_mathrmRT_k-1 for k  0. In this example we verify this identity for k=1 (higher order spaces are tested as well as soon as they are available).","category":"page"},{"location":"examples/ExampleA03_CommutingInterpolators3D/","page":"A03 : Commuting Interpolators 3D","title":"A03 : Commuting Interpolators 3D","text":"module ExampleA03_CommutingInterpolators3D\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\n\n# define some function\nfunction exact_function!(result,x)\n    result[1] = x[2]^2 + x[3]\n    result[2] = x[1]^3\n    result[3] = 1 + x[3]^2\nend\n# and its Curl3D\nfunction exact_curl!(result,x)\n    result[1] = 0\n    result[2] = 1\n    result[3] = 3*x[1]^2 - 2*x[2]\nend\n\n# everything is wrapped in a main function\nfunction main(;order::Int = 1, testmode = false)\n\n    # choose some grid\n    xgrid = uniform_refine(reference_domain(Tetrahedron3D),2)\n\n    # negotiate exact_function! and exact_curl! to the package\n    u = DataFunction(exact_function!, [3,3]; name = \"u_exact\", dependencies = \"X\", quadorder = 3)\n    u_curl = DataFunction(exact_curl!, [3,3]; name = \"Curl(u_exact)\", dependencies = \"X\", quadorder = 2)\n\n    # choose commuting interpolators pair\n    if order == 1\n        FE = [HCURLN0{3},HDIVRT0{3}]; testFE = H1P0{3}\n    end\n\n    # do the Hcurl interpolation of the function\n    FESH1 = FESpace{FE[1]}(xgrid)\n    HcurlInterpolation = FEVector(\"Hcurl-Interpolation\",FESH1)\n    interpolate!(HcurlInterpolation[1], u)\n\n    # do the Hdiv interpolation of the Curl of the function\n    # since integrals over faces have to be computed exactly we need to tune the quadrature order\n    FESHdiv = FESpace{FE[2]}(xgrid)\n    HdivCurlInterpolation = FEVector(\"Hdiv-Interpolation\",FESHdiv)\n    interpolate!(HdivCurlInterpolation[1], u_curl)\n\n    # Checking the identity:\n    # Both sides of the identity are finite element function of FEtype testFE\n    # Hence, we evaluate the error by testing the identity by all basisfunctions of this type\n\n    # first: generate the test space and some matching FEVector\n    FEStest = FESpace{testFE}(xgrid; broken = true)\n    error = FEVector(\"ErrorVector\",FEStest)\n\n    # Define bilinear forms that represents testing each side of the identity with the testspace functions\n    BLF1 = BilinearForm(Float64, ON_CELLS, [FEStest, FESHdiv], [Identity, Identity])\n    BLF2 = BilinearForm(Float64, ON_CELLS, [FEStest, FESH1], [Identity, Curl3D])\n\n    # evaluate the bilinear forms in the respective interpolations and subtract them from each other\n    # note that in these calls always the second argument of the bilinearform is fixed by the given FEVectorBlock\n    assemble!(error[1], BLF1, HdivCurlInterpolation[1]; fixed_arguments = [2])\n    assemble!(error[1], BLF2, HcurlInterpolation[1]; factor = -1, fixed_arguments = [2])\n\n    # do some norm that recognizes a nonzero in the vector\n    error = sqrt(sum(error[1][:].^2, dims = 1)[1])\n    if testmode == true\n        return error\n    else\n        println(\"error(Curl(I_$(FE[1])(psi) - I_$(FE[2])(Curl(psi))) = $error\")\n    end\nend\n\n# test function that is called by test unit\nfunction test()\n    error = []\n    for order in [1]\n        push!(error, max(main(order = order, testmode = true)))\n    end\n    return maximum(error)\nend\n\nend","category":"page"},{"location":"examples/ExampleA03_CommutingInterpolators3D/","page":"A03 : Commuting Interpolators 3D","title":"A03 : Commuting Interpolators 3D","text":"","category":"page"},{"location":"examples/ExampleA03_CommutingInterpolators3D/","page":"A03 : Commuting Interpolators 3D","title":"A03 : Commuting Interpolators 3D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/ExampleA03_CommutingInterpolators3D/","page":"A03 : Commuting Interpolators 3D","title":"A03 : Commuting Interpolators 3D","text":"Default output:","category":"page"},{"location":"examples/ExampleA03_CommutingInterpolators3D/","page":"A03 : Commuting Interpolators 3D","title":"A03 : Commuting Interpolators 3D","text":"julia> ExampleA03_CommutingInterpolators3D.main()\nerror(Curl(I_HCURLN0{3}(psi) - I_HDIVRT0{3}(Curl(psi))) = 3.821945511051252e-17","category":"page"},{"location":"viewers/#Viewers","page":"Viewers","title":"Viewers","text":"","category":"section"},{"location":"viewers/","page":"Viewers","title":"Viewers","text":"Plotting is possible e.g. via Nodal Evaluations and the plot routines from ExtendableGrids.jl. For an example see one of the many examples with plots in the example section.","category":"page"},{"location":"examples/Example210_NonlinearPoisson2D/#:-Nonlinear-Poisson-Problem-2D","page":"210 : Nonlinear Poisson Problem 2D","title":"210 : Nonlinear Poisson Problem 2D","text":"","category":"section"},{"location":"examples/Example210_NonlinearPoisson2D/","page":"210 : Nonlinear Poisson Problem 2D","title":"210 : Nonlinear Poisson Problem 2D","text":"(source code)","category":"page"},{"location":"examples/Example210_NonlinearPoisson2D/","page":"210 : Nonlinear Poisson Problem 2D","title":"210 : Nonlinear Poisson Problem 2D","text":"This example computes the solution u of the nonlinear Poisson problem","category":"page"},{"location":"examples/Example210_NonlinearPoisson2D/","page":"210 : Nonlinear Poisson Problem 2D","title":"210 : Nonlinear Poisson Problem 2D","text":"beginaligned\n-mathrmdiv(q(u) nabla u)  = f quad textin  Omega\nendaligned","category":"page"},{"location":"examples/Example210_NonlinearPoisson2D/","page":"210 : Nonlinear Poisson Problem 2D","title":"210 : Nonlinear Poisson Problem 2D","text":"with some right-hand side f on a series of uniform refinements of the unit square Omega. The quantity q(u) makes the problem nonlinear and we consider the two possibilites","category":"page"},{"location":"examples/Example210_NonlinearPoisson2D/","page":"210 : Nonlinear Poisson Problem 2D","title":"210 : Nonlinear Poisson Problem 2D","text":"beginaligned\n    q_1(u) = 1 + u^2\n    q_2(u) = (kappa + lvert nabla u rvert)^p-2\nendaligned","category":"page"},{"location":"examples/Example210_NonlinearPoisson2D/","page":"210 : Nonlinear Poisson Problem 2D","title":"210 : Nonlinear Poisson Problem 2D","text":"where the second one is known is the p-Laplacian (plus some small regularisation kappa geq 0 to make it solvable with the Newton solver).","category":"page"},{"location":"examples/Example210_NonlinearPoisson2D/","page":"210 : Nonlinear Poisson Problem 2D","title":"210 : Nonlinear Poisson Problem 2D","text":"This example demonstrates the automatic differentation feature and explains how to setup a nonlinear expression and how to assign it to the problem description. The setup is tested with some manufactured quadratic solution.","category":"page"},{"location":"examples/Example210_NonlinearPoisson2D/","page":"210 : Nonlinear Poisson Problem 2D","title":"210 : Nonlinear Poisson Problem 2D","text":"Also the factorization in the linear solver can be changed to anything <:ExtendableSparse.AbstractFactorization (but not every one will work in this example).","category":"page"},{"location":"examples/Example210_NonlinearPoisson2D/","page":"210 : Nonlinear Poisson Problem 2D","title":"210 : Nonlinear Poisson Problem 2D","text":"module Example210_NonlinearPoisson2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableSparse\nusing ExtendableGrids\nusing GridVisualize\n\n# problem data\nfunction exact_function!(result,x)\n    result[1] = x[1]*x[2]\n    return nothing\nend\nfunction exact_gradient!(result,x)\n    result[1] = x[2]\n    result[2] = x[1]\n    return nothing\nend\nfunction rhs!(q,p,κ)\n    function closure(result,x)\n        if q == 1\n            result[1] = -2*(x[1]^3*x[2] + x[2]^3*x[1]) # = -div((1+u^2)*grad(u))\n        elseif q == 2\n            result[1] = -2*(p-2) * (κ + x[1]^2+x[2]^2)^((p-2)/2-1) * x[1] * x[2] # = -div((κ + |grad(u)|)^p-2*grad(u))\n        end\n        return nothing\n    end\n    return closure\nend\nfunction diffusion_kernel1!(result, input)\n    # input[1,2:3] = [u, grad(u)]\n    result[1] = (1+input[1]^2)*input[2]\n    result[2] = (1+input[1]^2)*input[3]\n    return nothing\nend\nfunction diffusion_kernel2!(p,κ)\n    function closure(result, input)\n        # input[1:2] = [grad(u)]\n        # we use result[1] as temporary storage to compute (κ + |∇u|)^(p-2)\n        result[1] = (κ + input[1]^2 + input[2]^2)^((p-2)/2)\n        result[2] = result[1] * input[2]\n        result[1] = result[1] * input[1]\n        return nothing\n    end\n    return closure\nend\n\n# everything is wrapped in a main function\n# default argument trigger P1-FEM calculation, you might also want to try H1P2{1,2}\nfunction main(; q = 1, p = 2.7, κ = 0.0001, Plotter = nothing, verbosity = 0, nlevels = 6, FEType = H1P1{1}, testmode = false, factorization = ExtendableSparse.LUFactorization)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # choose initial mesh\n    xgrid = grid_unitsquare(Triangle2D)\n\n    # negotiate data functions to the package\n    u = DataFunction(exact_function!, [1,2]; name = \"u_exact\", dependencies = \"X\", quadorder = 2)\n    ∇u = DataFunction(exact_gradient!, [2,2]; name = \"grad(u_exact)\", dependencies = \"X\", quadorder = 1)\n    f = DataFunction(rhs!(q,p,κ), [1,2]; dependencies = \"X\", name = \"f\", quadorder = 4)\n\n    # prepare nonlinear expression (1+u^2)*grad(u)\n    if q == 1\n        nonlin_diffusion = NonlinearForm([Identity, Gradient], [1,1], Gradient, diffusion_kernel1!, [2,3]; name = \"(1+u^2) ∇u ⋅ ∇v\", quadorder = 4, ADnewton = true)\n    elseif q == 2\n        nonlin_diffusion = NonlinearForm([Gradient], [1], Gradient, diffusion_kernel2!(p,κ), [2,2]; name = \"(κ+|∇u|^2) ∇u ⋅ ∇v\", quadorder = 5, ADnewton = true)\n    else\n        @error \"only q ∈ [1,2] !\"\n    end\n\n    # generate problem description and assign nonlinear operator and data\n    Problem = PDEDescription(\"nonlinear Poisson problem\")\n    add_unknown!(Problem; unknown_name = \"u\", equation_name = \"nonlinear Poisson equation\")\n    add_operator!(Problem, [1,1], nonlin_diffusion)\n    add_boundarydata!(Problem, 1, [1,2,3,4], BestapproxDirichletBoundary; data = u)\n    add_rhsdata!(Problem, 1,  RhsOperator(Identity, [0], f; store = true))\n    @show Problem\n\n    # prepare error calculation\n    L2Error = L2ErrorIntegrator(Float64, u, Identity)\n    H1Error = L2ErrorIntegrator(Float64, ∇u, Gradient)\n    NDofs = zeros(Int,nlevels)\n    Results = zeros(Float64,nlevels,2)\n\n    # loop over levels\n    Solution = nothing\n    for level = 1 : nlevels\n        # uniform mesh refinement\n        xgrid = uniform_refine(xgrid)\n\n        # create finite element space and solution vector\n        FES = FESpace{FEType}(xgrid)\n        Solution = FEVector{Float64}(\"u_h\",FES)\n\n        # solve\n        @show Solution\n        solve!(Solution, Problem; linsolver = factorization, show_statistics = true)\n\n        # calculate L2 and H1 error and save data\n        NDofs[level] = length(Solution.entries)\n        Results[level,1] = sqrt(evaluate(L2Error,Solution[1]))\n        Results[level,2] = sqrt(evaluate(H1Error,Solution[1]))\n    end\n\n    if testmode == true\n        return Results[end,2]\n    else\n        # plot\n        p = GridVisualizer(; Plotter = Plotter, layout = (1,2), clear = true, resolution = (1000,500))\n        scalarplot!(p[1,1], xgrid, nodevalues_view(Solution[1])[1], levels = 11, title = \"u_h\")\n        scalarplot!(p[1,2], xgrid, view(nodevalues(Solution[1], Gradient; abs = true),1,:), levels=7)\n        vectorplot!(p[1,2], xgrid, evaluate(PointEvaluator(Solution[1], Gradient)), spacing = 0.1, clear = false, title = \"∇u_h (abs + quiver)\")\n\n        # print/plot convergence history\n        print_convergencehistory(NDofs, Results; X_to_h = X -> X.^(-1/2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\"])\n        plot_convergencehistory(NDofs, Results; add_h_powers = [1,2], X_to_h = X -> X.^(-1/2), Plotter = Plotter, ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\"])\n    end\nend\n\n# test function that is called by test unit\n# tests if the above problem is solved exactly by P2-FEM\nfunction test()\n    return main(; FEType = H1P2{1,2}, q = 1, nlevels = 1, testmode = true)\nend\n\nend","category":"page"},{"location":"examples/Example210_NonlinearPoisson2D/","page":"210 : Nonlinear Poisson Problem 2D","title":"210 : Nonlinear Poisson Problem 2D","text":"","category":"page"},{"location":"examples/Example210_NonlinearPoisson2D/","page":"210 : Nonlinear Poisson Problem 2D","title":"210 : Nonlinear Poisson Problem 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example210_NonlinearPoisson2D/","page":"210 : Nonlinear Poisson Problem 2D","title":"210 : Nonlinear Poisson Problem 2D","text":"Default output:","category":"page"},{"location":"examples/Example210_NonlinearPoisson2D/","page":"210 : Nonlinear Poisson Problem 2D","title":"210 : Nonlinear Poisson Problem 2D","text":"julia> Example210_NonlinearPoisson2D.main()\n\nPDE-DESCRIPTION\n===============\n  system name = nonlinear Poisson problem\n\n     id   | unknown name / equation name\n    [1]   | u / nonlinear Poisson equation \n\n  LHS block | PDEOperator(s)\n    [1,1]   | (1+u^2) ∇u ⋅ ∇v [AD-Newton] [∂u] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n\n  RHS block | PDEOperator(s)\n     [1]    | (1+u^2) ∇u ⋅ ∇v [AD-Newton] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n            | (f, id(v)) (APT = LinearForm, AT = ON_CELLS, regions = [0])\n\n   BoundaryOperator[1] : BestapproxDirichletBoundary -> [1, 2, 3, 4]\n                         \n\nProblem = \nSolution = \nFEVector information\n====================\n   block  |  ndofs  | name (FEType) \n [    1]  |      13 | u_h (H1P1{1})\n\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL  | TIME ASSEMBLY/SOLVE/TOTAL (s)\n\t-----------------------------------------------------------------------\n\t      1   | 1.276908e-16 | 1.879348e-01 | 1.32e-02/1.26e-04/2.23e-02\n\t      2   | 2.415941e-16 | 2.427676e-03 | 7.02e-04/1.13e-04/9.11e-04\n\t      3   | 2.586077e-16 | 3.580510e-07 | 5.50e-04/5.34e-05/6.38e-04\n\t      4   | 6.032275e-16 | 8.010898e-15 | 5.39e-04/4.22e-05/6.10e-04\n\nSolution = \nFEVector information\n====================\n   block  |  ndofs  | name (FEType) \n [    1]  |      41 | u_h (H1P1{1})\n\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL  | TIME ASSEMBLY/SOLVE/TOTAL (s)\n\t-----------------------------------------------------------------------\n\t      1   | 5.090761e-16 | 1.552235e-01 | 2.04e-03/2.19e-04/2.36e-03\n\t      2   | 1.702141e-15 | 1.898915e-03 | 2.02e-03/1.27e-04/2.24e-03\n\t      3   | 6.473127e-16 | 4.461316e-07 | 1.97e-03/1.23e-04/2.17e-03\n\t      4   | 9.026139e-16 | 2.496648e-14 | 2.16e-03/1.05e-04/2.33e-03\n\nSolution = \nFEVector information\n====================\n   block  |  ndofs  | name (FEType) \n [    1]  |     145 | u_h (H1P1{1})\n\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL  | TIME ASSEMBLY/SOLVE/TOTAL (s)\n\t-----------------------------------------------------------------------\n\t      1   | 1.514890e-15 | 9.834582e-02 | 7.49e-03/8.03e-04/8.41e-03\n\t      2   | 1.839081e-15 | 1.307935e-03 | 8.14e-03/7.36e-04/8.98e-03\n\t      3   | 2.040681e-15 | 4.214647e-07 | 8.26e-03/4.61e-04/8.81e-03\n\t      4   | 3.226807e-15 | 3.031147e-14 | 7.69e-03/4.49e-04/8.22e-03\n\nSolution = \nFEVector information\n====================\n   block  |  ndofs  | name (FEType) \n [    1]  |     545 | u_h (H1P1{1})\n\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL  | TIME ASSEMBLY/SOLVE/TOTAL (s)\n\t-----------------------------------------------------------------------\n\t      1   | 2.415097e-15 | 5.522608e-02 | 3.02e-02/2.46e-03/3.28e-02\n\t      2   | 4.721318e-15 | 8.487585e-04 | 2.96e-02/1.90e-03/3.17e-02\n\t      3   | 4.750765e-15 | 2.555420e-07 | 2.91e-02/1.77e-03/3.11e-02\n\t      4   | 4.311053e-15 | 2.230989e-14 | 2.92e-02/1.87e-03/3.12e-02\n\nSolution = \nFEVector information\n====================\n   block  |  ndofs  | name (FEType) \n [    1]  |    2113 | u_h (H1P1{1})\n\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL  | TIME ASSEMBLY/SOLVE/TOTAL (s)\n\t-----------------------------------------------------------------------\n\t      1   | 4.717838e-15 | 2.924738e-02 | 1.19e-01/9.18e-03/1.28e-01\n\t      2   | 9.826149e-15 | 4.905172e-04 | 1.20e-01/7.24e-03/1.28e-01\n\t      3   | 9.593028e-15 | 1.346748e-07 | 1.20e-01/7.15e-03/1.27e-01\n\t      4   | 8.954778e-15 | 1.876322e-14 | 1.22e-01/7.15e-03/1.30e-01\n\nSolution = \nFEVector information\n====================\n   block  |  ndofs  | name (FEType) \n [    1]  |    8321 | u_h (H1P1{1})\n\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL  | TIME ASSEMBLY/SOLVE/TOTAL (s)\n\t-----------------------------------------------------------------------\n\t      1   | 9.887750e-15 | 1.504798e-02 | 4.68e-01/4.46e-02/5.14e-01\n\t      2   | 1.901423e-14 | 2.640269e-04 | 4.78e-01/3.82e-02/5.17e-01\n\t      3   | 1.848103e-14 | 6.824838e-08 | 4.78e-01/5.78e-02/5.36e-01\n\t      4   | 1.866766e-14 | 3.344190e-14 | 4.80e-01/4.17e-02/5.22e-01\n\n\n    ndofs   |    || u - u_h ||     order  |  || ∇(u - u_h) ||    order  |\n============|=============================|=============================|\n        13  |     6.62330e-03      0.000  |     1.44378e-01      0.000  |\n        41  |     1.65803e-03      2.412  |     7.21744e-02      1.207  |\n       145  |     4.14699e-04      2.194  |     3.60851e-02      1.098  |\n       545  |     1.03688e-04      2.094  |     1.80423e-02      1.047  |\n      2113  |     2.59229e-05      2.046  |     9.02111e-03      1.023  |\n      8321  |     6.48078e-06      2.023  |     4.51055e-03      1.011  |","category":"page"},{"location":"examples/Example210_NonlinearPoisson2D/","page":"210 : Nonlinear Poisson Problem 2D","title":"210 : Nonlinear Poisson Problem 2D","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/Example214_TwoNonlinearCoupled2D/#:-Two-nonlinearly-coupled-PDEs-(2D)","page":"214 : Two nonlinearly coupled PDEs (2D)","title":"214 : Two nonlinearly coupled PDEs (2D)","text":"","category":"section"},{"location":"examples/Example214_TwoNonlinearCoupled2D/","page":"214 : Two nonlinearly coupled PDEs (2D)","title":"214 : Two nonlinearly coupled PDEs (2D)","text":"(source code)","category":"page"},{"location":"examples/Example214_TwoNonlinearCoupled2D/","page":"214 : Two nonlinearly coupled PDEs (2D)","title":"214 : Two nonlinearly coupled PDEs (2D)","text":"This example computes the solutions u_1 and u_2 of the two coupled nonlinear PDEs","category":"page"},{"location":"examples/Example214_TwoNonlinearCoupled2D/","page":"214 : Two nonlinearly coupled PDEs (2D)","title":"214 : Two nonlinearly coupled PDEs (2D)","text":"beginaligned\n-nu_1 Delta u_1 + alpha_1 u_1u_2  = f_1 quad textin  Omega\n-nu_2 Delta u_2 + alpha_2 u_1u_2  = f_2 quad textin  Omega\nendaligned","category":"page"},{"location":"examples/Example214_TwoNonlinearCoupled2D/","page":"214 : Two nonlinearly coupled PDEs (2D)","title":"214 : Two nonlinearly coupled PDEs (2D)","text":"with given data nu, alpha and right-hand sides f_1, f_2 on the unit cube domain Omega.","category":"page"},{"location":"examples/Example214_TwoNonlinearCoupled2D/","page":"214 : Two nonlinearly coupled PDEs (2D)","title":"214 : Two nonlinearly coupled PDEs (2D)","text":"This example demonstrates how to define this problem with one NonlinearForm per equation that can be automatically differentiated to solve the problem with Newton's method.","category":"page"},{"location":"examples/Example214_TwoNonlinearCoupled2D/","page":"214 : Two nonlinearly coupled PDEs (2D)","title":"214 : Two nonlinearly coupled PDEs (2D)","text":"module Example214_TwoNonlinearCoupled2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# problem data\nconst f = [x -> 1, x -> 2*x[2]]\nconst ν = [1e-3,1]\nconst α = [1,1]\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, Plotter = nothing)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # build/load any grid (here: a uniform-refined 2D unit square into triangles)\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D),4)\n\n    # create empty PDE description\n    Problem = PDEDescription(\"Problem\")\n\n    # add two unknown with zero boundary data\n    add_unknown!(Problem; unknown_name = \"u1\", equation_name = \"Equation for u1\")\n    add_unknown!(Problem; unknown_name = \"u2\", equation_name = \"Equation for u2\")\n    add_boundarydata!(Problem, 1, [1,2,3,4], HomogeneousDirichletBoundary)\n    add_boundarydata!(Problem, 2, [1,2,3,4], HomogeneousDirichletBoundary)\n\n    # add equations for unknowns as single NonlinearForms\n    function operator_kernel(id)\n        return function closure(result,input,x)\n            # input = [u1,∇u1,u2]\n            result[1] = α[id]*input[1]*input[4] - f[id](x)    # will be multiplied with identity of test function\n            result[2] = ν[id]*input[2] # will be multiplied with 1st component of gradient of testfunction\n            result[3] = ν[id]*input[3] # will be multiplied with 2nd component of gradient of testfunction\n            return nothing\n        end\n    end\n    add_operator!(Problem,[1,1], NonlinearForm([OperatorPair{Identity,Gradient},Identity], [1,2], OperatorPair{Identity,Gradient}, operator_kernel(1), [3,4]; name = \"ν1 (∇u1,∇v) + α1 (u1 u2,v) - (f1,v)\", dependencies = \"X\", ADnewton = true, quadorder = 0)  )\n    add_operator!(Problem,[2,2], NonlinearForm([OperatorPair{Identity,Gradient},Identity], [2,1], OperatorPair{Identity,Gradient}, operator_kernel(2), [3,4]; name = \"ν2 (∇u2,∇v) + α2 (u1 u2,v) - (f2,v)\", dependencies = \"X\", ADnewton = true, quadorder = 0)  )\n\n    # discretise (here: u1 with P3, u2 with P2)\n    FETypes = [H1P3{1,2},H1P2{1,2}]\n    FES = [FESpace{FETypes[1]}(xgrid),FESpace{FETypes[2]}(xgrid)]\n    Solution = FEVector([\"u1\",\"u2\"],FES)\n\n    # show problem and Solution structure\n    @show Problem Solution\n\n    # solve for chosen Solution vector\n    solve!(Solution, Problem)\n\n    # plot solution (for e.g. Plotter = PyPlot)\n    p = GridVisualizer(; Plotter = Plotter, layout = (1,2), clear = true, resolution = (1000,500))\n    scalarplot!(p[1,1], xgrid, nodevalues_view(Solution[1])[1], levels = 11, title = \"u_1\")\n    scalarplot!(p[1,2], xgrid, nodevalues_view(Solution[2])[1], levels = 11, title = \"u_2\")\nend\nend","category":"page"},{"location":"examples/Example214_TwoNonlinearCoupled2D/","page":"214 : Two nonlinearly coupled PDEs (2D)","title":"214 : Two nonlinearly coupled PDEs (2D)","text":"","category":"page"},{"location":"examples/Example214_TwoNonlinearCoupled2D/","page":"214 : Two nonlinearly coupled PDEs (2D)","title":"214 : Two nonlinearly coupled PDEs (2D)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example214_TwoNonlinearCoupled2D/","page":"214 : Two nonlinearly coupled PDEs (2D)","title":"214 : Two nonlinearly coupled PDEs (2D)","text":"Default output:","category":"page"},{"location":"examples/Example214_TwoNonlinearCoupled2D/","page":"214 : Two nonlinearly coupled PDEs (2D)","title":"214 : Two nonlinearly coupled PDEs (2D)","text":"julia> Example214_TwoNonlinearCoupled2D.main()\n\nPDE-DESCRIPTION\n===============\n  system name = Problem\n\n     id   | unknown name / equation name\n    [1]   | u1 / Equation for u1 \n    [2]   | u2 / Equation for u2 \n\n  LHS block | PDEOperator(s)\n    [1,1]   | ν1 (∇u1,∇v) + α1 (u1 u2,v) - (f1,v) [AD-Newton] [∂u1] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n    [1,2]   | ν1 (∇u1,∇v) + α1 (u1 u2,v) - (f1,v) [AD-Newton] [∂u2] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n    [2,1]   | ν2 (∇u2,∇v) + α2 (u1 u2,v) - (f2,v) [AD-Newton] [∂u1] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n    [2,2]   | ν2 (∇u2,∇v) + α2 (u1 u2,v) - (f2,v) [AD-Newton] [∂u2] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n\n  RHS block | PDEOperator(s)\n     [1]    | ν1 (∇u1,∇v) + α1 (u1 u2,v) - (f1,v) [AD-Newton] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n     [2]    | ν2 (∇u2,∇v) + α2 (u1 u2,v) - (f2,v) [AD-Newton] (APT = NonlinearForm, AT = ON_CELLS, regions = [0])\n\n   BoundaryOperator[1] : HomogeneousDirichletBoundary -> [1, 2, 3, 4]\n                          \n   BoundaryOperator[2] : HomogeneousDirichletBoundary -> [1, 2, 3, 4]\n                          \n\nProblem = \nSolution = \nFEVector information\n====================\n   block  |  ndofs  | name (FEType) \n [    1]  |    4705 | u1 (H1P3{1,2})\n [    2]  |    2113 | u2 (H1P2{1,2})\n\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 4.177785e-15 | 9.824796e-02\n\t      2   | 2.583591e-15 | 1.810300e-02\n\t      3   | 2.054850e-15 | 1.549532e-03\n\t      4   | 1.975420e-15 | 1.656753e-05\n\t      5   | 1.989576e-15 | 1.966716e-09\n\t      6   | 1.945037e-15 | 3.449146e-15\n","category":"page"},{"location":"examples/Example214_TwoNonlinearCoupled2D/","page":"214 : Two nonlinearly coupled PDEs (2D)","title":"214 : Two nonlinearly coupled PDEs (2D)","text":"(Image: )","category":"page"},{"location":"examples/Example208_FlowTransport2D/#:-Flow-Transport-2D","page":"208 : Flow + Transport 2D","title":"208 : Flow + Transport 2D","text":"","category":"section"},{"location":"examples/Example208_FlowTransport2D/","page":"208 : Flow + Transport 2D","title":"208 : Flow + Transport 2D","text":"(source code)","category":"page"},{"location":"examples/Example208_FlowTransport2D/","page":"208 : Flow + Transport 2D","title":"208 : Flow + Transport 2D","text":"This example solve the Stokes problem in a Omega-shaped pipe and then uses the velocity in a transport equation for a species with a certain inlet concentration. Altogether, we are looking for a velocity mathbfu, a pressure mathbfp and a species concentration mathbfc such that","category":"page"},{"location":"examples/Example208_FlowTransport2D/","page":"208 : Flow + Transport 2D","title":"208 : Flow + Transport 2D","text":"beginaligned\n- mu Delta mathbfu + nabla p  = 0\nmathrmdiv(u)  = 0\n- kappa Delta mathbfc + mathbfu cdot nabla mathbfc  = 0\nendaligned","category":"page"},{"location":"examples/Example208_FlowTransport2D/","page":"208 : Flow + Transport 2D","title":"208 : Flow + Transport 2D","text":"with some viscosity parameter  and diffusion parameter kappa.","category":"page"},{"location":"examples/Example208_FlowTransport2D/","page":"208 : Flow + Transport 2D","title":"208 : Flow + Transport 2D","text":"The diffusion coefficient for the species is chosen (almost) zero such that the isolines of the concentration should stay parallel from inlet to outlet. For the discretisation of the convection term in the transport equation two three possibilities can be chosen:","category":"page"},{"location":"examples/Example208_FlowTransport2D/","page":"208 : Flow + Transport 2D","title":"208 : Flow + Transport 2D","text":"Classical finite element discretisations mathbfu_h cdot nabla mathbfc_h\nPressure-robust finite element discretisation Pi_textreconst mathbfu_h cdot nabla mathbfc_h with some divergence-free reconstruction operator Pi_textreconst\nUpwind finite volume discretisation for kappa = 0 based on normal fluxes along the faces (also divergence-free in finite volume sense)","category":"page"},{"location":"examples/Example208_FlowTransport2D/","page":"208 : Flow + Transport 2D","title":"208 : Flow + Transport 2D","text":"Observe that a pressure-robust Bernardi–Raugel discretisation preserves this much better than a classical Bernardi–Raugel method. For comparison also a Taylor–Hood method can be switched on which is comparable to the pressure-robust lowest-order method in this example.","category":"page"},{"location":"examples/Example208_FlowTransport2D/","page":"208 : Flow + Transport 2D","title":"208 : Flow + Transport 2D","text":"Note, that the transport equation is very convection-dominated and no stabilisation in the finite element discretisations was used here (but instead a nonzero kappa). The results are very sensitive to kappa and may be different if a stabilisation is used (work in progress). Also note, that only the finite volume discretisation perfectly obeys the maximum principle for the concentration but the isolines do no stay parallel until the outlet is reached, possibly due to articifial diffusion.","category":"page"},{"location":"examples/Example208_FlowTransport2D/","page":"208 : Flow + Transport 2D","title":"208 : Flow + Transport 2D","text":"module Example208_FlowTransport2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# boundary data\nfunction inlet_velocity!(result,x)\n    result[1] = 4*x[2]*(1-x[2]);\n    result[2] = 0;\nend\nfunction inlet_concentration!(result,x)\n    result[1] = 1-x[2];\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, nrefinements = 5, Plotter = nothing, FVtransport = true, viscosity = 1)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # load mesh and refine\n    xgrid = simplexgrid(\"assets/2d_grid_upipe.sg\")\n    xgrid = uniform_refine(xgrid,nrefinements)\n\n    # choose one of these (inf-sup stable) finite element type pairs for the flow\n    #FETypes = [H1P2{2,2}, H1P1{1}]; postprocess_operator = Identity # Taylor--Hood\n    #FETypes = [H1BR{2}, H1P0{1}]; postprocess_operator = Identity # Bernardi--Raugel\n    FETypes = [H1BR{2}, H1P0{1}]; postprocess_operator = ReconstructionIdentity{HDIVRT0{2}} # Bernardi--Raugel pressure-robust (RT0 reconstruction)\n    #FETypes = [H1BR{2}, H1P0{1}]; postprocess_operator = ReconstructionIdentity{HDIVBDM1{2}} # Bernardi--Raugel pressure-robust (BDM1 reconstruction)\n\n    #####################################################################################\n\n    # negotiate data functions to the package\n    u_inlet = DataFunction(inlet_velocity!, [2,2]; name = \"u (inlet)\", dependencies = \"X\", quadorder = 2)\n    c_inlet = DataFunction(inlet_concentration!, [1,2]; name = \"c (inlet)\", dependencies = \"X\", quadorder = 1)\n\n    # load Stokes problem prototype and assign boundary data\n    # (inlet profile in bregion 2, zero Dirichlet at walls 1 and nothing at outlet region 2)\n    Problem = IncompressibleNavierStokesProblem(2; viscosity = viscosity, nonlinear = false, no_pressure_constraint = true)\n    Problem.name = \"Stokes + Transport\"\n    add_boundarydata!(Problem, 1, [1,3], HomogeneousDirichletBoundary)\n    add_boundarydata!(Problem, 1, [4], BestapproxDirichletBoundary; data = u_inlet)\n\n    # add transport equation of species\n    add_unknown!(Problem; unknown_name = \"c\", equation_name = \"transport equation\")\n    if FVtransport == true\n        # finite volume upwind discretisation\n        FETypeTransport = H1P0{1}\n        add_operator!(Problem, [3,3], FVConvectionDiffusionOperator(1))\n    else\n        # finite element convection and diffusion (very small) operators\n        FETypeTransport = H1P1{1}\n        diffusion_FE = 1e-7 # diffusion coefficient for transport equation\n        add_operator!(Problem, [3,3], LaplaceOperator(diffusion_FE))\n        add_operator!(Problem, [3,3], ConvectionOperator(1, postprocess_operator, 2, 1))\n    end\n    # with boundary data (i.e. inlet concentration)\n    add_boundarydata!(Problem, 3, [4], InterpolateDirichletBoundary; data = c_inlet)\n    @show Problem\n\n    # generate FESpaces and a solution vector for all 3 unknowns\n    FES = [FESpace{FETypes[1]}(xgrid), FESpace{FETypes[2]}(xgrid; broken = true), FESpace{FETypeTransport}(xgrid)]\n    Solution = FEVector([\"v_h\", \"p_h\", \"c_h\"],FES)\n\n    # first solve the decoupled flow problem equations [1,2]\n    solve!(Solution, Problem; subiterations = [[1,2]], maxiterations = 5, target_residual = 1e-12)\n\n    # then solve the transport equation [3] by finite volumes or finite elements\n    if FVtransport == true\n        # pseudo-timestepping until stationarity detected, the matrix stays the same in each iteration\n        TCS = TimeControlSolver(Problem, Solution, BackwardEuler; subiterations = [[3]], skip_update = [-1], timedependent_equations = [3], T_time = Int)\n        advance_until_stationarity!(TCS, 10000; maxTimeSteps = 100, stationarity_threshold = 1e-12)\n    else\n        # solve directly\n        solve!(Solution, Problem; subiterations = [[3]], maxiterations = 5, target_residual = 1e-12)\n    end\n\n    # print minimal and maximal concentration to check max principle (shoule be in [0,1])\n    println(\"\\n[min(c),max(c)] = [$(minimum(Solution[3][:])),$(maximum(Solution[3][:]))]\")\n\n    # plot\n    p = GridVisualizer(; Plotter = Plotter, layout = (2,1), clear = true, resolution = (800,800))\n    scalarplot!(p[1,1],xgrid,view(nodevalues(Solution[1]; abs = true),1,:), levels = 0, colorbarticks = 7)\n    vectorplot!(p[1,1],xgrid,evaluate(PointEvaluator(Solution[1], Identity)), spacing = 0.25, clear = false, title = \"u_h (abs + quiver)\")\n    scalarplot!(p[2,1],xgrid,view(nodevalues(Solution[3]),1,:), levels = 11, title = \"c_h\")\nend\n\nend","category":"page"},{"location":"examples/Example208_FlowTransport2D/","page":"208 : Flow + Transport 2D","title":"208 : Flow + Transport 2D","text":"","category":"page"},{"location":"examples/Example208_FlowTransport2D/","page":"208 : Flow + Transport 2D","title":"208 : Flow + Transport 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example208_FlowTransport2D/","page":"208 : Flow + Transport 2D","title":"208 : Flow + Transport 2D","text":"Default output:","category":"page"},{"location":"examples/Example208_FlowTransport2D/","page":"208 : Flow + Transport 2D","title":"208 : Flow + Transport 2D","text":"julia> Example208_FlowTransport2D.main()\n\nPDE-DESCRIPTION\n===============\n  system name = Stokes + Transport\n\n     id   | unknown name / equation name\n    [1]   | u / momentum equation \n    [2]   | p / incompressibility constraint \n    [3]   | c / transport equation \n\n  LHS block | PDEOperator(s)\n    [1,1]   | (∇u,∇v) (APT = SymmetricBilinearForm, AT = ON_CELLS, regions = [0])\n    [1,2]   | (div(v),q) (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n    [1,3]   | none\n    [2,1]   | none\n    [2,2]   | none\n    [2,3]   | none\n    [3,1]   | none\n    [3,2]   | none\n    [3,3]   | FVConvectionDiffusionOperator{Float64}\n\n  RHS block | PDEOperator(s)\n     [1]    | none\n     [2]    | none\n     [3]    | none\n\n   BoundaryOperator[1] : BestapproxDirichletBoundary -> [4]\n                         HomogeneousDirichletBoundary -> [1, 3]\n                          \n   BoundaryOperator[2] : \n   BoundaryOperator[3] : InterpolateDirichletBoundary -> [4]\n                         \n\nProblem = \n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t      1   | 8.221827e-14 | 8.221827e-14\n\n\n\t  STEP  |    TIME    | LSRESIDUAL |  RUNTIME  |   CHANGE                      \n\t        |            |  (total)   |    (s)    |      u           p           c     \n\t     1  | 1.0000e+04 | 1.9905e-16 | 1.919e+00 | 0.0000e+00  0.0000e+00  7.9759e+01 \n\t     2  | 2.0000e+04 | 2.1233e-16 | 5.020e-02 | 0.0000e+00  0.0000e+00  4.3757e-01 \n\t     3  | 3.0000e+04 | 2.2769e-16 | 4.683e-03 | 0.0000e+00  0.0000e+00  1.9895e-02 \n\t     4  | 4.0000e+04 | 2.2750e-16 | 4.779e-03 | 0.0000e+00  0.0000e+00  1.0653e-03 \n\t     5  | 5.0000e+04 | 2.0732e-16 | 6.543e-03 | 0.0000e+00  0.0000e+00  5.5956e-05 \n\t     6  | 6.0000e+04 | 2.0620e-16 | 6.744e-03 | 0.0000e+00  0.0000e+00  2.9128e-06 \n\t     7  | 7.0000e+04 | 2.2480e-16 | 4.700e-03 | 0.0000e+00  0.0000e+00  1.5116e-07 \n\t     8  | 8.0000e+04 | 2.2683e-16 | 4.946e-03 | 0.0000e+00  0.0000e+00  7.8373e-09 \n\t     9  | 9.0000e+04 | 2.0696e-16 | 6.722e-03 | 0.0000e+00  0.0000e+00  4.0622e-10 \n\t    10  | 1.0000e+05 | 2.2618e-16 | 4.795e-03 | 0.0000e+00  0.0000e+00  2.1056e-11 \n\t    11  | 1.1000e+05 | 2.2578e-16 | 4.834e-03 | 0.0000e+00  0.0000e+00  1.0900e-12 \n\t    12  | 1.2000e+05 | 2.2576e-16 | 4.525e-03 | 0.0000e+00  0.0000e+00  5.7531e-14 \n\n[min(c),max(c)] = [0.020833333333327937,0.9895833333333334]","category":"page"},{"location":"examples/Example208_FlowTransport2D/","page":"208 : Flow + Transport 2D","title":"208 : Flow + Transport 2D","text":"(Image: )","category":"page"},{"location":"examples/Example101_Bestapproximation1D/#:-L2-Bestapproximation-1D","page":"101 : L2-Bestapproximation 1D","title":"101 : L2-Bestapproximation 1D","text":"","category":"section"},{"location":"examples/Example101_Bestapproximation1D/","page":"101 : L2-Bestapproximation 1D","title":"101 : L2-Bestapproximation 1D","text":"(source code)","category":"page"},{"location":"examples/Example101_Bestapproximation1D/","page":"101 : L2-Bestapproximation 1D","title":"101 : L2-Bestapproximation 1D","text":"This example computes the L2-bestapproximation of some given scalar-valued function into the piecewise quadratic continuous polynomials. Afterwards the L2 error is computed and the solution is plotted.","category":"page"},{"location":"examples/Example101_Bestapproximation1D/","page":"101 : L2-Bestapproximation 1D","title":"101 : L2-Bestapproximation 1D","text":"module Example101_Bestapproximation1D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# define some (vector-valued) function (to be L2-bestapproximated in this example)\nfunction exact_function!(result,x)\n    result[1] = (x[1]-1//2)*(x[1]-9//10)*(x[1]-1//3)*(x[1]-1//10)*(x[1]-0.6)\nend\nconst u = DataFunction(exact_function!, [1,1]; name = \"u\", dependencies = \"X\", quadorder = 5)\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, verbosity = 0, order = 3, h = 0.5, h_fine = 1e-3)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # generate coarse and fine mesh\n    xgrid = simplexgrid(0:h:1)\n    xgrid_fine = simplexgrid(0:h_fine:1)\n\n    # setup a bestapproximation problem via a predefined prototype\n    # and an L2ErrorEvaluator that can be used later to compute the L2 error\n    Problem = L2BestapproximationProblem(u; bestapprox_boundary_regions = [1,2])\n    L2ErrorEvaluator = L2ErrorIntegrator(Float64, u, Identity)\n\n    # choose finite element type of desired order and generate a FESpace for the grid\n    FEType = H1Pk{1,1,order}\n    FES = FESpace{FEType}(xgrid)\n\n    # generate a solution vector and solve the problem on the coarse grid\n    Solution = FEVector(\"u_h\",FES)\n    solve!(Solution, Problem)\n\n    # we want to compare our discrete solution with a finer P1 interpolation of u\n    FES_fine = FESpace{H1P1{1}}(xgrid_fine)\n    Interpolation = FEVector(\"Iu (fine)\",FES_fine)\n    interpolate!(Interpolation[1], u)\n\n    # calculate the L2 errors\n    L2error = sqrt(evaluate(L2ErrorEvaluator,Solution[1]))\n    L2error_fine = (sqrt(evaluate(L2ErrorEvaluator,Interpolation[1])))\n    println(\"\\t|| u - u_h (P$order, coarse)|| = $L2error\")\n    println(\"\\t|| u - u_h (P1, fine) ||= $L2error_fine\")\n\n    # since plots only use values at vertices, we upscale our (possibly higher order Solution)\n    # by interpolating it also into a P1 function on the fine mesh\n    SolutionUpscaled = FEVector(\"u_h (fine)\",FES_fine)\n    interpolate!(SolutionUpscaled[1], Solution[1])\n\n    # evaluate/interpolate function at nodes and plot_trisurf\n    p=GridVisualizer(Plotter=Plotter,layout=(1,1))\n    scalarplot!(p[1,1],xgrid_fine, nodevalues_view(SolutionUpscaled[1])[1], color=(0,0.7,0), label = \"u_h (P$order, coarse bestapprox)\")\n    scalarplot!(p[1,1],xgrid_fine, nodevalues_view(Interpolation[1])[1], clear = false, color = (1,0,0), label = \"u_h (P1, fine interpolation)\", legend = :best)\nend\n\nend","category":"page"},{"location":"examples/Example101_Bestapproximation1D/","page":"101 : L2-Bestapproximation 1D","title":"101 : L2-Bestapproximation 1D","text":"","category":"page"},{"location":"examples/Example101_Bestapproximation1D/","page":"101 : L2-Bestapproximation 1D","title":"101 : L2-Bestapproximation 1D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example101_Bestapproximation1D/","page":"101 : L2-Bestapproximation 1D","title":"101 : L2-Bestapproximation 1D","text":"Default output:","category":"page"},{"location":"examples/Example101_Bestapproximation1D/","page":"101 : L2-Bestapproximation 1D","title":"101 : L2-Bestapproximation 1D","text":"julia> Example101_Bestapproximation1D.main()\n\t|| u - u_h (P3, coarse)|| = 0.000591231934028954\n\t|| u - u_h (P1, fine) ||= 6.205492265952196e-8","category":"page"},{"location":"examples/Example101_Bestapproximation1D/","page":"101 : L2-Bestapproximation 1D","title":"101 : L2-Bestapproximation 1D","text":"(Image: )","category":"page"},{"location":"functionoperators/#Function-Operators","page":"Function Operators","title":"Function Operators","text":"","category":"section"},{"location":"functionoperators/#Available-Operators","page":"Function Operators","title":"Available Operators","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"FunctionOperators are building blocks for the weak form and define the operations that should be applied to the trial and test functions (and their discrete representatives) inside some PDEOperator. Below is a list of currently available FunctionOperators. Note, that not all operators can be applied to all finite element types in principle, but potentially have to be understood in a broken sense and only make sense on certain parts of the mesh (e.g. NormalFlux only on a face). Also note that all evaluations are returned as a vector,  so e.g.\\ a gradient of a 2d vector-field will be a vector of length 4 (ordered component-wise).","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"Function operator Description Mathematically\nIdentity identity v rightarrow v\nIdentityComponent{c} identity of c-th component v rightarrow v_c\nNormalFlux normal flux (function times normal) v rightarrow v cdot vecn (only ON_FACES)\nTangentFlux tangent flux (function times tangent) v rightarrow v cdot vect (only ON_EDGES)\nGradient gradient/Jacobian (as a vector) v rightarrow nabla v\nSymmetricGradient symmetric part of the gradient v rightarrow Voigt(mathrmsym(nabla v))\nDivergence divergence v rightarrow mathrmdiv(v) = nabla cdot v\nCurlScalar curl operator 1D to 2D (rotated gradient) v rightarrow -dvdx_2dvdx_1\nCurl2D curl operator 2D to 1D v rightarrow dv_1dx_2 - dv_2dx_1\nCurl3D curl operator 3D to 3D v rightarrow nabla times v\nHessian Hesse matrix = all 2nd order derivatives (as a vector) v rightarrow D^2 v      (e.g. in 2D: xx,xy,yx,yy for each component)\nSymmetricHessian{a} symmetric part of Hesse matrix, offdiagonals scaled by a v rightarrow sym(D^2 v) (e.g. in 2D: xx,yy,a*xy for each component)\nLaplacian Laplace Operator (diagonal of Hessian) v rightarrow Delta v   (e.g. in 2D: xx,yy for each component)","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"note: Note\nAs each finite element type is transformed differently from the reference domain to the general domain, the evaluation of each function operator has to be implemented for each finite element class. Currently, not every function operator works in any dimension and for any finite element. More evaluations are added as soon as they are needed (and possibly upon request). Also, the function operators can be combined with user-defined actions to evaluate other operators that can be build from the ones available (e.g. the deviator).","category":"page"},{"location":"functionoperators/#Jumps-and-Averages","page":"Function Operators","title":"Jumps and Averages","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"If one of the operators above is evaluted ON_FACES for a finite element that is not continuous there, the code usually will crash or produce weird results. However, some operators can be transformed into a Jump- or Average operator and then either the jumps or the average of this operator along the face is assembled. The operator Jump(Identity) for example gives the jump of the identity evaluation on both sides of the face.","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"Jump\nAverage","category":"page"},{"location":"functionoperators/#GradientRobustMultiPhysics.Jump","page":"Function Operators","title":"GradientRobustMultiPhysics.Jump","text":"function Jump(::Type{<:AbstractFunctionOperator})\n\nTransforms operator inito its jump evaluation.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#GradientRobustMultiPhysics.Average","page":"Function Operators","title":"GradientRobustMultiPhysics.Average","text":"function Average::Type{<:AbstractFunctionOperator})\n\nTransforms operator inito its average evaluation.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"note: Note\nCurrently this feature is only available for assembly on faces (2D and 3D) and certain function operators like Identity, Gradient, ReconstructionIdentity, ReconstructionGradient, NormalFlux, TangentFlux, but more are added as soon as they are needed (and possibly upon request).Also note that if a Jump or Average operator has different behaviour depending on the Assembly Pattern it is used in. Usually, the input of the action used in the assembly pattern has the evaluation on one of the two neighbours at a time, but this should be okay in a linear context. Only in ItemIntegrators the whole jump comes in. In NonlinearForms jumps and averages should better not be used currently.","category":"page"},{"location":"functionoperators/#Reconstruction-Operators","page":"Function Operators","title":"Reconstruction Operators","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"There are special operators (see Table below) that allow to evaluate a usual operator of some discrete reconstructed version of a vector-valued testfunction. These operators keep the discrete divergence exactly and so allow for gradient-robust discretisations with classical non divergence-conforming ansatz spaces. So far such operators are available for the vector-valued Crouzeix-Raviart and Bernardi–Raugel finite element types.","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"Function operator Description\nReconstructionIdentity{FEType} reconstruction operator into specified FEType\nReconstructionDivergence{FEType} divergence of FEType reconstruction operator\nReconstructionGradient{FEType} gradient of FEType reconstruction operator","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"note: Note\nCurrently this feature works with FEType = HdivRT0{d} and FEType = HdivBDM1{d} where d is the space dimension. However, solve! on a PDEDescription that includes these operators will only work if the function operators are at spots were it is applied to functions of type H1BR, H1CR or H1P2B. More reconstruction operators will be implemented at some later point.","category":"page"},{"location":"functionoperators/#Operator-Pairs-(experimental)","page":"Function Operators","title":"Operator Pairs (experimental)","text":"","category":"section"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"Two function operators can be put into an OperatorPair so that one can provide effectively two operators in each argument of an assembly pattern. However, the user should make sure that both operators can be evaluated together reasonably (meaning both should be well-defined on the element geometries and the finite element space where the argument will be evaluated, and the action of the operator has to operate with coressponding input and result fields). This feature is still experimental and might have issues in some cases. OperatorTriple for a combination of three operators is also available.","category":"page"},{"location":"functionoperators/","page":"Function Operators","title":"Function Operators","text":"OperatorPair\nOperatorTriple","category":"page"},{"location":"functionoperators/#GradientRobustMultiPhysics.OperatorPair","page":"Function Operators","title":"GradientRobustMultiPhysics.OperatorPair","text":"abstract type OperatorPair{<:AbstractFunctionOperator,<:AbstractFunctionOperator} <: AbstractFunctionOperator\n\nallows to evaluate two operators in place of one, e.g. OperatorPair{Identity,Gradient}.\n\n\n\n\n\n","category":"type"},{"location":"functionoperators/#GradientRobustMultiPhysics.OperatorTriple","page":"Function Operators","title":"GradientRobustMultiPhysics.OperatorTriple","text":"abstract type OperatorTriple{<:AbstractFunctionOperator,<:AbstractFunctionOperator} <: AbstractFunctionOperator\n\nallows to evaluate three operators in place of one, e.g. OperatorTriple{Identity,Gradient,Hessian}.\n\n\n\n\n\n","category":"type"},{"location":"globalconstraints/#Global-Constraints","page":"Global Constraints","title":"Global Constraints","text":"","category":"section"},{"location":"globalconstraints/","page":"Global Constraints","title":"Global Constraints","text":"GlobalConstraints are additional constraints that the user does not wish to implement as a global Lagrange multiplier because it e.g. causes a dense row in the system matrix and therefore may destroy the performance of the sparse matrix routines. Such a constraint may be a fixed integral mean. Another application are periodic boundary conditions or glued-together quantities in different regions of the grid. Here a CombineDofs constraint may help.","category":"page"},{"location":"globalconstraints/","page":"Global Constraints","title":"Global Constraints","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"globalconstraints.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"globalconstraints/#GradientRobustMultiPhysics.CombineDofs","page":"Global Constraints","title":"GradientRobustMultiPhysics.CombineDofs","text":"struct CombineDofs <: AbstractGlobalConstraint\n\ncombines specified degrees of freedom of two unknown (can be the same), which allows to glue together different unknowns in different regions or periodic boundary conditions\n\n\n\n\n\n","category":"type"},{"location":"globalconstraints/#GradientRobustMultiPhysics.CombineDofs-Tuple{Int64, Int64, Vector{Int64}, Vector{Int64}}","page":"Global Constraints","title":"GradientRobustMultiPhysics.CombineDofs","text":"function CombineDofs(idX::Int,idY::Int,dofsX::Array{Int,1},dofsY::Array{Int,1})\n\nconstructs a CombineDofs constraint that (if assigned to a PDEDescription) ensures that the dofsX of the unknown with id idX matches the dofsY of the unknown with id idY.\n\n\n\n\n\n","category":"method"},{"location":"globalconstraints/#GradientRobustMultiPhysics.FixedIntegralMean","page":"Global Constraints","title":"GradientRobustMultiPhysics.FixedIntegralMean","text":"struct FixedIntegralMean <: AbstractGlobalConstraint\n\nfixes integral mean of the unknown to the specified value\n\n\n\n\n\n","category":"type"},{"location":"globalconstraints/#GradientRobustMultiPhysics.FixedIntegralMean-Tuple{Int64, Real}","page":"Global Constraints","title":"GradientRobustMultiPhysics.FixedIntegralMean","text":"function FixedIntegralMean(unknown_id::Int, value::Real; name::String = \"\")\n\nconstructs a FixedIntegralMean constraint that (if assigned to a PDEDescription) ensures that the unknown with the specified id has an integral mean value.\n\n\n\n\n\n","category":"method"},{"location":"globalconstraints/","page":"Global Constraints","title":"Global Constraints","text":"add_constraint!","category":"page"},{"location":"globalconstraints/#GradientRobustMultiPhysics.add_constraint!","page":"Global Constraints","title":"GradientRobustMultiPhysics.add_constraint!","text":"add_constraint!(PDE::PDEDescription, GC::AbstractGlobalConstraint)\n\n\nAdds the given global constraint to the PDEDescription.\n\n\n\n\n\n","category":"function"},{"location":"assemblypatterns/#Assembly-Patterns","page":"Assembly Patterns","title":"Assembly Patterns","text":"","category":"section"},{"location":"assemblypatterns/","page":"Assembly Patterns","title":"Assembly Patterns","text":"The definition and assembly of an operator is essentially based on Assembly Patterns and a Assembly Type to choose the geometry information needed for providing quadrature and dof handling. The assembly pattern then basically evaluates the function operators and action for the ansatz and test functions and does the quadrature-weighted accumulation into matrices or vectors that represent the operators.","category":"page"},{"location":"assemblypatterns/","page":"Assembly Patterns","title":"Assembly Patterns","text":"Each pattern comes with a number of arguments/quantities with associated Function Operators as well as one of the Assembly Type that states whether the form is evaluated over CELLS, FACES order BFACES (see above). Important note: this assembly type is relative to the grid of the first argument of the pattern. If this argument already lives ONFACES and the pattern is also ONFACES, it will ultimatively assemble on the faces of the faces (that are the edges of the grid with these faces). Moreover, patterns can have an Action that allow to make the evaluations parameter-, region- and/or function-dependent. Each pattern then has usually on to three implementation that writes into FEMatrix or FEVector (where e.g. a subset of arguments is fixed) or evaluates the pattern in the given FEVectorBlocks.","category":"page"},{"location":"assemblypatterns/","page":"Assembly Patterns","title":"Assembly Patterns","text":"The patterns are used to assembly the PDE operators defined in a PDE Description.","category":"page"},{"location":"assemblypatterns/","page":"Assembly Patterns","title":"Assembly Patterns","text":"GradientRobustMultiPhysics.AssemblyPattern{APT <: AssemblyPatternType, T <: Real, AT <: AssemblyType}","category":"page"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.AssemblyPattern","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.AssemblyPattern","text":"mutable struct AssemblyPattern{APT<:AssemblyPatternType, T<:Real, AT<:AssemblyType, Tv<:Real, Ti<:Integer, ActionType<:AbstractAction}\n\neach assembly pattern has one of the assembly pattern types (APT) that trigger different assemblies for the involved finite element spaces, operators and an assigned action. The assembly type (AT) determines if the assembly takes place on cells, faces or edges etc. (relatively to the assembly type of the first argument of the pattern)\n\n\n\n\n\n","category":"type"},{"location":"assemblypatterns/","page":"Assembly Patterns","title":"Assembly Patterns","text":"The following table lists all available assembly patterns, their constuctor names and how they can be used for assembly or evaluations.","category":"page"},{"location":"assemblypatterns/","page":"Assembly Patterns","title":"Assembly Patterns","text":"AssemblyPatternType constructor evaluate assembly into matrix assembly into vector\nAPT_ItemIntegrator ItemIntegrator yes no no\nAPT_LinearForm LinearForm no no yes\nAPT_BilinearForm BilinearForm no yes yes (1)\nAPT_TrilinearForm TrilinearForm no yes (1) yes (2)\nAPT_MultiLinearForm MultilinearForm no no yes (N-1)\nAPT_NonlinearForm NonlinearForm no yes (L) yes (L)","category":"page"},{"location":"assemblypatterns/","page":"Assembly Patterns","title":"Assembly Patterns","text":"Number in brackets denotes the number of fixed arguments needed for this assembly, (L) means that a current solution is needed to evaluate (to evaluate the linearisation of the nonlinear form in this state). Evaluations of the other AssemblyPatterns may be possible in a future update, but currently have to be performed by maintaining a duplicate of the pattern rewritten as an ItemIntegrator.","category":"page"},{"location":"assemblypatterns/#Constructor-details","page":"Assembly Patterns","title":"Constructor details","text":"","category":"section"},{"location":"assemblypatterns/","page":"Assembly Patterns","title":"Assembly Patterns","text":"Below all assembly pattern types, constructor functions and evaluate/assembly functions are detailed. (For more on the ItemIntegrator also see Item Integrators.)","category":"page"},{"location":"assemblypatterns/","page":"Assembly Patterns","title":"Assembly Patterns","text":"Modules = [GradientRobustMultiPhysics]\nPages = [\"itemintegrator.jl\",\"bilinearform.jl\",\"trilinearform.jl\",\"multilinearform.jl\",\"nonlinearform.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.APT_ItemIntegrator","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.APT_ItemIntegrator","text":"abstract type APT_ItemIntegrator <: AssemblyPatternType\n\nitemintegrator assembly pattern type\n\n\n\n\n\n","category":"type"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.ItemIntegrator","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.ItemIntegrator","text":"function ItemIntegrator(\n    T::Type{<:Real},\n    AT::Type{<:AssemblyType},\n    operators::Array{DataType,1}, \n    action::AbstractAction; \n    name = \"ItemIntegrator\",\n    regions::Array{Int,1} = [0])\n\nCreates an ItemIntegrator assembly pattern with the given operators and action etc.\n\n\n\n\n\n","category":"function"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.L2DifferenceIntegrator-Tuple{Type{<:Real}, Int64, Any}","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.L2DifferenceIntegrator","text":"function L2DifferenceIntegrator(\n    T::Type{<:Real},\n    ncomponents::Int,\n    operator::Union{Type{<:AbstractFunctionOperator},Array{DataType,1}};\n    AT::Type{<:AssemblyType} = ON_CELLS,\n    name = \"L2 difference\",\n    quadorder = 2,\n    regions = [0])\n\nCreates an ItemIntegrator that computes the L2 norm difference between two arguments evalauted with the same operator (or with different operators if operator is an array) where ncomponents is the expected length of each operator evaluation. Note that all arguments in an evaluation call need to be defined on the same grid !\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.L2ErrorIntegrator","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.L2ErrorIntegrator","text":"function L2ErrorIntegrator(\n    T::Type{<:Real},\n    compare_data::UserData{AbstractDataFunction}, # can be omitted if zero\n    operator::Type{<:AbstractFunctionOperator};\n    quadorder = \"auto\",\n    name = \"auto\",\n    factor = 1,\n    AT::Type{<:AssemblyType} = ON_CELLS,\n    time = 0)\n\nCreates an ItemIntegrator that compares discrete FEVectorBlock operator-evaluations against the given comparedata and returns the L2-error || comparedata(x) - factor*discrete(x) ||. If quadorder is left on \"auto\" two times the quadorder of the data is used in the evaluation.\n\n\n\n\n\n","category":"function"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.L2NormIntegrator-Tuple{Type{<:Real}, Int64, Any}","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.L2NormIntegrator","text":"L2NormIntegrator(\n    T::Type{<:Real},\n    ncomponents::Int,\n    operator::Type{<:AbstractFunctionOperator};\n    AT::Type{<:AssemblyType} = ON_CELLS,\n    name = \"L2 norm\",\n    quadorder = 2,\n    regions = [0])\n\nCreates an ItemIntegrator that computes the L2 norm of an operator evaluation where ncomponents is the expected length of the operator evaluation.\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.evaluate!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractMatrix{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT}, Union{FEVector{T, Tv, Ti}, Vector{<:FEVectorBlock{T, Tv, Ti}}, FEVectorBlock{T, Tv, Ti}}}} where {APT<:ItemIntegrator, T<:Real, AT<:AssemblyType, Tv, Ti}","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.evaluate!","text":"function evaluate!(\n    b::AbstractArray{T,2},\n    AP::AssemblyPattern{APT,T,AT},\n    FEB::Union{<:FEVector{T,Tv,Ti},<:FEVectorBlock{T,Tv,Ti},Array{<:FEVectorBlock{T,Tv,Ti},1}};\n    skip_preps::Bool = false) where {APT <: APT_ItemIntegrator, T<: Real, AT <: AssemblyType, Tv, Ti}\n\nEvaluation of an ItemIntegrator assembly pattern with given FEVectorBlock or FEVector FEB into given two-dimensional Array b.\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.evaluate-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT}, Union{FEVector{T, Tv, Ti}, Vector{<:FEVectorBlock{T, Tv, Ti}}, FEVectorBlock{T, Tv, Ti}}}} where {APT<:ItemIntegrator, T<:Real, AT<:AssemblyType, Tv, Ti}","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.evaluate","text":"function evaluate(\n    AP::AssemblyPattern{APT,T,AT},\n    FEB::Union{<:FEVector{T,Tv,Ti},<:FEVectorBlock{T,Tv,Ti},Array{<:FEVectorBlock{T,Tv,Ti},1}};\n    skip_preps::Bool = false) where {APT <: APT_ItemIntegrator, T<: Real, AT <: AssemblyType, Tv, Ti}\n\n\nEvaluation of an ItemIntegrator assembly pattern with given FEVectorBlock or FEVector FEB, only returns accumulation over all items.\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.APT_BilinearForm","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.APT_BilinearForm","text":"abstract type APT_BilinearForm <: AssemblyPatternType\n\nbilinearform assembly pattern type\n\n\n\n\n\n","category":"type"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.APT_LumpedBilinearForm","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.APT_LumpedBilinearForm","text":"abstract type APT_LumpedBilinearForm <: BilinearForm\n\nlumped bilinearform assembly pattern type where only the diagonal elements on each item are assembled\n\n\n\n\n\n","category":"type"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.APT_SymmetricBilinearForm","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.APT_SymmetricBilinearForm","text":"abstract type APT_SymmetricBilinearForm <: BilinearForm\n\nsymmetric bilinearform assembly pattern type\n\n\n\n\n\n","category":"type"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.BilinearForm","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.BilinearForm","text":"function BilinearForm(\n    T::Type{<:Real},\n    AT::Type{<:AssemblyType},\n    FE::Array{FESpace,1},\n    operators::Array{DataType,1}, \n    action::AbstractAction; \n    regions::Array{Int,1} = [0])\n\nCreates a general BilinearForm assembly pattern with the given FESpaces, operators and action etc.\n\n\n\n\n\n","category":"function"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.LumpedBilinearForm","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.LumpedBilinearForm","text":"function LumpedBilinearForm(\n    T::Type{<:Real},\n    AT::Type{<:AssemblyType},\n    FE::Array{FESpace,1},\n    operators::Array{DataType,1}, \n    action::AbstractAction; \n    regions::Array{Int,1} = [0])\n\nCreates a LumpedBilinearForm assembly pattern with the given FESpaces, operators and action etc.\n\n\n\n\n\n","category":"function"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.SymmetricBilinearForm","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.SymmetricBilinearForm","text":"function SymmetricBilinearForm(\n    T::Type{<:Real},\n    AT::Type{<:AssemblyType},\n    FE::Array{FESpace,1},\n    operators::Array{DataType,1}, \n    action::AbstractAction; \n    regions::Array{Int,1} = [0])\n\nCreates a symmetric BilinearForm assembly pattern with the given FESpaces, operators and action etc. Symmetry is not checked automatically, but is assumed during assembly!\n\n\n\n\n\n","category":"function"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractVector{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT}, AbstractVector{T}}} where {APT<:BilinearForm, T<:Real, AT<:AssemblyType}","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.assemble!","text":"assemble!(\n    b::AbstractArray{T,1},          # target vector\n    AP::AssemblyPattern{APT,T,AT},  # BilinearForm Pattern\n    fixedFE::AbstractArray;         # coefficients for fixed argument\n    apply_action_to::Int = 1,       # action is applied to 1st or 2nd argument?\n    fixed_arguments = [1],        # which argument is fixed?\n    factor = 1)                     # factor that is multiplied\n    where {APT <: APT_BilinearForm, T, AT}\n\nAssembly of a BilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the second argument is fixed (default) by the given coefficients in fixedFE. With applyactionto=2 the action can be also applied to the second argument instead of the first one (default).\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.assemble!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractMatrix{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti}}} where {APT<:BilinearForm, T<:Real, AT<:AssemblyType, Tv, Ti}","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.assemble!","text":"assemble!(\n    A::AbstractArray{T,2},                  # target matrix\n    AP::AssemblyPattern{APT,T,AT};          # BilinearForm Pattern\n    apply_action_to::Int = 1,               # action is applied to which argument?\n    factor = 1,                             # factor that is multiplied\n    transposed_assembly::Bool = false,      # transpose result?\n    transpose_copy = Nothing)               # copy a transposed block to this matrix\n    where {APT <: APT_BilinearForm, T, AT}\n\nAssembly of a BilinearForm BLF into given two-dimensional AbstractArray (e.g. FEMatrixBlock or a ExtendableSparseMatrix).\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.APT_TrilinearForm","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.APT_TrilinearForm","text":"abstract type APT_TrilinearForm <: AssemblyPatternType\n\ntrilinearform assembly pattern type\n\n\n\n\n\n","category":"type"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.TrilinearForm-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Type{<:Real}, Type{<:AssemblyType}, Vector{<:FESpace{Tv, Ti}}, Vector{DataType}, AbstractAction}} where {Tv, Ti}","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.TrilinearForm","text":"function TrilinearForm(\n    T::Type{<:Real},\n    FES::Array{FESpace,1},          \n    operators::Array{DataType,1},\n    action::AbstractAction;\n    regions::Array{Int,1} = [0])\n\nCreates a TrilinearForm assembly pattern with the given FESpaces, operators and action etc.\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractMatrix{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT}, Vector{<:FEVectorBlock}}} where {APT<:TrilinearForm, T<:Real, AT<:AssemblyType}","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.assemble!","text":"assemble!(\n    assemble!(\n    A::AbstractArray{T,2},                  # target matrix\n    AP::AssemblyPattern{APT,T,AT},          # TrilinearForm pattern\n    fixedFE::Array{<:FEVectorBlock,1};      # coefficients for fixed argument\n    fixed_argument = [1],                   # position of fixed argument (as an array)\n    transposed_assembly::Bool = false,      # transpose result?\n    factor = 1)                             # factor that is multiplied\n    where {APT <: APT_TrilinearForm, T, AT}\n\nAssembly of a TrilinearForm AP into given two-dimensional AbstractArray (e.g. a FEMatrixBlock). Here, one argument (specified by fixed_argument) is fixed by the given coefficients in fixedFE[1]. Note, that the action is (currently) always applied to the first and second argument.\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractVector, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT}, Vector{<:FEVectorBlock}}} where {APT<:TrilinearForm, T<:Real, AT<:AssemblyType}","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.assemble!","text":"assemble!(\n    assemble!(\n    b::AbstractVector,                      # target vector\n    AP::AssemblyPattern{APT,T,AT},          # coefficients for fixed arguments\n    fixedFE::Array{<:FEVectorBlock,1};      # TrilinearForm pattern\n    factor = 1)                             # factor that is multiplied\n    where {APT <: APT_TrilinearForm, T, AT}\n\nAssembly of a TrilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the first two arguments are fixed by the given coefficients in FE1 and FE2.\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.APT_MultilinearForm","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.APT_MultilinearForm","text":"abstract type APT_MultilinearForm <: AssemblyPatternType\n\nmultilinearform assembly pattern type\n\n\n\n\n\n","category":"type"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.MultilinearForm-Tuple{Type{<:Real}, Type{<:AssemblyType}, Vector{FESpace}, Vector{DataType}, AbstractAction}","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.MultilinearForm","text":"function MultilinearForm(\n    T::Type{<:Real},\n    AT::Type{<:AssemblyType},\n    FE::Array{FESpace,1},\n    operators::Array{DataType,1}, \n    action::AbstractAction; \n    regions::Array{Int,1} = [0])\n\nCreates a MultilinearForm assembly pattern with the given FESpaces, operators and action etc.\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractVector, Vector{AbstractVector}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT}}} where {APT<:MultilinearForm, T<:Real, AT<:AssemblyType}","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.assemble!","text":"assemble!(\n    b::AbstractVector,                        # target vector\n    FE::Array{<:FEVectorBlock,1},             # coefficients of all but last argument\n    AP::AssemblyPattern{APT,T,AT};            # Multilinearform pattern\n    factor = 1)                               # factor that is multiplied\n    where {APT <: APT_MultilinearForm, T, AT}\n\nAssembly of a MultilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the all but the last arguments are fixed by the given coefficients in the components of FE.\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.APT_NonlinearForm","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.APT_NonlinearForm","text":"abstract type APT_NonlinearForm <: AssemblyPatternType\n\nnonlinearform assembly pattern type\n\n\n\n\n\n","category":"type"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.NonlinearForm-Tuple{Type{<:Real}, Type{<:AssemblyType}, Vector{FESpace}, Vector{DataType}, AbstractAction}","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.NonlinearForm","text":"function NonlinearForm(\n    T::Type{<:Real},\n    FES::Array{FESpace,1},          # finite element spaces for each operator of the ansatz function and the last one refers to the test function\n    operators::Array{DataType,1},   # operators that should be evaluated for the ansatz function and the last one refers to the test function\n    action::AbstractAction;         # action that shoul have an AbstractNLActionKernel\n    regions::Array{Int,1} = [0])\n\nCreates a NonlinearForm assembly pattern.\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.assemble!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractMatrix{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT}, Vector{<:FEVectorBlock{T, Tv, Ti}}}} where {APT<:NonlinearForm, T<:Real, AT<:AssemblyType, Tv, Ti}","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.assemble!","text":"assemble!(\n    A::AbstractArray{T,2},                 # target matrix\n    AP::AssemblyPattern{APT,T,AT};         # NonlinearForm pattern\n    FEB::Array{<:FEVectorBlock,1};         # coefficients of current solution for each operator\n    factor = 1,                            # factor that is multiplied\n    transposed_assembly::Bool = false)     # transpose result?\n    where {APT <: APT_NonlinearForm, T, AT}\n\nAssembly of a NonlinearForm assembly pattern into given two-dimensional AbstractArray (e.g. FEMatrixBlock).\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.assemble!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractVector, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT}, Vector{<:FEVectorBlock{T, Tv, Ti}}}} where {APT<:NonlinearForm, T<:Real, AT<:AssemblyType, Tv, Ti}","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.assemble!","text":"assemble!(\n    b::AbstractVector,                     # target vector\n    AP::AssemblyPattern{APT,T,AT},         # NonlinearForm pattern\n    FEB::Array{<:FEVectorBlock,1};         # coefficients of current solution for each operator\n    factor = 1)                            # factor that is multiplied\n    where {APT <: APT_NonlinearForm, T, AT}\n\nAssembly of a NonlinearForm AP into given AbstractVector (e.g. FEMatrixBlock).\n\n\n\n\n\n","category":"method"},{"location":"assemblypatterns/#GradientRobustMultiPhysics.evaluate-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT}, Vector{<:FEVectorBlock}, FEVectorBlock{T, Tv, Ti}}} where {APT<:NonlinearForm, T<:Real, AT<:AssemblyType, Tv, Ti}","page":"Assembly Patterns","title":"GradientRobustMultiPhysics.evaluate","text":"assemble!(\n    AP::AssemblyPattern{APT,T,AT},         # NonlinearForm pattern\n    FEB::Array{<:FEVectorBlock,1};         # coefficients of current solution for each operator\n    FEBtest::FEVectorBlock;                # coefficients of test function for test function operator\n    factor = 1)                            # factor that is multiplied\n    where {APT <: APT_NonlinearForm, T, AT}\n\nEvaluation of a NonlinearForm AP for given coefficients of ansatz and test function.\n\n\n\n\n\n","category":"method"},{"location":"examples/Example204_PoissonLshapeAdaptive2D/#:-Poisson-L-shape-Adaptive-Mesh-Refinement","page":"204 : Poisson L-shape Adaptive Mesh Refinement","title":"204 : Poisson L-shape Adaptive Mesh Refinement","text":"","category":"section"},{"location":"examples/Example204_PoissonLshapeAdaptive2D/","page":"204 : Poisson L-shape Adaptive Mesh Refinement","title":"204 : Poisson L-shape Adaptive Mesh Refinement","text":"(source code)","category":"page"},{"location":"examples/Example204_PoissonLshapeAdaptive2D/","page":"204 : Poisson L-shape Adaptive Mesh Refinement","title":"204 : Poisson L-shape Adaptive Mesh Refinement","text":"This example computes the standard-residual error estimator for the H^1 error e = u - u_h of some H^1-conforming approximation u_h to the solution u of some Poisson problem -Delta u = f on an L-shaped domain, i.e.","category":"page"},{"location":"examples/Example204_PoissonLshapeAdaptive2D/","page":"204 : Poisson L-shape Adaptive Mesh Refinement","title":"204 : Poisson L-shape Adaptive Mesh Refinement","text":"eta^2(u_h) = sum_T in mathcalT lvert T rvert  f + Delta u_h ^2_L^2(T)\n+ sum_F in mathcalF lvert F rvert  nabla u_h cdot mathbfn ^2_L^2(F)","category":"page"},{"location":"examples/Example204_PoissonLshapeAdaptive2D/","page":"204 : Poisson L-shape Adaptive Mesh Refinement","title":"204 : Poisson L-shape Adaptive Mesh Refinement","text":"This example script showcases the evaluation of 2nd order derivatives like the Laplacian and adaptive mesh refinement.","category":"page"},{"location":"examples/Example204_PoissonLshapeAdaptive2D/","page":"204 : Poisson L-shape Adaptive Mesh Refinement","title":"204 : Poisson L-shape Adaptive Mesh Refinement","text":"module Example204_PoissonLshapeAdaptive2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# exact solution u for the Poisson problem\nfunction u!(result,x)\n    result[1] = atan(x[2],x[1])\n    if result[1] < 0\n        result[1] += 2*pi\n    end\n    result[1] = sin(2*result[1]/3)\n    result[1] *= (x[1]^2 + x[2]^2)^(1/3)\nend\n# ... and its gradient\nfunction ∇u!(result,x)\n    result[1] = atan(x[2],x[1])\n    if result[1] < 0\n        result[1] += 2*pi\n    end\n    # du/dy = du/dr * sin(phi) + (1/r) * du/dphi * cos(phi)\n    result[2] = sin(2*result[1]/3) * sin(result[1]) + cos(2*result[1]/3) * cos(result[1])\n    result[2] *= (x[1]^2 + x[2]^2)^(-1/6) * 2/3\n    # du/dx = du/dr * cos(phi) - (1/r) * du/dphi * sin(phi)\n    result[1] = sin(2*result[1]/3) * cos(result[1]) - cos(2*result[1]/3) * sin(result[1])\n    result[1] *= (x[1]^2 + x[2]^2)^(-1/6) * 2/3\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, nlevels = 20, theta = 1//3, order = 2, Plotter = nothing)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # initial grid\n    xgrid = grid_lshape(Triangle2D)\n\n    # choose some finite element\n    if order == 1\n        FEType = H1P1{1}\n    elseif order == 2\n        FEType = H1P2{1,2}\n    elseif order == 3\n        FEType = H1P3{1,2}\n    else\n        @error \"order has to be 1,2 or 3\"\n    end\n\n    # negotiate data functions to the package\n    u = DataFunction(u!, [1,2]; name = \"u\", dependencies = \"X\", quadorder = 5)\n    ∇u = DataFunction(∇u!, [2,2]; name = \"∇u\", dependencies = \"X\", quadorder = 4)\n\n    # setup Poisson problem\n    Problem = PoissonProblem()\n    add_boundarydata!(Problem, 1, [2,3,4,5,6,7], BestapproxDirichletBoundary; data = u)\n    add_boundarydata!(Problem, 1, [1,8], HomogeneousDirichletBoundary)\n\n    # setup exact error evaluations\n    L2Error = L2ErrorIntegrator(Float64, u, Identity)\n    H1Error = L2ErrorIntegrator(Float64, ∇u, Gradient)\n\n    # define error estimator\n    # kernel for jump term : |F| ||[[grad(u_h)*n_F]]||^2_L^2(F)\n    xFaceVolumes::Array{Float64,1} = xgrid[FaceVolumes]\n    xFaceNormals::Array{Float64,2} = xgrid[FaceNormals]\n    xCellVolumes::Array{Float64,1} = xgrid[CellVolumes]\n    function L2jump_integrand(result, input, item)\n        result[1] = ((input[1]*xFaceNormals[1,item])^2 + (input[2]*xFaceNormals[2,item])^2) * xFaceVolumes[item]\n        return nothing\n    end\n    # kernel for volume term : |T| * ||f + Laplace(u_h)||^2_L^2(T)\n    # note: f = 0 here, but integrand can also be made x-dpendent to allow for non-homogeneous rhs\n    function L2vol_integrand(result, input, item)\n        result[1] = input[1]^2 * xCellVolumes[item]\n        return nothing\n    end\n    # ... which generates an action...\n    eta_jumps_action = Action(L2jump_integrand, [1,2]; name = \"kernel of η (jumps)\", dependencies = \"I\", quadorder = 2)\n    eta_vol_action = Action(L2vol_integrand, [1,1]; name = \"kernel of η (vol)\", dependencies = \"I\", quadorder = 1)\n    # ... which is used inside an ItemIntegrator\n    ηF = ItemIntegrator(Float64,ON_IFACES,[Jump(Gradient)],eta_jumps_action; name = \"η_F\")\n    ηT = ItemIntegrator(Float64,ON_CELLS,[Laplacian],eta_vol_action; name = \"η_T\")\n\n    # refinement loop\n    NDofs = zeros(Int, nlevels)\n    Results = zeros(Float64, nlevels, 3)\n    Solution = nothing\n    for level = 1 : nlevels\n\n        # create a solution vector and solve the problem\n        println(\"------- LEVEL $level\")\n        @time begin\n            FES = FESpace{FEType}(xgrid)\n            Solution = FEVector{Float64}(\"u_h\",FES)\n            solve!(Solution, Problem)\n            NDofs[level] = length(Solution[1])\n            println(\"\\t ndof =  $(NDofs[level])\")\n            print(\"@time  solver =\")\n        end\n\n\n        # calculate local error estimator contributions\n        @time begin\n            xFaceVolumes = xgrid[FaceVolumes]\n            xFaceNormals = xgrid[FaceNormals]\n            xCellVolumes = xgrid[CellVolumes]\n            vol_error = zeros(Float64,1,num_sources(xgrid[CellNodes]))\n            jump_error = zeros(Float64,1,num_sources(xgrid[FaceNodes]))\n            evaluate!(vol_error,ηT,Solution[1])\n            evaluate!(jump_error,ηF,Solution[1])\n\n            # calculate total estimator\n            Results[level,3] = sqrt(sum(jump_error) + sum(vol_error))\n            print(\"@time  η eval =\")\n        end\n\n        # calculate exact L2 error, H1 error\n        @time begin\n            Results[level,1] = sqrt(evaluate(L2Error,Solution[1]))\n            Results[level,2] = sqrt(evaluate(H1Error,Solution[1]))\n            print(\"@time  e eval =\")\n        end\n\n        if level == nlevels\n            break;\n        end\n\n        # mesh refinement\n        @time begin\n            if theta >= 1 ## uniform mesh refinement\n                xgrid = uniform_refine(xgrid)\n            else ## adaptive mesh refinement\n                # compute refinement indicators\n                nfaces = num_sources(xgrid[FaceNodes])\n                refinement_indicators::Array{Float64,1} = view(jump_error,1,:)\n                xFaceCells = xgrid[FaceCells]\n                cell::Int = 0\n                for face = 1 : nfaces, k = 1 : 2\n                    cell = xFaceCells[k,face]\n                    if cell > 0\n                        refinement_indicators[face] += vol_error[1,cell]\n                    end\n                end\n\n                # refine by red-green-blue refinement (incl. closuring)\n                facemarker = bulk_mark(xgrid, refinement_indicators, theta; indicator_AT = ON_FACES)\n                xgrid = RGB_refine(xgrid, facemarker)\n            end\n            print(\"@time  refine =\")\n        end\n\n        println(\"\\t    η =  $(Results[level,3])\\n\\t    e =  $(Results[level,2])\")\n    end\n\n    # plot\n    p=GridVisualizer(; Plotter = Plotter, layout = (1,3), clear = true, resolution = (1200,400))\n    scalarplot!(p[1,1], xgrid, nodevalues_view(Solution[1])[1], levels = 11, title = \"u_h\")\n    gridplot!(p[1,2], xgrid; linewidth = 1)\n    gridplot!(p[1,3], xgrid; linewidth = 1, xlimits = [-0.0001,0.0001], ylimits = [-0.0001,0.0001])\n\n    # print/plot convergence history\n    print_convergencehistory(NDofs, Results; X_to_h = X -> X.^(-1/2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"η\"])\n    plot_convergencehistory(NDofs, Results; add_h_powers = [order,order+1], X_to_h = X -> X.^(-1/2), Plotter = Plotter, ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\", \"η\"])\nend\n\nend","category":"page"},{"location":"examples/Example204_PoissonLshapeAdaptive2D/","page":"204 : Poisson L-shape Adaptive Mesh Refinement","title":"204 : Poisson L-shape Adaptive Mesh Refinement","text":"","category":"page"},{"location":"examples/Example204_PoissonLshapeAdaptive2D/","page":"204 : Poisson L-shape Adaptive Mesh Refinement","title":"204 : Poisson L-shape Adaptive Mesh Refinement","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example204_PoissonLshapeAdaptive2D/","page":"204 : Poisson L-shape Adaptive Mesh Refinement","title":"204 : Poisson L-shape Adaptive Mesh Refinement","text":"Default output:","category":"page"},{"location":"examples/Example204_PoissonLshapeAdaptive2D/","page":"204 : Poisson L-shape Adaptive Mesh Refinement","title":"204 : Poisson L-shape Adaptive Mesh Refinement","text":"julia> Example204_PoissonLshapeAdaptive2D.main()\n------- LEVEL 1\n\t ndof =  21\n@time  solver =  0.502862 seconds (854.76 k allocations: 47.062 MiB, 99.40% compilation time)\n@time  η eval =  4.748110 seconds (7.03 M allocations: 381.836 MiB, 4.59% gc time, 99.85% compilation time)\n@time  e eval =  3.687637 seconds (1.86 M allocations: 113.265 MiB, 1.18% gc time, 99.92% compilation time)\n@time  refine =  0.120973 seconds (87.38 k allocations: 4.923 MiB, 99.87% compilation time)\n\t    η =  1.1809216557030233\n\t    e =  0.2076474651624387\n------- LEVEL 2\n\t ndof =  33\n@time  solver =  0.002508 seconds (2.34 k allocations: 233.766 KiB)\n@time  η eval =  0.001023 seconds (1.28 k allocations: 74.172 KiB)\n@time  e eval =  0.000878 seconds (960 allocations: 77.094 KiB)\n@time  refine =  0.000126 seconds (43 allocations: 4.844 KiB)\n\t    η =  0.7574690118747248\n\t    e =  0.16086233264174035\n------- LEVEL 3\n\t ndof =  41\n@time  solver =  0.002089 seconds (2.38 k allocations: 254.555 KiB)\n@time  η eval =  0.000871 seconds (1.29 k allocations: 74.750 KiB)\n@time  e eval =  0.001104 seconds (960 allocations: 77.219 KiB)\n@time  refine =  0.006077 seconds (85 allocations: 7.172 KiB, 98.96% compilation time)\n\t    η =  0.5060512659008009\n\t    e =  0.12710035674542716\n------- LEVEL 4\n\t ndof =  67\n@time  solver =  0.002051 seconds (2.59 k allocations: 309.766 KiB)\n@time  η eval =  0.001105 seconds (1.31 k allocations: 76.625 KiB)\n@time  e eval =  0.001456 seconds (960 allocations: 77.594 KiB)\n@time  refine =  0.000103 seconds (49 allocations: 6.219 KiB)\n\t    η =  0.3333391179306109\n\t    e =  0.0820803030509537\n------- LEVEL 5\n\t ndof =  93\n@time  solver =  0.002417 seconds (2.80 k allocations: 383.086 KiB)\n@time  η eval =  0.000952 seconds (1.33 k allocations: 78.531 KiB)\n@time  e eval =  0.001836 seconds (960 allocations: 77.969 KiB)\n@time  refine =  0.000083 seconds (52 allocations: 9.953 KiB)\n\t    η =  0.2330831445899326\n\t    e =  0.05500436313527563\n------- LEVEL 6\n\t ndof =  119\n@time  solver =  0.002745 seconds (3.01 k allocations: 486.141 KiB)\n@time  η eval =  0.001127 seconds (1.35 k allocations: 80.453 KiB)\n@time  e eval =  0.002237 seconds (960 allocations: 78.469 KiB)\n@time  refine =  0.000065 seconds (57 allocations: 13.594 KiB)\n\t    η =  0.1786953253460242\n\t    e =  0.03945622994399559\n------- LEVEL 7\n\t ndof =  159\n@time  solver =  0.024748 seconds (3.50 k allocations: 613.047 KiB, 85.26% gc time)\n@time  η eval =  0.001304 seconds (1.38 k allocations: 83.422 KiB)\n@time  e eval =  0.003152 seconds (960 allocations: 78.969 KiB)\n@time  refine =  0.000088 seconds (62 allocations: 15.797 KiB)\n\t    η =  0.13915850782044384\n\t    e =  0.029372552786887562\n------- LEVEL 8\n\t ndof =  215\n@time  solver =  0.003893 seconds (4.03 k allocations: 747.164 KiB)\n@time  η eval =  0.001240 seconds (1.43 k allocations: 87.500 KiB)\n@time  e eval =  0.003792 seconds (960 allocations: 79.719 KiB)\n@time  refine =  0.000086 seconds (66 allocations: 17.594 KiB)\n\t    η =  0.10982145223347514\n\t    e =  0.022390159079847222\n------- LEVEL 9\n\t ndof =  287\n@time  solver =  0.004505 seconds (4.67 k allocations: 1023.219 KiB)\n@time  η eval =  0.001443 seconds (1.49 k allocations: 92.609 KiB)\n@time  e eval =  0.005020 seconds (960 allocations: 80.781 KiB)\n@time  refine =  0.000128 seconds (71 allocations: 22.844 KiB)\n\t    η =  0.08174488804164001\n\t    e =  0.015716863066144362\n------- LEVEL 10\n\t ndof =  377\n@time  solver =  0.005576 seconds (5.23 k allocations: 1.239 MiB)\n@time  η eval =  0.001770 seconds (1.55 k allocations: 99.312 KiB)\n@time  e eval =  0.006569 seconds (960 allocations: 82.344 KiB)\n@time  refine =  0.000120 seconds (90 allocations: 41.891 KiB)\n\t    η =  0.06164313323480456\n\t    e =  0.011660924169566598\n------- LEVEL 11\n\t ndof =  527\n@time  solver =  0.007295 seconds (6.44 k allocations: 1.688 MiB)\n@time  η eval =  0.002251 seconds (1.67 k allocations: 109.938 KiB)\n@time  e eval =  0.009430 seconds (960 allocations: 84.469 KiB)\n@time  refine =  0.000154 seconds (103 allocations: 46.719 KiB)\n\t    η =  0.04513125476819608\n\t    e =  0.008394383745614006\n------- LEVEL 12\n\t ndof =  729\n@time  solver =  0.011394 seconds (8.44 k allocations: 2.248 MiB)\n@time  η eval =  0.003486 seconds (1.94 k allocations: 126.047 KiB)\n@time  e eval =  0.013938 seconds (960 allocations: 87.781 KiB)\n@time  refine =  0.000243 seconds (134 allocations: 54.141 KiB)\n\t    η =  0.03308173869008518\n\t    e =  0.0061174746554651886\n------- LEVEL 13\n\t ndof =  1025\n@time  solver =  0.013429 seconds (11.20 k allocations: 2.735 MiB)\n@time  η eval =  0.003935 seconds (3.06 k allocations: 161.234 KiB)\n@time  e eval =  0.017405 seconds (960 allocations: 92.281 KiB)\n@time  refine =  0.000257 seconds (172 allocations: 79.797 KiB)\n\t    η =  0.024323647581148286\n\t    e =  0.004508865558052975\n------- LEVEL 14\n\t ndof =  1403\n@time  solver =  0.016360 seconds (15.36 k allocations: 3.954 MiB)\n@time  η eval =  0.004655 seconds (5.27 k allocations: 217.953 KiB)\n@time  e eval =  0.024371 seconds (2.57 k allocations: 123.188 KiB)\n@time  refine =  0.000344 seconds (220 allocations: 121.047 KiB)\n\t    η =  0.01772116812991022\n\t    e =  0.003194641336963935\n------- LEVEL 15\n\t ndof =  1951\n@time  solver =  0.022441 seconds (21.07 k allocations: 5.575 MiB)\n@time  η eval =  0.006849 seconds (8.67 k allocations: 303.625 KiB)\n@time  e eval =  0.033523 seconds (5.27 k allocations: 173.875 KiB)\n@time  refine =  0.000460 seconds (296 allocations: 139.125 KiB)\n\t    η =  0.012865079056258897\n\t    e =  0.0023110894195146137\n------- LEVEL 16\n\t ndof =  2685\n@time  solver =  0.030566 seconds (28.91 k allocations: 6.666 MiB)\n@time  η eval =  0.009214 seconds (13.23 k allocations: 418.484 KiB)\n@time  e eval =  0.046454 seconds (8.89 k allocations: 241.688 KiB)\n@time  refine =  0.000532 seconds (381 allocations: 199.812 KiB)\n\t    η =  0.009428615043435729\n\t    e =  0.0016865873324354108\n------- LEVEL 17\n\t ndof =  3647\n@time  solver =  0.043056 seconds (39.53 k allocations: 9.119 MiB)\n@time  η eval =  0.012448 seconds (19.19 k allocations: 567.922 KiB)\n@time  e eval =  0.062224 seconds (13.61 k allocations: 330.188 KiB)\n@time  refine =  0.000785 seconds (475 allocations: 294.469 KiB)\n\t    η =  0.006942150841718373\n\t    e =  0.0012444240066196615\n------- LEVEL 18\n\t ndof =  4953\n@time  solver =  0.074231 seconds (53.27 k allocations: 11.946 MiB, 20.08% gc time)\n@time  η eval =  0.016296 seconds (27.32 k allocations: 772.328 KiB)\n@time  e eval =  0.084825 seconds (20.07 k allocations: 451.062 KiB)\n@time  refine =  0.001130 seconds (638 allocations: 440.000 KiB)\n\t    η =  0.005073360038187676\n\t    e =  0.0008976812517459603\n------- LEVEL 19\n\t ndof =  6781\n@time  solver =  0.079229 seconds (72.70 k allocations: 17.359 MiB)\n@time  η eval =  0.020764 seconds (38.70 k allocations: 1.034 MiB)\n@time  e eval =  0.116345 seconds (29.11 k allocations: 620.562 KiB)\n@time  refine =  0.001763 seconds (819 allocations: 635.422 KiB)\n\t    η =  0.003722822140531952\n\t    e =  0.0006539955724240159\n------- LEVEL 20\n\t ndof =  9271\n@time  solver =  0.107449 seconds (100.47 k allocations: 23.638 MiB)\n@time  η eval =  0.029140 seconds (54.22 k allocations: 1.415 MiB)\n@time  e eval =  0.158038 seconds (41.47 k allocations: 852.438 KiB)\n\n    ndofs   |    || u - u_h ||     order  |  || ∇(u - u_h) ||    order  |          η           order  |\n============|=============================|=============================|=============================|\n        21  |     2.51263e-02      0.000  |     2.07647e-01      0.000  |     1.18092e+00      0.000  |\n        33  |     1.90247e-02      1.231  |     1.60862e-01      1.130  |     7.57469e-01      1.965  |\n        41  |     1.26917e-02      3.730  |     1.27100e-01      2.171  |     5.06051e-01      3.716  |\n        67  |     4.79055e-03      3.968  |     8.20803e-02      1.781  |     3.33339e-01      1.700  |\n        93  |     2.38377e-03      4.257  |     5.50044e-02      2.441  |     2.33083e-01      2.182  |\n       119  |     1.78155e-03      2.362  |     3.94562e-02      2.695  |     1.78695e-01      2.156  |\n       159  |     1.24278e-03      2.486  |     2.93726e-02      2.037  |     1.39159e-01      1.726  |\n       215  |     7.86008e-04      3.037  |     2.23902e-02      1.799  |     1.09821e-01      1.569  |\n       287  |     4.04477e-04      4.600  |     1.57169e-02      2.450  |     8.17449e-02      2.044  |\n       377  |     3.33412e-04      1.417  |     1.16609e-02      2.189  |     6.16431e-02      2.069  |\n       527  |     1.95675e-04      3.182  |     8.39438e-03      1.963  |     4.51313e-02      1.862  |\n       729  |     1.14131e-04      3.323  |     6.11747e-03      1.950  |     3.30817e-02      1.914  |\n      1025  |     8.23682e-05      1.914  |     4.50887e-03      1.791  |     2.43236e-02      1.805  |\n      1403  |     4.27727e-05      4.175  |     3.19464e-03      2.195  |     1.77212e-02      2.018  |\n      1951  |     2.80610e-05      2.557  |     2.31109e-03      1.964  |     1.28651e-02      1.942  |\n      2685  |     1.67382e-05      3.236  |     1.68659e-03      1.973  |     9.42862e-03      1.946  |\n      3647  |     1.15905e-05      2.400  |     1.24442e-03      1.986  |     6.94215e-03      1.999  |\n      4953  |     6.26521e-06      4.020  |     8.97681e-04      2.134  |     5.07336e-03      2.049  |\n      6781  |     3.91776e-06      2.989  |     6.53996e-04      2.016  |     3.72282e-03      1.971  |\n      9271  |     2.50250e-06      2.866  |     4.76773e-04      2.021  |     2.72507e-03      1.995  |","category":"page"},{"location":"examples/Example204_PoissonLshapeAdaptive2D/","page":"204 : Poisson L-shape Adaptive Mesh Refinement","title":"204 : Poisson L-shape Adaptive Mesh Refinement","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/Example212_NonlinearPoissonTransient2D/#:-Nonlinear-Poisson-Transient-2D","page":"212 : Nonlinear Poisson Transient 2D","title":"212 : Nonlinear Poisson Transient 2D","text":"","category":"section"},{"location":"examples/Example212_NonlinearPoissonTransient2D/","page":"212 : Nonlinear Poisson Transient 2D","title":"212 : Nonlinear Poisson Transient 2D","text":"(source code)","category":"page"},{"location":"examples/Example212_NonlinearPoissonTransient2D/","page":"212 : Nonlinear Poisson Transient 2D","title":"212 : Nonlinear Poisson Transient 2D","text":"This example computes a transient velocity mathbfu solution of the nonlinear Poisson problem","category":"page"},{"location":"examples/Example212_NonlinearPoissonTransient2D/","page":"212 : Nonlinear Poisson Transient 2D","title":"212 : Nonlinear Poisson Transient 2D","text":"beginaligned\nmathbfu_t - mathrmdiv((1+betamathbfu^2) nabla mathbfu)  = mathbff\nendaligned","category":"page"},{"location":"examples/Example212_NonlinearPoissonTransient2D/","page":"212 : Nonlinear Poisson Transient 2D","title":"212 : Nonlinear Poisson Transient 2D","text":"with (some time-dependent) exterior force mathbff. The parameter beta steers the strength of the nonlinearity.","category":"page"},{"location":"examples/Example212_NonlinearPoissonTransient2D/","page":"212 : Nonlinear Poisson Transient 2D","title":"212 : Nonlinear Poisson Transient 2D","text":"The time integration will be performed by the internal CrankNicolson rule (or optionally BackwardEuler) of GradientRobustMultiPhysics. A manufactureed quadratic-in-space and qaudratic-in-time solution is prescribed to test if the solver computes the exact solution.","category":"page"},{"location":"examples/Example212_NonlinearPoissonTransient2D/","page":"212 : Nonlinear Poisson Transient 2D","title":"212 : Nonlinear Poisson Transient 2D","text":"module Example212_NonlinearPoissonTransient2D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# kernel for nonlinear diffusion operator\nfunction diffusion_kernel!(result, input)\n    # input = [u, grad(u)]\n    result[1] = (1+input[1]^2)*input[2]\n    result[2] = (1+input[1]^2)*input[3]\n    return nothing\nend\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, Plotter = nothing, nlevels = 3, timestep = 1e-1, T = 0.5, FEType = H1P2{1,2}, time_integration_rule = CrankNicolson, t_power = 2, testmode = false)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # set exact solution and data\n    u = DataFunction((result,x,t) -> (result[1] = x[1]*x[2]*(1-t)^t_power), [1,2]; dependencies = \"XT\", quadorder = 2)\n    ∇u = DataFunction((result,x,t) -> (result[1] = x[2]*(1-t)^t_power; result[2] = x[1]*(1-t)^t_power), [2,1]; name = \"∇(u)\", dependencies = \"XT\", quadorder = 1)\n    f = DataFunction((result,x,t) -> (result[1] = -2*(x[1]^3*x[2] + x[2]^3*x[1])*(1-t)^(3*t_power) -t_power*x[1]*x[2]*(1-t)^(t_power-1)), [2,1]; name = \"∇(u)\", dependencies = \"XT\", quadorder = 4)\n\n    # initial grid and final time\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D),1)\n\n    # prepare nonlinear expression (1+u^2)*grad(u)\n    nonlin_diffusion = NonlinearForm([Identity, Gradient], [1,1], Gradient, diffusion_kernel!, [2,3]; name = \"(1+u^2) ∇u ⋅ ∇v\", quadorder = 2, ADnewton = true)\n\n    # generate problem description and assign nonlinear operator and data\n    Problem = PDEDescription(\"nonlinear Poisson problem\")\n    add_unknown!(Problem; unknown_name = \"u\", equation_name = \"nonlinear Poisson equation\")\n    add_operator!(Problem, [1,1], nonlin_diffusion)\n    add_boundarydata!(Problem, 1, [1,2,3,4], BestapproxDirichletBoundary; data = u)\n    add_rhsdata!(Problem, 1,  RhsOperator(Identity, [0], f))\n\n    # define error evaluators\n    L2Error = L2ErrorIntegrator(Float64, u, Identity; time = T)\n    H1Error = L2ErrorIntegrator(Float64, ∇u, Gradient; time = T)\n    NDofs = zeros(Int,nlevels)\n    Results = zeros(Float64,nlevels,2)\n\n    # loop over levels\n    Solution = nothing\n    for level = 1 : nlevels\n        # refine grid\n        xgrid = uniform_refine(xgrid)\n\n        # generate FESpace and solution vector\n        FES = FESpace{FEType}(xgrid)\n        Solution = FEVector(\"u_h\",FES)\n\n        # set initial solution\n        interpolate!(Solution[1], u)\n\n        # generate time-dependent solver\n        sys = TimeControlSolver(Problem, Solution, time_integration_rule; timedependent_equations = [1], maxiterations = 5)\n\n        # use time control solver by GradientRobustMultiPhysics\n        advance_until_time!(sys, timestep, T)\n\n        # calculate L2 and H1 error and save data\n        NDofs[level] = length(Solution.entries)\n        Results[level,1] = sqrt(evaluate(L2Error,Solution[1]))\n        Results[level,2] = sqrt(evaluate(H1Error,Solution[1]))\n    end\n\n    if testmode == true\n        return Results[end,2]\n    else\n        p = GridVisualizer(; Plotter = Plotter, layout = (1,2), clear = true, resolution = (1000,500))\n        scalarplot!(p[1,1], xgrid, nodevalues_view(Solution[1])[1], levels = 11, title = \"u_h\")\n        scalarplot!(p[1,2], xgrid, view(nodevalues(Solution[1], Gradient; abs = true),1,:), levels=7)\n        vectorplot!(p[1,2], xgrid, evaluate(PointEvaluator(Solution[1], Gradient)), spacing = 0.1, clear = false, title = \"∇u_h (abs + quiver)\")\n\n        # print/plot convergence history\n        print_convergencehistory(NDofs, Results; X_to_h = X -> X.^(-1/2), ylabels = [\"|| u - u_h ||\", \"|| ∇(u - u_h) ||\"])\n    end\nend\n\nfunction test()\n    error1 = main(; nlevels = 1, FEType = H1P2{1,2}, t_power = 1, time_integration_rule = BackwardEuler, testmode = true)\n    error2 = main(; nlevels = 1, FEType = H1P2{1,2}, t_power = 2, time_integration_rule = CrankNicolson, testmode = true)\n    return max(error1,error2)\nend\n\nend","category":"page"},{"location":"examples/Example212_NonlinearPoissonTransient2D/","page":"212 : Nonlinear Poisson Transient 2D","title":"212 : Nonlinear Poisson Transient 2D","text":"","category":"page"},{"location":"examples/Example212_NonlinearPoissonTransient2D/","page":"212 : Nonlinear Poisson Transient 2D","title":"212 : Nonlinear Poisson Transient 2D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example212_NonlinearPoissonTransient2D/","page":"212 : Nonlinear Poisson Transient 2D","title":"212 : Nonlinear Poisson Transient 2D","text":"(Image: )","category":"page"},{"location":"examples/ExampleA04_CustomLinearSolver/#A04-:-Custom-Linear-Solvers","page":"A04 : Custom Linear Solvers","title":"A04 : Custom Linear Solvers","text":"","category":"section"},{"location":"examples/ExampleA04_CustomLinearSolver/","page":"A04 : Custom Linear Solvers","title":"A04 : Custom Linear Solvers","text":"(source code)","category":"page"},{"location":"examples/ExampleA04_CustomLinearSolver/","page":"A04 : Custom Linear Solvers","title":"A04 : Custom Linear Solvers","text":"This example revisits the nonlinear Poisson example from the introductory examples and showcases how to define a user-specified linear solver.","category":"page"},{"location":"examples/ExampleA04_CustomLinearSolver/","page":"A04 : Custom Linear Solvers","title":"A04 : Custom Linear Solvers","text":"module ExampleA04_CustomLinearSolver\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing ExtendableSparse\nusing GridVisualize\n\n\n# first define a subtype of AbstractLinearSystem, which is later given as an optional parameter to the problem solve! call\nmutable struct MySolver{Tv,Ti} <: GradientRobustMultiPhysics.AbstractLinearSystem{Tv, Ti}\n    x::AbstractVector{Tv}\n    A::ExtendableSparseMatrix{Tv,Ti}\n    b::AbstractVector{Tv}\n    # add stuff here that you need e.g. for preconditioners\n    MySolver{Tv,Ti}(x,A,b) where {Tv,Ti} = new{Tv,Ti}(x,A,b)\nend\n\n# you need to define update_factorization! and solve! functions for your new subtype\nfunction GradientRobustMultiPhysics.update_factorization!(LS::MySolver)\n    # this function is called before the solve (if other solver configuration not cause to skip it)\n    # do anything here (e.g. updating the preconditioner)\n    println(\"\\t\\tHi! update_factorization! is called at start and every skip_update time...\")\nend\nfunction GradientRobustMultiPhysics.solve!(LS::MySolver)\n    # this function is called to solve the linear system\n    println(\"\\t\\tHi! solve! under way...\")\n    LS.x .= LS.A \\ LS.b\nend\n\n\n# problem data\nfunction exact_function!(result,x)\n    result[1] = x[1]*x[2]\n    return nothing\nend\nfunction exact_gradient!(result,x)\n    result[1] = x[2]\n    result[2] = x[1]\n    return nothing\nend\nfunction rhs!(result,x)\n    result[1] = -2*(x[1]^3*x[2] + x[2]^3*x[1]) # = -div((1+u^2)*grad(u))\n    return nothing\nend\n\n# everything is wrapped in a main function\nfunction main(; Plotter = nothing, verbosity = 0, nrefinements = 5, FEType = H1P1{1}, skip_update = 2)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # choose initial mesh\n    xgrid = uniform_refine(grid_unitsquare(Triangle2D),nrefinements)\n\n    # negotiate data functions to the package\n    u = DataFunction(exact_function!, [1,2]; name = \"u_exact\", dependencies = \"X\", quadorder = 2)\n    u_gradient = DataFunction(exact_gradient!, [2,2]; name = \"grad(u_exact)\", dependencies = \"X\", quadorder = 1)\n    u_rhs = DataFunction(rhs!, [1,2]; dependencies = \"X\", name = \"f\", quadorder = 4)\n\n    # prepare nonlinear expression (1+u^2)*grad(u)\n    function diffusion_kernel!(result, input)\n        # input = [u, grad(u)]\n        result[1] = (1+input[1]^2)*input[2]\n        result[2] = (1+input[1]^2)*input[3]\n        return nothing\n    end\n    nonlin_diffusion = NonlinearForm([Identity, Gradient], [1,1], Gradient, diffusion_kernel!, [2,3]; name = \"((1+u^2)*grad(u))*grad(v)\", quadorder = 2, ADnewton = true)\n\n    # generate problem description and assign nonlinear operator and data\n    Problem = PDEDescription(\"nonlinear Poisson problem\")\n    add_unknown!(Problem; unknown_name = \"u\", equation_name = \"nonlinear Poisson equation\")\n    add_operator!(Problem, [1,1], nonlin_diffusion)\n    add_boundarydata!(Problem, 1, [1,2,3,4], BestapproxDirichletBoundary; data = u)\n    add_rhsdata!(Problem, 1,  RhsOperator(Identity, [0], u_rhs; store = true))\n\n    # create finite element space and solution vector\n    FES = FESpace{FEType}(xgrid)\n    Solution = FEVector(\"u_h\",FES)\n\n    # solve the problem (here the newly defined linear solver type is used)\n    solve!(Solution, Problem; linsolver = MySolver{Float64,Int64}, skip_update = [skip_update])\n\n    # calculate error\n    L2Error = L2ErrorIntegrator(Float64, u, Identity)\n    H1Error = L2ErrorIntegrator(Float64, u_gradient, Gradient)\n    println(\"\\tL2error = $(sqrt(evaluate(L2Error,Solution[1])))\")\n    println(\"\\tH1error = $(sqrt(evaluate(H1Error,Solution[1])))\")\n\n    # plot\n    p = GridVisualizer(; Plotter = Plotter, layout = (1,2), clear = true, resolution = (1000,500))\n    scalarplot!(p[1,1], xgrid, view(nodevalues(Solution[1]),1,:), levels = 11, title = \"u_h\")\n    scalarplot!(p[1,2], xgrid, view(nodevalues(Solution[1], Gradient; abs = true),1,:), levels=7)\n    vectorplot!(p[1,2], xgrid, evaluate(PointEvaluator(Solution[1], Gradient)), spacing = 0.1, clear = false, title = \"∇u_h (abs + quiver)\")\nend\n\n\nend","category":"page"},{"location":"examples/ExampleA04_CustomLinearSolver/","page":"A04 : Custom Linear Solvers","title":"A04 : Custom Linear Solvers","text":"","category":"page"},{"location":"examples/ExampleA04_CustomLinearSolver/","page":"A04 : Custom Linear Solvers","title":"A04 : Custom Linear Solvers","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/ExampleA04_CustomLinearSolver/","page":"A04 : Custom Linear Solvers","title":"A04 : Custom Linear Solvers","text":"Default output:","category":"page"},{"location":"examples/ExampleA04_CustomLinearSolver/","page":"A04 : Custom Linear Solvers","title":"A04 : Custom Linear Solvers","text":"julia> ExampleA04_CustomLinearSolver.main()\n\n\tITERATION |  LSRESIDUAL  |  NLRESIDUAL\n\t--------------------------------------\n\t\tHi! update_factorization! is called at start and every skip_update time...\n\t\tHi! solve! under way...\n\t      1   | 8.364130e-15 | 2.924738e-02\n\t\tHi! update_factorization! is called at start and every skip_update time...\n\t\tHi! solve! under way...\n\t      2   | 9.261648e-15 | 4.905172e-04\n\t\tHi! solve! under way...\n\t      3   | 9.632991e-15 | 1.346748e-07\n\t\tHi! update_factorization! is called at start and every skip_update time...\n\t\tHi! solve! under way...\n\t      4   | 9.869671e-15 | 1.971147e-14\n\n\tL2error = 2.592288956238043e-5\n\tH1error = 0.00902110956931196","category":"page"},{"location":"examples/ExampleA04_CustomLinearSolver/","page":"A04 : Custom Linear Solvers","title":"A04 : Custom Linear Solvers","text":"(Image: )","category":"page"},{"location":"examples/ExampleA08_BasisPlotter/#A08-:-Basis-Plotter","page":"A08 : Basis-Plotter","title":"A08 : Basis-Plotter","text":"","category":"section"},{"location":"examples/ExampleA08_BasisPlotter/","page":"A08 : Basis-Plotter","title":"A08 : Basis-Plotter","text":"(source code)","category":"page"},{"location":"examples/ExampleA08_BasisPlotter/","page":"A08 : Basis-Plotter","title":"A08 : Basis-Plotter","text":"This example shows how to plot all the basis functions of a finite element on a reference geometry","category":"page"},{"location":"examples/ExampleA08_BasisPlotter/","page":"A08 : Basis-Plotter","title":"A08 : Basis-Plotter","text":"module ExampleA08_BasisPlotter\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# everything is wrapped in a main function\nfunction main(; refgeom = Triangle2D, nrefinements_for_plot = 4, nplots_per_row = num_nodes(refgeom), plotsize = 400, Plotter = nothing)\n\n    # generate two grids\n    xgrid = reference_domain(refgeom)\n    xgrid_fine = split_grid_into(xgrid, dim_element(refgeom) == 2 ? Triangle2D : Tetrahedron3D)\n    xgrid_fine = uniform_refine(xgrid_fine, nrefinements_for_plot)\n\n    # set finite element type and get some information\n    FEType = HDIVBDM1{2}\n    ncomponents = get_ncomponents(FEType)\n    ndofs = get_ndofs(ON_CELLS, FEType, refgeom)\n\n    # generate FEVector that carry the basis functions\n    FEFunc = FEVector(\"unit vector\",FESpace{FEType}(xgrid))\n    FEFunc_fine = FEVector(\"representation on fine mesh\",FESpace{H1P1{ncomponents}}(xgrid_fine))\n\n    # prepare plot layout\n    nrows = Int(ceil(ndofs/nplots_per_row))\n    p = GridVisualizer(; Plotter = Plotter, layout = (nrows,nplots_per_row), clear = true, resolution = (plotsize*nplots_per_row,nrows*plotsize))\n\n    # loop over all basis functions\n    # interpolate on fine grid and plot\n    nodevalues = zeros(Float64,2,num_nodes(xgrid_fine))\n    col::Int, row::Int = 1, 1\n    for j = 1 : ndofs\n        fill!(FEFunc.entries,0)\n        FEFunc.entries[j] = 1\n        interpolate!(FEFunc_fine[1], FEFunc[1])\n        nodevalues!(nodevalues,FEFunc_fine[1])\n        if ncomponents > 1 # vector-valued functions are plotted abs + quiver\n            scalarplot!(p[row,col], xgrid_fine, view(sqrt.(sum(nodevalues.^2, dims = 1)),1,:), levels = 3, colorbarticks = 11, xlimits = [-0.25,1.25], ylimits = [-0.25,1.25], title = \"φ_$j\")\n            vectorplot!(p[row,col], xgrid_fine, nodevalues, clear = false, spacing = 1/7, title = \"φ_$j\")\n        else\n            scalarplot!(p[row,col], xgrid_fine, view(nodevalues,1,:), levels = 7, title = \"φ_$j\")\n        end\n        if col == nplots_per_row\n            row += 1\n            col = 1\n        else\n            col += 1\n        end\n    end\nend\nend","category":"page"},{"location":"examples/ExampleA08_BasisPlotter/","page":"A08 : Basis-Plotter","title":"A08 : Basis-Plotter","text":"","category":"page"},{"location":"examples/ExampleA08_BasisPlotter/","page":"A08 : Basis-Plotter","title":"A08 : Basis-Plotter","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/ExampleA08_BasisPlotter/","page":"A08 : Basis-Plotter","title":"A08 : Basis-Plotter","text":"Default output:","category":"page"},{"location":"examples/ExampleA08_BasisPlotter/","page":"A08 : Basis-Plotter","title":"A08 : Basis-Plotter","text":"julia> ExampleA08_BasisPlotter.main()","category":"page"},{"location":"examples/ExampleA08_BasisPlotter/","page":"A08 : Basis-Plotter","title":"A08 : Basis-Plotter","text":"(Image: )","category":"page"},{"location":"examples_intro/#About-the-examples","page":"About the examples","title":"About the examples","text":"","category":"section"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"The examples have been designed with the following issues in mind:","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"they run from the Julia REPL\neach example is a Julia module named similar to the basename of the example file.\nan example can be used as the starting point for a project \nsome examples define test cases for the test suite\nExampleXYZ with X = A can be considered advanced and uses low-level structures and/or demonstrates customisation features or experimental features\nthe default output of the main function is printed on the website and can be used to check if the code runs as expected (unfortunately REPL messages are not recorded)","category":"page"},{"location":"examples_intro/#Running-the-examples","page":"About the examples","title":"Running the examples","text":"","category":"section"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"In order to run ExampleXXX, peform the following steps:","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"Download the example file (e.g. via the source code link at the top)\nMake sure all used packages are installed in your Julia environment\nIn the REPL: ","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"julia> include(\"ExampleXXX.jl\")`\n\njulia> ExampleXXX.main()","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"Some examples offer visual output via the optional argument Plotter = PyPlot or Plotter = GLMakie","category":"page"},{"location":"examples_intro/","page":"About the examples","title":"About the examples","text":"(provided the package PyPlot/GLMakie is installed and loaded)","category":"page"},{"location":"fems/#Implemented-Finite-Elements","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"This page describes the finite element type-tree and lists all implemented finite elements.","category":"page"},{"location":"fems/#The-Finite-Element-Type-Tree","page":"Implemented Finite Elements","title":"The Finite Element Type-Tree","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"Finite elements are abstract type leaves in a type-tree. The complete tree looks like this:","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"AbstractFiniteElement\n├─ AbstractH1FiniteElement\n│  ├─ AbstractH1FiniteElementWithCoefficients\n│  │  ├─ H1P1TEB\n│  │  └─ H1BR\n│  ├─ H1CR\n│  ├─ H1MINI\n│  ├─ H1P0\n│  ├─ H1P1\n│  ├─ H1P2\n│  ├─ H1P2B\n│  ├─ H1P3\n│  └─ H1Pk\n├─ AbstractHcurlFiniteElement\n│  └─ HCURLN0\n└─ AbstractHdivFiniteElement\n   ├─ HDIVBDM1\n   ├─ HDIVBDM2\n   ├─ HDIVRT0\n   └─ HDIVRT1","category":"page"},{"location":"fems/#Remarks","page":"Implemented Finite Elements","title":"Remarks","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"each type depends on one/two or three parameters, the first one is always the number of components (ncomponents) that determines if the finite element is scalar- or veector-valued; some elements additionaly require the parameter edim <: Int if they are structurally different in different space dimensions; arbitrary order elements require a third parameter that determines the order\neach finite elements mainly comes with a set of basis functions in reference coordinates for each applicable AbstractElementGeometry and degrees of freedom maps for each Assembly Type (coded as a string)\nbroken finite elements are possible via the broken switch in the FESpace constructor\nthe type steers how the basis functions are transformed from local to global coordinates and how FunctionOperators are evaluated\ndepending on additional continuity properties of the element types more basis function sets are defined:\nAbstractH1FiniteElements additionally have evaluations of nonzero basisfunctions on faces/bfaces\nAbstractHdivFiniteElements additionally have evaluations of nonzero normalfluxes of basisfunctions on faces/bfaces\nAbstractHcurlFiniteElements additionally have evaluations of nonzero tangentfluxes of basisfunctions on edges/bedges\neach finite element has its own implemented standard interpolation interpolate! (see Finite Element Interpolations) that can be applied to a Data Function, below it is shortly described what this means for each finite element","category":"page"},{"location":"fems/#List-of-implemented-Finite-Elements","page":"Implemented Finite Elements","title":"List of implemented Finite Elements","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The following table lists all curently implemented finite elements and on which geometries they are available (in brackets a dofmap pattern for CellDofs is shown and the number of local degrees of freedom for a vector-valued realisation). Click on the FEType to find out more details.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"FEType Triangle2D Parallelogram2D Tetrahedron3D Parallelepiped3D\nAbstractH1FiniteElementWithCoefficients    \nH1BR ✓ (N1f1, 9) ✓ (N1f1, 12) ✓ (N1f1, 16) \nH1P1TEB ✓ (N1f1, 9)  ✓ (N1e1, 18) \nAbstractH1FiniteElement    \nH1BUBBLE ✓ (I1, 2) ✓ (I1, 2) ✓ (I1, 3) \nH1CR ✓ (F1, 6) ✓ (F1, 8) ✓ (F1, 12) \nH1MINI ✓ (N1I1, 8) ✓ (N1I1, 10) ✓ (N1I1, 15) \nH1P0 ✓ (I1, 2) ✓ (I1, 2) ✓ (I1, 3) ✓ (I1, 3)\nH1P1 ✓ (N1, 6) ✓ (N1, 8) ✓ (N1, 12) ✓ (N1, 24)\nH1P2 ✓ (N1F1, 12) ✓ (N1F1, 16) ✓ (N1E1, 30) \nH1P2B ✓ (N1F1I1, 14)   \nH1P3 ✓ (N1F2I1, 20)   \nH1Pk ✓ (order-dep)   \nAbstractHcurlFiniteElement    \nHCURLN0 ✓ (f1, 3) ✓ (f1, 4) ✓ (e1, 6) \nAbstractHdivFiniteElement    \nHDIVBDM1 ✓ (f2, 6) ✓ (f2, 8) ✓ (f3, 12) \nHDIVBDM2 ✓ (f3i3, 12)   \nHDIVRT0 ✓ (f1, 3) ✓ (f1, 4) ✓ (f1, 4) ✓ (f1, 6)\nHDIVRT1 ✓ (f2i2, 8)  ✓ (f3i3, 15) ","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"Note: the dofmap pattern describes the connection of the local degrees of freedom to entities of the grid and also hints to the continuity. Here, \"N\" or \"n\" means nodes, \"F\" or \"f\" means faces, \"E\" or \"e\" means edges and \"I\" means interior (dofs without any continuity across elements). Capital letters cause that every component has its own degree of freedom, while small letters signalize that only one dof is associated to the entity. As an example \"N1f1\" (for the Bernardi-Raugel element) means that at each node sits one dof per component and at each face sits a single dof. Usually finite elements that involve small letters are only defined vector-valued (i.e. the number of components has to match the element dimension), while finite elements that only involve capital letters are available for any number of components.","category":"page"},{"location":"fems/#H1-conforming-finite-elements","page":"Implemented Finite Elements","title":"H1-conforming finite elements","text":"","category":"section"},{"location":"fems/#P0-finite-element","page":"Implemented Finite Elements","title":"P0 finite element","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"Piecewise constant finite element that has one degree of freedom on each cell of the grid. (It is masked as a H1-conforming finite element, because it uses the same transformations.)","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The interpolation of a given function into this space preserves the cell integrals.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1P0","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.H1P0","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1P0","text":"abstract type H1P0{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nPiecewise constant polynomials on cells.\n\nallowed on every ElementGeometry\n\n\n\n\n\n","category":"type"},{"location":"fems/#P1-finite-element","page":"Implemented Finite Elements","title":"P1 finite element","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The lowest-order current finite element that has a degree of freedom on each vertex of the grid. On simplices the basis functions coincide with the linear barycentric coordinates, on parallelepiped bi-linear functions are used (also known as Q1 element).","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1P1","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.H1P1","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1P1","text":"abstract type H1P1{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nContinuous piecewise first-order polynomials.\n\nallowed ElementGeometries:\n\nEdge1D (linear polynomials)\nTriangle2D (linear polynomials)\nQuadrilateral2D (Q1 space)\nTetrahedron3D (linear polynomials)\nHexahedron3D (Q1 space)\n\n\n\n\n\n","category":"type"},{"location":"fems/#MINI-finite-element","page":"Implemented Finite Elements","title":"MINI finite element","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The mini finite element adds cell bubles to the P1 element that are e.g. beneficial to define inf-sup stable finite element pairs for the Stokes problem.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves its cell integral.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1MINI","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.H1MINI","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1MINI","text":"abstract type H1MINI{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nMini finite element.\n\nallowed element geometries:\n\nTriangle2D (linear polynomials + cubic cell bubble)\nQuadrilateral2D (Q1 space + quartic cell bubble)\nTetrahedron3D (linear polynomials + cubic cell bubble)\n\n\n\n\n\n","category":"type"},{"location":"fems/#P1TEB-finite-element","page":"Implemented Finite Elements","title":"P1TEB finite element","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"This element adds tangent-weighted edge bubbles to the P1 finite element and therefore is only available as a vector-valued element.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves face integrals of its tangential flux.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1P1TEB","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.H1P1TEB","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1P1TEB","text":"abstract type H1P1TEB{edim} <: AbstractH1FiniteElementWithCoefficients where {edim<:Int}\n\nvector-valued (ncomponents = edim) element that uses P1 functions + tangential-weighted edge bubbles as suggested by [\"Fortin Operator for the Taylor-Hood Element\", 2021, arxiv:2104.13953]\n\n(is inf-sup stable for Stokes if paired with continuous P1 pressure space, less degrees of freedom than MINI)\n\nallowed ElementGeometries:\n\nTriangle2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Bernardi-Raugel-(BR)-finite-element","page":"Implemented Finite Elements","title":"Bernardi-Raugel (BR) finite element","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The Bernardi-Raugel adds normal-weighted face bubbles to the P1 finite element and therefore is only available as a vector-valued element.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves face integrals of its normal flux.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1BR","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.H1BR","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1BR","text":"abstract type H1BR{edim} <: AbstractH1FiniteElementWithCoefficients where {edim<:Int}\n\nvector-valued (ncomponents = edim) Bernardi–Raugel element (first-order polynomials + normal-weighted face bubbles)\n\nallowed ElementGeometries:\n\nTriangle2D (piecewise linear + normal-weighted face bubbles)\nQuadrilateral2D (Q1 space + normal-weighted face bubbles)\nTetrahedron3D (piecewise linear + normal-weighted face bubbles)\n\n\n\n\n\n","category":"type"},{"location":"fems/#P2-finite-element","page":"Implemented Finite Elements","title":"P2 finite element","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The P2 finite element method on simplices equals quadratic polynomials. On the Triangle2D shape the degrees of freedom are associated with the three vertices and the three faces of the triangle. On the Tetrahedron3D shape the degrees of freedom are associated with the four verties and the six edges. On Parallelogram2D cubic Q2 element functions are used.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves its face/edge integrals in 2D/3D.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1P2","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.H1P2","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1P2","text":"abstract type H1P2{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nContinuous piecewise second-order polynomials.\n\nallowed ElementGeometries:\n\nEdge1D (quadratic polynomials)\nTriangle2D (quadratic polynomials)\nQuadrilateral2D (Q2 space)\nTetrahedron3D (quadratic polynomials)\n\n\n\n\n\n","category":"type"},{"location":"fems/#P2B-finite-element","page":"Implemented Finite Elements","title":"P2B finite element","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The P2B finite element adds additional cell bubles (in 2D and 3D) and face bubbles (only in 3D) that are e.g. used to define inf-sup stable finite element pairs for the Stokes problem.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves its cell and face integrals in 2D and also edge integrals in 3D.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1P2B","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.H1P2B","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1P2B","text":"abstract type H1P2B{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nContinuous piecewise second-order polynomials.\n\nallowed ElementGeometries:\n\nTriangle2D\n\n\n\n\n\n","category":"type"},{"location":"fems/#P3-finite-element","page":"Implemented Finite Elements","title":"P3 finite element","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The P3 finite element method on simplices equals cubic polynomials. On the Triangle2D shape the degrees of freedom are associated with the three vertices, the three faces (double dof) of the triangle and the cell itself (one cell bubble).","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves cell and face integrals in 2D.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1P3","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.H1P3","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1P3","text":"abstract type H1P3{ncomponents,edim} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int}\n\nContinuous piecewise third-order polynomials.\n\nallowed ElementGeometries:\n\nEdge1D (cubic polynomials)\nTriangle2D (cubic polynomials, experimental)\n\n\n\n\n\n","category":"type"},{"location":"fems/#Pk-finite-element-(experimental)","page":"Implemented Finite Elements","title":"Pk finite element (experimental)","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The Pk finite element method generically generates polynomials of abitrary order k on simplices (Edge1D, Triangle2D so far).","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The interpolation of a given function into this space performs point evaluations at the nodes and preserves cell and face integrals in 2D (moment order depends on the order and the element dimension).","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1Pk","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.H1Pk","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1Pk","text":"abstract type H1PK{ncomponents,edim,order} <: AbstractH1FiniteElement where {ncomponents<:Int,edim<:Int,order<:Int}\n\nContinuous piecewise polynomials of arbitrary order >= 1.\n\nallowed ElementGeometries:\n\nEdge1D\nTriangle2D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Crouzeix-Raviart-(CR)-finite-element","page":"Implemented Finite Elements","title":"Crouzeix-Raviart (CR) finite element","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The Crouzeix-Raviart element associates one lowest-order function with each face. On the Triangle2D shape, the basis function of a face is one minus two times the nodal basis function of the opposite node. ","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"The interpolation of a given function into this space preserves its face integrals.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"H1CR","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.H1CR","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.H1CR","text":"abstract type H1CR{ncomponents} <: AbstractH1FiniteElement where {ncomponents<:Int}\n\nCrouzeix-Raviart element (only continuous at face centers).\n\nallowed ElementGeometries:\n\nTriangle2D (piecewise linear, similar to P1)\nQuadrilateral2D (similar to Q1 space)\nTetrahedron3D (piecewise linear, similar to P1)\n\n\n\n\n\n","category":"type"},{"location":"fems/#Hdiv-conforming-finite-elements","page":"Implemented Finite Elements","title":"Hdiv-conforming finite elements","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"These Raviart-Thomas and Brezzi-Douglas-Marini finite elements of lower order and their standard interpolations are available:","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"HDIVRT0\nHDIVBDM1\nHDIVRT1\nHDIVBDM2","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.HDIVRT0","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.HDIVRT0","text":"abstract type HDIVRT0{edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) lowest-order Raviart-Thomas space.\n\nallowed ElementGeometries:\n\nTriangle2D\nQuadrilateral2D\nTetrahedron3D\nHexahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#GradientRobustMultiPhysics.HDIVBDM1","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.HDIVBDM1","text":"abstract type HDIVBDM1{edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) lowest-order Brezzi-Douglas-Marini space\n\nallowed ElementGeometries:\n\nTriangle2D\nQuadrilateral2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#GradientRobustMultiPhysics.HDIVRT1","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.HDIVRT1","text":"abstract type HDIVRT1{edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) Raviart-Thomas space of order 1.\n\nallowed ElementGeometries:\n\nTriangle2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"fems/#GradientRobustMultiPhysics.HDIVBDM2","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.HDIVBDM2","text":"abstract type HDIVBDM2{edim} <: AbstractHdivFiniteElement where {edim<:Int}\n\nHdiv-conforming vector-valued (ncomponents = edim) Brezzi-Douglas-Marini space of order 2\n\nallowed ElementGeometries:\n\nTriangle2D\n\n\n\n\n\n","category":"type"},{"location":"fems/#Hcurl-conforming-finite-elements","page":"Implemented Finite Elements","title":"Hcurl-conforming finite elements","text":"","category":"section"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"So far only the lowest order Nedelec element is available in 2D and 3D. On Triangle2D it has one degree of freedom for each face (i.e. the rotated RT0 element), on Tetrahedron3D it has one degree of freedom associated to each of the six edges.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"Its standard interpolation of a given functions preserves its tangential face/edge integrals.","category":"page"},{"location":"fems/","page":"Implemented Finite Elements","title":"Implemented Finite Elements","text":"HCURLN0","category":"page"},{"location":"fems/#GradientRobustMultiPhysics.HCURLN0","page":"Implemented Finite Elements","title":"GradientRobustMultiPhysics.HCURLN0","text":"abstract type HCURLN0{edim} <: AbstractHcurlFiniteElement where {edim<:Int}\n\nHcurl-conforming vector-valued (ncomponents = edim) lowest-order Nedelec space.\n\nallowed ElementGeometries:\n\nTriangle2D\nQuadrilateral2D\nTetrahedron3D\n\n\n\n\n\n","category":"type"},{"location":"pdesolvers/#Fixed-Time-Solvers","page":"Fixed-Time Solvers","title":"Fixed-Time Solvers","text":"","category":"section"},{"location":"pdesolvers/#Fixed-Time-Solvers-2","page":"Fixed-Time Solvers","title":"Fixed-Time Solvers","text":"","category":"section"},{"location":"pdesolvers/","page":"Fixed-Time Solvers","title":"Fixed-Time Solvers","text":"If solve! is applied to a PDEDescription and a FEVector (that specifies the ansatz spaces for the unknowns) an investigation of the PDEDescription is performed that decides if the problem is nonlinear (and has to be solved by a fixed-point algorithm) or if it can be solved directly in one step. Additionally the user can manually trigger subiterations that splits the fixed-point algorithm into substeps where only subsets of the PDE equations are solved together.","category":"page"},{"location":"pdesolvers/","page":"Fixed-Time Solvers","title":"Fixed-Time Solvers","text":"solve!","category":"page"},{"location":"pdesolvers/#GradientRobustMultiPhysics.solve!","page":"Fixed-Time Solvers","title":"GradientRobustMultiPhysics.solve!","text":"function solve!(\n    Target::FEVector,       # contains initial guess and final solution after solve\n    PDE::PDEDescription;\n    kwargs)\n\nSolves a given PDE (provided as a PDEDescription) and writes the solution into the FEVector Target (which knows the discrete ansatz spaces).\n\nKeyword arguments:\n\nanderson_iterations: use Anderson acceleration with this many previous iterates (to hopefully speed up/enable convergence of fixpoint iterations). Default: 0\nsubiterations: an array of equation subsets (each an array) that should be solved together in each fixpoint iteration. Default: ''auto''\nshowiterationdetails: show details (residuals etc.) of each iteration. Default: true\nanderson_unknowns: an array of unknown numbers that should be included in the Anderson acceleration. Default: [1]\nshow_statistics: show some statistics like assembly times. Default: false\nanderson_metric: String that encodes the desired convergence metric for the Anderson acceleration (possible values: ''l2'' or ''L2'' or ''H1''). Default: ''l2''\nskipupdate: matrix update (for the j-th sub-iteration) will be performed each skipupdate[j] iteration; -1 means only in the first iteration. Default: [1]\nlinsolver: String that encodes the linear solver, or type name of self-defined solver (see corressponding example), or type name of ExtendableSparse.AbstractFactorization. Default: ''UMFPACK''\ndamping: damp the new iteration with this part of the old iteration (0 = undamped), also a function is allowed with the interface (olditerate, newiterate, fixed_dofs) that returns the new damping value. Default: 0\ntime: time at which time-dependent data functions are evaluated or initial time for TimeControlSolver. Default: 0\nshowsolverconfig: show the complete solver configuration before starting to solve. Default: false\nanderson_damping: Damping factor in Anderson acceleration (1 = undamped). Default: 1\nchecknonlinearresidual: check the nonlinear residual in last nonlinear iteration (causes one more reassembly of nonlinear terms). Default: ''auto''\nfixed_penalty: penalty that is used for the values of fixed degrees of freedom (e.g. by Dirichlet boundary data or global constraints). Default: 1.0e60\ntarget_residual: stop fixpoint iterations if the (nonlinear) residual is smaller than this number. Default: 1.0e-10\nmaxiterations: maximal number of nonlinear iterations (TimeControlSolver runs that many in each time step). Default: ''auto''\n\nDepending on the subiterations and detected/configured nonlinearities the whole system is either solved directly in one step or via a fixed-point iteration.\n\n\n\n\n\n","category":"function"},{"location":"pdesolvers/#Anderson-acceleration","page":"Fixed-Time Solvers","title":"Anderson acceleration","text":"","category":"section"},{"location":"pdesolvers/","page":"Fixed-Time Solvers","title":"Fixed-Time Solvers","text":"Fixpoint iterations my be accelerated by Anderson acceleration. Concepts and some theoretical background can be found in the reference below. Within this package, Anderson acceleration can be triggered by optional solver arguments: the user can specify the depth of the Anderson acceleration (anderson_iterations), the damping within the Anderson iteration (anderson_damping), the ids of the unknowns that should be included in the iteration (anderson_unknowns) and the convergence metric (anderson_metric); also see above for a full list of optional solver arguments. In case of subiterations, the Anderson iteration will be called as a postprocessing after the final subiteration.","category":"page"},{"location":"pdesolvers/","page":"Fixed-Time Solvers","title":"Fixed-Time Solvers","text":"Reference:","category":"page"},{"location":"pdesolvers/","page":"Fixed-Time Solvers","title":"Fixed-Time Solvers","text":"\"A Proof That Anderson Acceleration Improves the Convergence Rate in Linearly Converging Fixed-Point Methods (But Not in Those Converging Quadratically)\",\nC. Evans, S. Pollock, L. Rebholz, and M. Xiao,\nSIAM J. Numer. Anal., 58(1) (2020),\n>Journal-Link<","category":"page"},{"location":"examples/Example302_BestapproximationHdiv3D/#:-Bestapproximation-Hdiv-3D","page":"302 : Bestapproximation Hdiv 3D","title":"302 : Bestapproximation Hdiv 3D","text":"","category":"section"},{"location":"examples/Example302_BestapproximationHdiv3D/","page":"302 : Bestapproximation Hdiv 3D","title":"302 : Bestapproximation Hdiv 3D","text":"(source code)","category":"page"},{"location":"examples/Example302_BestapproximationHdiv3D/","page":"302 : Bestapproximation Hdiv 3D","title":"302 : Bestapproximation Hdiv 3D","text":"This example computes the L2-bestapproximation of some given vector-valued function into an Hdiv-conforming finite element space. It also preserves the divergence of the function in the sense that the divergence of the approximation equals the piecewise integral mean of the exact divergence. Afterwards the L2 error (also of the divergence) is computed.","category":"page"},{"location":"examples/Example302_BestapproximationHdiv3D/","page":"302 : Bestapproximation Hdiv 3D","title":"302 : Bestapproximation Hdiv 3D","text":"module Example302_BestapproximationHdiv3D\n\nusing GradientRobustMultiPhysics\nusing ExtendableGrids\nusing GridVisualize\n\n# define some vector field that should be approximated\nfunction exact_function!(result,x)\n    result[1] = x[1]^3+x[3]^2\n    result[2] = -x[1]^2 + x[2] + 1\n    result[3] = x[1]*x[2]\nend\n# define its divergence\nfunction exact_divergence!(result,x)\n    result[1] = 3*x[1]*x[1] + 1\nend\n\nconst u = DataFunction(exact_function!, [3,3]; name = \"u\", dependencies = \"X\", quadorder = 3)\nconst div_u = DataFunction(exact_divergence!, [1,3]; name = \"div(u)\", dependencies = \"X\", quadorder = 2)\n\n# everything is wrapped in a main function\nfunction main(; verbosity = 0, Plotter = nothing)\n\n    # set log level\n    set_verbosity(verbosity)\n\n    # generate a unit square mesh and refine\n    xgrid = uniform_refine(reference_domain(Tetrahedron3D),4)\n\n    # setup a bestapproximation problem via a predefined prototype\n    Problem = L2BestapproximationProblem(u; bestapprox_boundary_regions = [])\n\n    # add a new unknown (Lagrange multiplier that handles the divergence constraint)\n    # here 1 is the number of components (it is scalarvalued) and 3 is the space dimension\n    add_unknown!(Problem; unknown_name = \"p\", equation_name = \"divergence constraint\")\n    add_operator!(Problem, [1,2], LagrangeMultiplier(Divergence))\n\n    # add the right-hand side data for the constraint and inspect the defined problem\n    add_rhsdata!(Problem, 2, RhsOperator(Identity, [0], div_u))\n    @show Problem\n\n    # choose some (inf-sup stable) finite element types\n    #FEType = [HDIVRT0{3}, H1P0{1}]\n    FEType = [HDIVBDM1{3}, H1P0{1}]\n    FES = [FESpace{FEType[1]}(xgrid),FESpace{FEType[2]}(xgrid; broken = true)]\n\n    # create a solution vector and solve the problem\n    Solution = FEVector{Float64}([\"u_h\",\"p_h\"],FES)\n    solve!(Solution, Problem)\n\n    # plot\n    p = GridVisualizer(; Plotter = Plotter, layout = (1,2), clear = true, resolution = (1000,500))\n    scalarplot!(p[1,1], xgrid, view(nodevalues(Solution[1]; abs = true),1,:), levels = 5, title = \"u_h (abs)\")\n    scalarplot!(p[1,2], xgrid, view(nodevalues(Solution[1], Divergence),1,:), levels = 5, title = \"div(u_h)\")\n\n    # calculate L2 error and L2 divergence error\n    L2Error = L2ErrorIntegrator(Float64, u, Identity)\n    L2DivergenceError = L2ErrorIntegrator(Float64, div_u, Divergence)\n    println(\"\\tL2error(Id) = $(sqrt(evaluate(L2Error,Solution[1])))\")\n    println(\"\\tL2error(div) = $(sqrt(evaluate(L2DivergenceError,Solution[1])))\")\nend\n\nend","category":"page"},{"location":"examples/Example302_BestapproximationHdiv3D/","page":"302 : Bestapproximation Hdiv 3D","title":"302 : Bestapproximation Hdiv 3D","text":"","category":"page"},{"location":"examples/Example302_BestapproximationHdiv3D/","page":"302 : Bestapproximation Hdiv 3D","title":"302 : Bestapproximation Hdiv 3D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example302_BestapproximationHdiv3D/","page":"302 : Bestapproximation Hdiv 3D","title":"302 : Bestapproximation Hdiv 3D","text":"Default output:","category":"page"},{"location":"examples/Example302_BestapproximationHdiv3D/","page":"302 : Bestapproximation Hdiv 3D","title":"302 : Bestapproximation Hdiv 3D","text":"julia> Example302_BestapproximationHdiv3D.main()\n\nPDE-DESCRIPTION\n===============\n  system name = L2-Bestapproximation problem\n\n     id   | unknown name / equation name\n    [1]   | u / L2-bestapproximation equation \n    [2]   | p / divergence constraint \n\n  LHS block | PDEOperator(s)\n    [1,1]   | (u,v) (APT = SymmetricBilinearForm, AT = ON_CELLS, regions = [0])\n    [1,2]   | (div(v),q) (APT = BilinearForm, AT = ON_CELLS, regions = [0])\n    [2,1]   | none\n    [2,2]   | none\n\n  RHS block | PDEOperator(s)\n     [1]    | (u, id(v)) (APT = LinearForm, AT = ON_CELLS, regions = [0])\n     [2]    | (div(u), id(v)) (APT = LinearForm, AT = ON_CELLS, regions = [0])\n\n   BoundaryOperator[1] : \n   BoundaryOperator[2] : \n\nProblem = \n\tL2error(Id) = 0.0001770647462745962\n\tL2error(div) = 0.009878280436234932","category":"page"},{"location":"examples/Example302_BestapproximationHdiv3D/","page":"302 : Bestapproximation Hdiv 3D","title":"302 : Bestapproximation Hdiv 3D","text":"(Image: )","category":"page"},{"location":"timecontrolsolver/#Time-Dependent-Solvers","page":"Time-Dependent Solvers","title":"Time-Dependent Solvers","text":"","category":"section"},{"location":"timecontrolsolver/#TimeControlSolver","page":"Time-Dependent Solvers","title":"TimeControlSolver","text":"","category":"section"},{"location":"timecontrolsolver/","page":"Time-Dependent Solvers","title":"Time-Dependent Solvers","text":"The structure TimeControlSolver can be used to setup a time-dependent solver that can be configured in a similar manner as the time-independent ones (subiterations, nonlinear iterations, linear solvers). The following table lists the available TimeIntegrationRules:","category":"page"},{"location":"timecontrolsolver/","page":"Time-Dependent Solvers","title":"Time-Dependent Solvers","text":"Time integration rule order Formula\nBackwardEuler 1 (M^n+1 + A^n+1) u^n+1 = F^n+1 + M^n+1 u^n\nCrankNicolson 2 (M^n+1 + A^n+1) u^n+1 = F^n+1 + F^n - A^n u^n + M^n+1 u^n","category":"page"},{"location":"timecontrolsolver/","page":"Time-Dependent Solvers","title":"Time-Dependent Solvers","text":"Note that currently the time-derivative (M terms) is added by the TimeControlSolver in each integration step and is in general not part of the PDEDescription (this might change in future). The default time derivative is a scaled (depends on the integration rule) mass matrix of the used finite element space, but the user can overwrite it via optional constructor arguments (experimental).","category":"page"},{"location":"timecontrolsolver/","page":"Time-Dependent Solvers","title":"Time-Dependent Solvers","text":"In case of the Crank-Nicolson scheme the user can mask unknowns of the PDE as an algebraic constraint (see add_unknown! in ProblemDescription). For these variables old iterates are not used on the right-hand side of the iteration formula. The pressure in the Navier-Stokes system is an example for such a constraint.","category":"page"},{"location":"timecontrolsolver/","page":"Time-Dependent Solvers","title":"Time-Dependent Solvers","text":"TimeControlSolver\nadvance!","category":"page"},{"location":"timecontrolsolver/#GradientRobustMultiPhysics.TimeControlSolver","page":"Time-Dependent Solvers","title":"GradientRobustMultiPhysics.TimeControlSolver","text":"function TimeControlSolver(\n    PDE::PDEDescription,                                        # PDE system description\n    InitialValues::FEVector{T,Tv,Ti},                           # contains initial values and stores solution of advance! methods\n    TIR::Type{<:AbstractTimeIntegrationRule} = BackwardEuler;   # Time integration rule\n    dt_operator = [],                                           # Operator in time derivative (default: Identity) for each subiteration (applied to test and ansatz function)\n    dt_action = [],                                             # Action in time derivative (deulta: NoAction) for each subiteration\n    dt_is_nonlinear = [],                                          # is the time derivative nonlinear?\n    T_time = Float64,                                           # Type for timestep and total time\n    kwargs...) where {T,Tv,Ti}                                  # additional solver arguments\n\nCreates a time-dependent solver that can be advanced in time with advance!. The FEVector Solution stores the initial state but also the solution at the current time. The argument TIR carries the time integration rule to be use (e.g. BackwardEuler or CrankNicolson). T_time determines the NumberType of the timesteps and total time.\n\nKeyword arguments:\n\nsubiterations: an array of equation subsets (each an array) that should be solved together in each fixpoint iteration. Default: ''auto''\nshowiterationdetails: show details (residuals etc.) of each iteration. Default: true\ntimedependent_equations: array of the equations that should get a time derivative (only for TimeControlSolver). Default: Any[]\nshow_statistics: show some statistics like assembly times. Default: false\nskipupdate: matrix update (for the j-th sub-iteration) will be performed each skipupdate[j] iteration; -1 means only in the first iteration. Default: [1]\nlinsolver: String that encodes the linear solver, or type name of self-defined solver (see corressponding example), or type name of ExtendableSparse.AbstractFactorization. Default: ''UMFPACK''\ntime: time at which time-dependent data functions are evaluated or initial time for TimeControlSolver. Default: 0\nshowsolverconfig: show the complete solver configuration before starting to solve. Default: false\nchecknonlinearresidual: check the nonlinear residual in last nonlinear iteration (causes one more reassembly of nonlinear terms). Default: ''auto''\nfixed_penalty: penalty that is used for the values of fixed degrees of freedom (e.g. by Dirichlet boundary data or global constraints). Default: 1.0e60\ntarget_residual: stop fixpoint iterations if the (nonlinear) residual is smaller than this number. Default: 1.0e-10\nmaxiterations: maximal number of nonlinear iterations (TimeControlSolver runs that many in each time step). Default: ''auto''\n\nFurther (very experimental) optional arguments for TimeControlSolver are:\n\ndt_operator : (array of) operators applied to testfunctions in time derivative (default: Identity)\ndt_action : (array of) actions that are applied to the ansatz function in the time derivative (to include parameters etc.)\ndtisnonlinear : (array of) booleans to decide which time derivatives should be recomputed in each timestep\n\n\n\n\n\n","category":"type"},{"location":"timecontrolsolver/#GradientRobustMultiPhysics.advance!","page":"Time-Dependent Solvers","title":"GradientRobustMultiPhysics.advance!","text":"function TimeControlSolver(\n    advance!(TCS::TimeControlSolver, timestep::Real = 1e-1)\n\nAdvances a TimeControlSolver one step in time with the given timestep.\n\n\n\n\n\n","category":"function"},{"location":"timecontrolsolver/#Advancing-a-TimeControlSolver","page":"Time-Dependent Solvers","title":"Advancing a TimeControlSolver","text":"","category":"section"},{"location":"timecontrolsolver/","page":"Time-Dependent Solvers","title":"Time-Dependent Solvers","text":"There are two functions that advance the TimeControlSolver automatically until a given final time (advance_until_time!) is reached or until stationarity is reached (advance_until_stationarity!). As an experimental feature, one can add the module DifferentialEquations.jl as the first argument to these methods to let this module run the time integration (the native TimeIntegrationRule argument in the TimeControlSolver constuctor is ignored in this case).","category":"page"},{"location":"timecontrolsolver/","page":"Time-Dependent Solvers","title":"Time-Dependent Solvers","text":"advance_until_time!\nadvance_until_stationarity!","category":"page"},{"location":"timecontrolsolver/#GradientRobustMultiPhysics.advance_until_time!","page":"Time-Dependent Solvers","title":"GradientRobustMultiPhysics.advance_until_time!","text":"advance_until_time!(TCS::TimeControlSolver, timestep, finaltime; finaltime_tolerance = 1e-15, do_after_each_timestep = nothing)\n\nAdvances a TimeControlSolver in time with the given (initial) timestep until the specified finaltime is reached (up to the specified tolerance). The function doaftertimestep is called after each timestep and can be used to print/save data (and maybe timestep control in future).\n\n\n\n\n\nadvance_until_time!(DiffEQ::Module, TCS::TimeControlSolver, timestep, finaltime; solver = nothing, abstol = 1e-1, reltol = 1e-1, dtmin = 0, adaptive::Bool = true)\n\nAdvances a TimeControlSolver in time with the given (initial) timestep until the specified finaltime is reached (up to the specified tolerance) with the given exterior time integration module. The only valid Module here is DifferentialEquations.jl and the optional arguments are passed to it. If solver == nothing the solver Rosenbrock23(autodiff = false) will be chosen. For more choices please consult the documentation of DifferentialEquations.jl.\n\nAlso note that this is a highly experimental feature and will not work for general TimeControlSolvers configuration (e.g. in the case of several subiterations or, it seems, saddle point problems). Also have a look at corressponding the example in the advanced examples section.\n\n\n\n\n\n","category":"function"},{"location":"timecontrolsolver/#GradientRobustMultiPhysics.advance_until_stationarity!","page":"Time-Dependent Solvers","title":"GradientRobustMultiPhysics.advance_until_stationarity!","text":"advance_until_stationarity!(TCS::TimeControlSolver, timestep; stationarity_threshold = 1e-11, maxTimeSteps = 100, do_after_each_timestep = nothing)\n\nAdvances a TimeControlSolver in time with the given (initial) timestep until stationarity is detected (change of variables below threshold) or a maximal number of time steps is exceeded. The function doaftertimestep is called after each timestep and can be used to print/save data (and maybe timestep control in future).\n\n\n\n\n\n","category":"function"}]
}
