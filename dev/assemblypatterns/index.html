<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Assembly Patterns · GradientRobustMultiPhysics.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GradientRobustMultiPhysics.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../package_index/">Index</a></li><li><span class="tocitem">Problem Description</span><ul><li><a class="tocitem" href="../pdedescription/">PDE Description</a></li><li><a class="tocitem" href="../pdeoperators/">PDE Operators</a></li><li><a class="tocitem" href="../functionoperators/">Function Operators</a></li><li><a class="tocitem" href="../userdata/">User Data and Actions</a></li><li><a class="tocitem" href="../boundarydata/">Boundary Data</a></li><li><a class="tocitem" href="../globalconstraints/">Global Constraints</a></li><li><a class="tocitem" href="../pdeprototypes/">PDE Prototypes</a></li></ul></li><li><span class="tocitem">Discretisation</span><ul><li><a class="tocitem" href="../meshing/">Meshing</a></li><li><a class="tocitem" href="../fems/">Implemented Finite Elements</a></li><li><a class="tocitem" href="../fespace/">Finite Element Spaces and Arrays</a></li><li><a class="tocitem" href="../interpolations/">Finite Element Interpolations</a></li></ul></li><li><span class="tocitem">Solving</span><ul><li><a class="tocitem" href="../pdesolvers/">Fixed-Time Solvers</a></li><li><a class="tocitem" href="../timecontrolsolver/">Time-Dependent Solvers</a></li></ul></li><li><span class="tocitem">Postprocessing</span><ul><li><a class="tocitem" href="../itemintegrators/">Item Integrators</a></li><li><a class="tocitem" href="../pointevaluators/">Point Evaluators</a></li><li><a class="tocitem" href="../viewers/">Viewers</a></li><li><a class="tocitem" href="../export/">Data Export</a></li></ul></li><li><span class="tocitem">Low-Level Structures</span><ul><li><a class="tocitem" href="../quadrature/">Quadrature</a></li><li class="is-active"><a class="tocitem" href>Assembly Patterns</a></li><li><a class="tocitem" href="../febasisevaluators/">FE Basis Evaluators</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples_intro/">About the examples</a></li><li><a class="tocitem" href="../examples/Example101_Bestapproximation1D/">101 : L2-Bestapproximation 1D</a></li><li><a class="tocitem" href="../examples/Example102_RobinBoundaryCondition1D/">102 : Robin-Boundary Conditions 1D</a></li><li><a class="tocitem" href="../examples/Example201_PoissonProblem2D/">201 : Poisson-Problem 2D</a></li><li><a class="tocitem" href="../examples/Example202_LinearElasticity2D/">202 : Linear Elasticity</a></li><li><a class="tocitem" href="../examples/Example203_ReactionConvectionDiffusion2D/">203 : Reaction-Convection-Diffusion-Problem 2D</a></li><li><a class="tocitem" href="../examples/Example204_ReactionConvectionDiffusionSUPG2D/">204 : Reaction-Convection-Diffusion-Problem SUPG 2D</a></li><li><a class="tocitem" href="../examples/Example205_NonlinearPoisson2D/">205 : Nonlinear Poisson Problem 2D</a></li><li><a class="tocitem" href="../examples/Example206_NonlinearPoissonTransient2D/">206 : Nonlinear Poisson Transient 2D</a></li><li><a class="tocitem" href="../examples/Example207_NonlinearElasticityBimetal2D/">207 : Nonlinear Elasticity Bimetal 2D</a></li><li><a class="tocitem" href="../examples/Example208_ObstacleProblem2D/">208 : Obstacle Problem 2D</a></li><li><a class="tocitem" href="../examples/Example209_FaceLagrangeMultiplier2D/">209 : Lagrange Multiplier on Faces</a></li><li><a class="tocitem" href="../examples/Example210_PoissonLshapeAdaptive2D/">210 : Poisson L-shape Adaptive Mesh Refinement</a></li><li><a class="tocitem" href="../examples/Example212_WaveEquation2D/">212 : Wave Equation 2D</a></li><li><a class="tocitem" href="../examples/Example215_TwoNonlinearCoupled2D/">215 : Two nonlinearly coupled PDEs (2D)</a></li><li><a class="tocitem" href="../examples/Example220_PlanarLatticeFlow2D/">220 : Planar Lattice Flow 2D</a></li><li><a class="tocitem" href="../examples/Example221_StokesIterated2D/">221 : Stokes iterated penalty method 2D</a></li><li><a class="tocitem" href="../examples/Example222_PressureRobustness2D/">222 : Pressure-robustness 2D</a></li><li><a class="tocitem" href="../examples/Example223_StokesHdivDG2D/">223 : Stokes Hdiv-DG 2D</a></li><li><a class="tocitem" href="../examples/Example224_StokesHdivP1RT/">224 : Stokes <span>$(P1 \oplus RT0) \times P0$</span></a></li><li><a class="tocitem" href="../examples/Example225_NavierStokesAnderson2D/">225 : Navier-Stokes Lid-driven cavity + Anderson Acceleration</a></li><li><a class="tocitem" href="../examples/Example226_StokesTransient2D/">226 : Stokes Transient 2D</a></li><li><a class="tocitem" href="../examples/Example227_FlowTransport2D/">227 : Flow + Transport 2D</a></li><li><a class="tocitem" href="../examples/Example230_FlowAroundCylinder2D/">230 : Flow around a cylinder 2D</a></li><li><a class="tocitem" href="../examples/Example231_TransientFlowAroundCylinder2D/">231 : Transient Flow around a cylinder 2D</a></li><li><a class="tocitem" href="../examples/Example235_NaturalConvectionTriangle2D/">235 : Natural Convection Triangle 2D</a></li><li><a class="tocitem" href="../examples/Example236_NaturalConvectionSquare2D/">236 : Natural Convection Square 2D</a></li><li><a class="tocitem" href="../examples/Example240_CompressibleStokes2D/">240 : Compressible Stokes 2D</a></li><li><a class="tocitem" href="../examples/Example250_LevelSetMethod2D/">250 : Level Set Method 2D</a></li><li><a class="tocitem" href="../examples/Example260_CahnHilliard2D/">260 : Cahn-Hilliard Equations 2D</a></li><li><a class="tocitem" href="../examples/Example301_Poisson3D/">301 : Poisson-Problem 3D</a></li><li><a class="tocitem" href="../examples/Example302_BestapproximationHdiv3D/">302 : Bestapproximation Hdiv 3D</a></li><li><a class="tocitem" href="../examples/ExampleA01_RationalMassMatrix/">A01 : Rational Mass Matrix</a></li><li><a class="tocitem" href="../examples/ExampleA02_CommutingInterpolators2D/">A02 : Commuting Interpolators 2D</a></li><li><a class="tocitem" href="../examples/ExampleA03_CommutingInterpolators3D/">A03 : Commuting Interpolators 3D</a></li><li><a class="tocitem" href="../examples/ExampleA04_CustomLinearSolver/">A04 : Custom Linear Solvers</a></li><li><a class="tocitem" href="../examples/ExampleA05_DiffEQ/">A05 : Comparison with DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples/ExampleA06_LocalEquilibratedFluxes2D/">A06 : Local Equilibrated Fluxes 2D</a></li><li><a class="tocitem" href="../examples/ExampleA07_InterpolationBetweenMeshes/">A07 : Interpolation Between Meshes</a></li><li><a class="tocitem" href="../examples/ExampleA08_BasisPlotter/">A08 : Basis-Plotter</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Low-Level Structures</a></li><li class="is-active"><a href>Assembly Patterns</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Assembly Patterns</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/master/docs/src/assemblypatterns.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Assembly-Patterns"><a class="docs-heading-anchor" href="#Assembly-Patterns">Assembly Patterns</a><a id="Assembly-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly-Patterns" title="Permalink"></a></h1><p>The definition and assembly of an operator is essentially based on Assembly Patterns and a <a href="../pdeoperators/#Assembly-Type">Assembly Type</a> to choose the geometry information needed for providing quadrature and dof handling. The assembly pattern then basically evaluates the function operators and action for the ansatz and test functions and does the quadrature-weighted accumulation into matrices or vectors that represent the operators.</p><p>Each pattern comes with a number of arguments/quantities with associated <a href="../functionoperators/#Function-Operators">Function Operators</a> as well as one of the <a href="../pdeoperators/#Assembly-Type">Assembly Type</a> that states whether the form is evaluated over CELLS, FACES order BFACES (see above). Important note: this assembly type is relative to the grid of the first argument of the pattern. If this argument already lives ON<em>FACES and the pattern is also ON</em>FACES, it will ultimatively assemble on the faces of the faces (that are the edges of the grid with these faces). Moreover, patterns can have an <a href="../userdata/#Action">Action</a> that allow to make the evaluations parameter-, region- and/or function-dependent. Each pattern then has usually on to three implementation that writes into FEMatrix or FEVector (where e.g. a subset of arguments is fixed) or evaluates the pattern in the given FEVectorBlocks.</p><p>The patterns are used to assembly the PDE operators defined in a <a href="../pdedescription/#PDE-Description">PDE Description</a>.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.AssemblyPattern" href="#GradientRobustMultiPhysics.AssemblyPattern"><code>GradientRobustMultiPhysics.AssemblyPattern</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct AssemblyPattern{APT&lt;:AssemblyPatternType, T&lt;:Real, AT&lt;:AssemblyType, Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:Union{AbstractAction, GradientRobustMultiPhysics.AbstractNonlinearFormHandler}}</code></pre><p>each assembly pattern has one of the assembly pattern types (APT) that trigger different assemblies for the involved finite element spaces, operators and an assigned action. The assembly type (AT) determines if the assembly takes place on cells, faces or edges etc. (relatively to the assembly type of the first argument of the pattern)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns.jl#L301">source</a></section></article><p>The following table lists all available assembly patterns, their constuctor names and how they can be used for assembly or evaluations.</p><table><tr><th style="text-align: left">AssemblyPatternType</th><th style="text-align: left">constructor</th><th style="text-align: center">evaluate</th><th style="text-align: center">assembles into matrix</th><th style="text-align: center">assembles into vector</th></tr><tr><td style="text-align: left">APT_ItemIntegrator</td><td style="text-align: left">ItemIntegrator</td><td style="text-align: center">yes</td><td style="text-align: center">no</td><td style="text-align: center">no</td></tr><tr><td style="text-align: left">APT_LinearForm</td><td style="text-align: left">LinearForm</td><td style="text-align: center">no</td><td style="text-align: center">no</td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left">APT_BilinearForm</td><td style="text-align: left">BilinearForm</td><td style="text-align: center">no</td><td style="text-align: center">yes</td><td style="text-align: center">no</td></tr><tr><td style="text-align: left">APT_NonlinearForm</td><td style="text-align: left">NonlinearForm</td><td style="text-align: center">no</td><td style="text-align: center">yes</td><td style="text-align: center">yes</td></tr></table><p>Evaluations of the other AssemblyPatterns may be possible in a future update, but currently have to be performed by maintaining a duplicate of the pattern rewritten as an ItemIntegrator.</p><h4 id="Constructor-details"><a class="docs-heading-anchor" href="#Constructor-details">Constructor details</a><a id="Constructor-details-1"></a><a class="docs-heading-anchor-permalink" href="#Constructor-details" title="Permalink"></a></h4><p>Below all assembly pattern types, constructor functions and evaluate/assembly functions are detailed. (For more info on the ItemIntegrator also see <a href="../itemintegrators/#Item-Integrators">Item Integrators</a>.)</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.APT_ItemIntegrator" href="#GradientRobustMultiPhysics.APT_ItemIntegrator"><code>GradientRobustMultiPhysics.APT_ItemIntegrator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type APT_ItemIntegrator &lt;: AssemblyPatternType</code></pre><p>itemintegrator assembly pattern type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns/itemintegrator.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ItemIntegrator" href="#GradientRobustMultiPhysics.ItemIntegrator"><code>GradientRobustMultiPhysics.ItemIntegrator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ItemIntegrator(operators) -&gt; GradientRobustMultiPhysics.AssemblyPattern{ItemIntegrator, Float64, ON_CELLS, Float64, Int32, NoAction}
ItemIntegrator(operators, action; T, AT, regions, name) -&gt; GradientRobustMultiPhysics.AssemblyPattern{ItemIntegrator, Float64, ON_CELLS, Float64, Int32}
</code></pre><p>Creates an ItemIntegrator assembly pattern based on:</p><ul><li>operators : operators that should be evaluated for the coressponding FESpace (last one refers to test function)</li><li>action    : an Action with kernel of interface (result, input, kwargs) that takes input (= all but last operator evaluations) and computes result to be dot-producted with test function evaluation             (if no action is specified, the full input vector is dot-producted with the test function operator evaluation)</li></ul><p>Optional arguments:</p><ul><li>T         : expected NumberType for evaluation output</li><li>AT        : specifies on which entities of the grid the ItemINtegrator is evaluated</li><li>regions   : specifies in which regions the operator should assemble, default [0] means all regions</li><li>name      : name for this LinearForm that is used in print messages</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns/itemintegrator.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.L2DifferenceIntegrator-Tuple{Int64, Any}" href="#GradientRobustMultiPhysics.L2DifferenceIntegrator-Tuple{Int64, Any}"><code>GradientRobustMultiPhysics.L2DifferenceIntegrator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">L2DifferenceIntegrator(ncomponents::Int64, operator; AT, T, name, quadorder, regions) -&gt; GradientRobustMultiPhysics.AssemblyPattern{ItemIntegrator, _A, _B, Float64, Int32} where {_A&lt;:Real, _B&lt;:AssemblyType}
</code></pre><p>Creates an ItemIntegrator that computes the L2 norm difference between two arguments evalauted with the same operator (or with different operators if operator is an array) where ncomponents is the expected length of each operator evaluation. Note that all arguments in an evaluation call need to be defined on the same grid !</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns/itemintegrator.jl#L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.L2ErrorIntegrator" href="#GradientRobustMultiPhysics.L2ErrorIntegrator"><code>GradientRobustMultiPhysics.L2ErrorIntegrator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">L2ErrorIntegrator(compare_data::GradientRobustMultiPhysics.AbstractUserDataType) -&gt; GradientRobustMultiPhysics.AssemblyPattern{ItemIntegrator, _A, _B, Float64, Int32} where {_A&lt;:Real, _B&lt;:AssemblyType}
L2ErrorIntegrator(compare_data::GradientRobustMultiPhysics.AbstractUserDataType, operator; T, quadorder, name, AT, factor, regions, time) -&gt; GradientRobustMultiPhysics.AssemblyPattern{ItemIntegrator, _A, _B, Float64, Int32} where {_A&lt;:Real, _B&lt;:AssemblyType}
</code></pre><p>Creates an ItemIntegrator that compares discrete FEVectorBlock operator-evaluations against the given compare<em>data and returns the L2-error || compare</em>data(x) - factor*discrete(x) ||. If quadorder is left on &quot;auto&quot; two times the quadorder of the data is used in the evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns/itemintegrator.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.L2NormIntegrator-Tuple{Int64, Any}" href="#GradientRobustMultiPhysics.L2NormIntegrator-Tuple{Int64, Any}"><code>GradientRobustMultiPhysics.L2NormIntegrator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">L2NormIntegrator(ncomponents::Int64, operator; T, AT, name, quadorder, regions) -&gt; GradientRobustMultiPhysics.AssemblyPattern{ItemIntegrator, _A, _B, Float64, Int32} where {_A&lt;:Real, _B&lt;:AssemblyType}
</code></pre><p>Creates an ItemIntegrator that computes the L2 norm of an operator evaluation where ncomponents is the expected length of the operator evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns/itemintegrator.jl#L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.evaluate!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractMatrix{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT}, Union{FEVector{T, Tv, Ti}, Vector{&lt;:FEVectorBlock{T, Tv, Ti}}, FEVectorBlock{T, Tv, Ti}}}} where {APT&lt;:ItemIntegrator, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}" href="#GradientRobustMultiPhysics.evaluate!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractMatrix{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT}, Union{FEVector{T, Tv, Ti}, Vector{&lt;:FEVectorBlock{T, Tv, Ti}}, FEVectorBlock{T, Tv, Ti}}}} where {APT&lt;:ItemIntegrator, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}"><code>GradientRobustMultiPhysics.evaluate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function evaluate!(
    b::AbstractArray{T,2},
    AP::AssemblyPattern{APT,T,AT},
    FEB::Union{&lt;:FEVector{T,Tv,Ti},&lt;:FEVectorBlock{T,Tv,Ti},Array{&lt;:FEVectorBlock{T,Tv,Ti},1}};
    skip_preps::Bool = false) where {APT &lt;: APT_ItemIntegrator, T&lt;: Real, AT &lt;: AssemblyType, Tv, Ti}</code></pre><p>Evaluation of an ItemIntegrator assembly pattern with given FEVectorBlock or FEVector FEB into given two-dimensional Array b.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns/itemintegrator.jl#L158-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.evaluate-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT}, Union{FEVector{T, Tv, Ti}, Vector{&lt;:FEVectorBlock{T, Tv, Ti}}, FEVectorBlock{T, Tv, Ti}}}} where {APT&lt;:ItemIntegrator, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}" href="#GradientRobustMultiPhysics.evaluate-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT}, Union{FEVector{T, Tv, Ti}, Vector{&lt;:FEVectorBlock{T, Tv, Ti}}, FEVectorBlock{T, Tv, Ti}}}} where {APT&lt;:ItemIntegrator, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}"><code>GradientRobustMultiPhysics.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function evaluate(
    AP::AssemblyPattern{APT,T,AT},
    FEB::Union{&lt;:FEVector{T,Tv,Ti},&lt;:FEVectorBlock{T,Tv,Ti},Array{&lt;:FEVectorBlock{T,Tv,Ti},1}};
    skip_preps::Bool = false) where {APT &lt;: APT_ItemIntegrator, T&lt;: Real, AT &lt;: AssemblyType, Tv, Ti}
</code></pre><p>Evaluation of an ItemIntegrator assembly pattern with given FEVectorBlock or FEVector FEB, only returns accumulation over all items.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns/itemintegrator.jl#L312-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.APT_BilinearForm" href="#GradientRobustMultiPhysics.APT_BilinearForm"><code>GradientRobustMultiPhysics.APT_BilinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type APT_BilinearForm &lt;: AssemblyPatternType</code></pre><p>bilinearform assembly pattern type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns/bilinearform.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.APT_LinearForm" href="#GradientRobustMultiPhysics.APT_LinearForm"><code>GradientRobustMultiPhysics.APT_LinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type APT_LinearForm &lt;: AssemblyPatternType</code></pre><p>linearform assembly pattern type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns/linearform.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.APT_LumpedBilinearForm" href="#GradientRobustMultiPhysics.APT_LumpedBilinearForm"><code>GradientRobustMultiPhysics.APT_LumpedBilinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type APT_LumpedBilinearForm &lt;: BilinearForm</code></pre><p>lumped bilinearform assembly pattern type where only the diagonal elements on each item are assembled</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns/bilinearform.jl#L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.APT_NonlinearForm" href="#GradientRobustMultiPhysics.APT_NonlinearForm"><code>GradientRobustMultiPhysics.APT_NonlinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type APT_NonlinearForm &lt;: AssemblyPatternType</code></pre><p>nonlinearform assembly pattern type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns/nonlinearform.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.APT_SymmetricBilinearForm" href="#GradientRobustMultiPhysics.APT_SymmetricBilinearForm"><code>GradientRobustMultiPhysics.APT_SymmetricBilinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type APT_SymmetricBilinearForm &lt;: BilinearForm</code></pre><p>symmetric bilinearform assembly pattern type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns/bilinearform.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.DiscreteBilinearForm" href="#GradientRobustMultiPhysics.DiscreteBilinearForm"><code>GradientRobustMultiPhysics.DiscreteBilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">DiscreteBilinearForm(operators, FES) -&gt; GradientRobustMultiPhysics.AssemblyPattern{BilinearForm, Float64, ON_CELLS, _A, _B, NoAction} where {_A&lt;:Real, _B&lt;:Integer}
DiscreteBilinearForm(operators, FES, action; T, AT, name, regions, apply_action_to) -&gt; GradientRobustMultiPhysics.AssemblyPattern{BilinearForm, Float64, ON_CELLS}
</code></pre><p>Creates a (discrete) BilinearForm assembly pattern based on:</p><ul><li>operators : operators that should be evaluated for the coressponding FESpace (last two refer to ansatz and test function)</li><li>FES       : FESpaces for each operator (last two refer to ansatz and test function)</li><li>action    : an Action with kernel of interface (result, input, kwargs) that takes input (= all but last operator evaluations) and computes result to be dot-producted with test function evaluation             (if no action is specified, the full input vector is dot-producted with the test function operator evaluation)</li></ul><p>Optional arguments:</p><ul><li>apply<em>action</em>to : specifies which of the two linear arguments is part of the action input ([1] = ansatz, [2] = test)</li><li>regions   : specifies in which regions the operator should assemble, default [0] means all regions</li><li>name      : name for this LinearForm that is used in print messages</li><li>AT        : specifies on which entities of the grid the LinearForm is assembled (default: ON_CELLS)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns/bilinearform.jl#L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.DiscreteLinearForm-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Any, Vector{&lt;:FESpace{Tv, Ti}}}, Tuple{Any, Vector{&lt;:FESpace{Tv, Ti}}, Any}} where {Tv, Ti}" href="#GradientRobustMultiPhysics.DiscreteLinearForm-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Any, Vector{&lt;:FESpace{Tv, Ti}}}, Tuple{Any, Vector{&lt;:FESpace{Tv, Ti}}, Any}} where {Tv, Ti}"><code>GradientRobustMultiPhysics.DiscreteLinearForm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DiscreteLinearForm(operators, FES::Array{&lt;:FESpace{Tv, Ti}, 1}) -&gt; GradientRobustMultiPhysics.AssemblyPattern{LinearForm, Float64, ON_CELLS, _A, _B, NoAction} where {_A&lt;:Real, _B&lt;:Integer}
DiscreteLinearForm(operators, FES::Array{&lt;:FESpace{Tv, Ti}, 1}, action; T, AT, regions, name) -&gt; GradientRobustMultiPhysics.AssemblyPattern{LinearForm, Float64, ON_CELLS}
</code></pre><p>Creates a (discrete) LinearForm assembly pattern based on:</p><ul><li>operators : operators that should be evaluated for the coressponding FESpace (last one refers to test function)</li><li>FES       : FESpaces for each operator (last one refers to test function)</li><li>action    : an Action with kernel of interface (result, input, kwargs) that takes input (= all but last operator evaluations) and computes result to be dot-producted with test function evaluation             (if no action is specified, the full input vector is dot-producted with the test function operator evaluation)</li></ul><p>Optional arguments:</p><ul><li>regions   : specifies in which regions the operator should assemble, default [0] means all regions</li><li>name      : name for this LinearForm that is used in print messages</li><li>AT        : specifies on which entities of the grid the LinearForm is assembled (default: ON_CELLS)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns/linearform.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.DiscreteLumpedBilinearForm" href="#GradientRobustMultiPhysics.DiscreteLumpedBilinearForm"><code>GradientRobustMultiPhysics.DiscreteLumpedBilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">DiscreteLumpedBilinearForm(operators, FES) -&gt; GradientRobustMultiPhysics.AssemblyPattern{LumpedBilinearForm, Float64, ON_CELLS, _A, _B, NoAction} where {_A&lt;:Real, _B&lt;:Integer}
DiscreteLumpedBilinearForm(operators, FES, action; T, AT, name, regions, apply_action_to) -&gt; GradientRobustMultiPhysics.AssemblyPattern{LumpedBilinearForm, Float64, ON_CELLS}
</code></pre><p>Creates a (discrete) LumpedBilinearForm assembly pattern. For more details see BilinearForm constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns/bilinearform.jl#L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.DiscreteSymmetricBilinearForm" href="#GradientRobustMultiPhysics.DiscreteSymmetricBilinearForm"><code>GradientRobustMultiPhysics.DiscreteSymmetricBilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">DiscreteSymmetricBilinearForm(operators, FES) -&gt; GradientRobustMultiPhysics.AssemblyPattern{SymmetricBilinearForm, Float64, ON_CELLS, _A, _B, NoAction} where {_A&lt;:Real, _B&lt;:Integer}
DiscreteSymmetricBilinearForm(operators, FES, action; T, AT, name, regions, apply_action_to) -&gt; GradientRobustMultiPhysics.AssemblyPattern{SymmetricBilinearForm, Float64, ON_CELLS}
</code></pre><p>Creates a (discrete) SymmetricBilinearForm assembly pattern. For more details see BilinearForm constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns/bilinearform.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractVecOrMat{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT}}, Tuple{AbstractVecOrMat{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT}, Any}} where {APT&lt;:LinearForm, T&lt;:Real, AT&lt;:AssemblyType}" href="#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractVecOrMat{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT}}, Tuple{AbstractVecOrMat{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT}, Any}} where {APT&lt;:LinearForm, T&lt;:Real, AT&lt;:AssemblyType}"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble!(
    b::Union{AbstractArray{T,1},AbstractArray{T,2}},    # target vector/matrix
    AP::AssemblyPattern{APT,T,AT};                      # LinearForm pattern
    factor = 1)                                         # factor that is multiplied
    where {APT &lt;: APT_LinearForm, T, AT}</code></pre><p>Assembly of a LinearForm pattern AP into a vector or matrix (if action is vetor-valued).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns/linearform.jl#L36-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractMatrix{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti}}, Tuple{AbstractMatrix{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti}, Any}} where {APT&lt;:BilinearForm, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}" href="#GradientRobustMultiPhysics.assemble!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractMatrix{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti}}, Tuple{AbstractMatrix{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti}, Any}} where {APT&lt;:BilinearForm, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble!(
    A::AbstractArray{T,2},                  # target matrix
    AP::AssemblyPattern{APT,T,AT};          # BilinearForm Pattern
    apply_action_to::Int = 1,               # action is applied to which argument?
    factor = 1,                             # factor that is multiplied
    transposed_assembly::Bool = false,      # transpose result?
    transpose_copy = Nothing)               # copy a transposed block to this matrix
    where {APT &lt;: APT_BilinearForm, T, AT}</code></pre><p>Assembly of a BilinearForm BLF into given two-dimensional AbstractArray (e.g. FEMatrixBlock or a ExtendableSparseMatrix).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns/bilinearform.jl#L78-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.full_assemble!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractMatrix{T}, AbstractVector{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT}, Vector{&lt;:FEVectorBlock{T, Tv, Ti}}}} where {APT&lt;:NonlinearForm, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}" href="#GradientRobustMultiPhysics.full_assemble!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractMatrix{T}, AbstractVector{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT}, Vector{&lt;:FEVectorBlock{T, Tv, Ti}}}} where {APT&lt;:NonlinearForm, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}"><code>GradientRobustMultiPhysics.full_assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">full_assemble!(
    A::AbstractArray{T,2},                 # target matrix
    b::AbstractArray{T,1},                 # target rhs
    AP::AssemblyPattern{APT,T,AT};         # NonlinearForm pattern
    FEB::Array{&lt;:FEVectorBlock,1};         # coefficients of current solution for each operator
    factor = 1,                            # factor that is multiplied
    transposed_assembly::Bool = false)     # transpose result?
    where {APT &lt;: APT_NonlinearForm, T, AT}</code></pre><p>Assembly (of Newton terms) of a NonlinearForm assembly pattern (assembles both matrix and rhs!).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/ede321644c961e5ef50852aea9b8053a010a7a31/src/assemblypatterns/nonlinearform.jl#L30-L43">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quadrature/">« Quadrature</a><a class="docs-footer-nextpage" href="../febasisevaluators/">FE Basis Evaluators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Thursday 24 March 2022 10:51">Thursday 24 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
