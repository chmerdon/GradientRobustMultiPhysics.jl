<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Assembly Patterns · GradientRobustMultiPhysics.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GradientRobustMultiPhysics.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Problem Description</span><ul><li><a class="tocitem" href="../pdedescription/">PDE Description</a></li><li><a class="tocitem" href="../pdeoperators/">PDE Operators</a></li><li><a class="tocitem" href="../functionoperators/">Function Operators</a></li><li><a class="tocitem" href="../userdata/">User Data and Actions</a></li><li><a class="tocitem" href="../boundarydata/">Boundary Data</a></li><li><a class="tocitem" href="../globalconstraints/">Global Constraints</a></li><li><a class="tocitem" href="../pdeprototypes/">PDE Prototypes</a></li></ul></li><li><span class="tocitem">Discretisation</span><ul><li><a class="tocitem" href="../meshing/">Meshing</a></li><li><a class="tocitem" href="../fems/">Implemented Finite Elements</a></li><li><a class="tocitem" href="../fespace/">Finite Element Spaces and Arrays</a></li><li><a class="tocitem" href="../interpolations/">Finite Element Interpolations</a></li></ul></li><li><span class="tocitem">Solving</span><ul><li><a class="tocitem" href="../pdesolvers/">Fixed-Time Solvers</a></li><li><a class="tocitem" href="../timecontrolsolver/">Time-Dependent Solvers</a></li></ul></li><li><span class="tocitem">Postprocessing</span><ul><li><a class="tocitem" href="../itemintegrators/">Item Integrators</a></li><li><a class="tocitem" href="../pointevaluators/">Point Evaluators</a></li><li><a class="tocitem" href="../viewers/">Viewers</a></li><li><a class="tocitem" href="../export/">Data Export</a></li></ul></li><li><span class="tocitem">Low-Level Structures</span><ul><li><a class="tocitem" href="../quadrature/">Quadrature</a></li><li class="is-active"><a class="tocitem" href>Assembly Patterns</a></li><li><a class="tocitem" href="../febasisevaluators/">FE Basis Evaluators</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples_intro/">About the examples</a></li><li><a class="tocitem" href="../examples/Example101_Bestapproximation1D/">101 : L2-Bestapproximation 1D</a></li><li><a class="tocitem" href="../examples/Example201_PoissonProblem2D/">201 : Poisson-Problem 2D</a></li><li><a class="tocitem" href="../examples/Example202_LinearElasticity2D/">202 : Linear Elasticity</a></li><li><a class="tocitem" href="../examples/Example203_ReactionConvectionDiffusion2D/">203 : Reaction-Convection-Diffusion-Problem 2D</a></li><li><a class="tocitem" href="../examples/Example204_PoissonLshapeAdaptive2D/">204 : Poisson L-shape Adaptive Mesh Refinement</a></li><li><a class="tocitem" href="../examples/Example205_PlanarLatticeFlow2D/">205 : Planar Lattice Flow 2D</a></li><li><a class="tocitem" href="../examples/Example206_PressureRobustness2D/">206 : Pressure-robustness 2D</a></li><li><a class="tocitem" href="../examples/Example207_StokesTransient2D/">207 : Stokes Transient 2D</a></li><li><a class="tocitem" href="../examples/Example208_FlowTransport2D/">208 : Flow + Transport 2D</a></li><li><a class="tocitem" href="../examples/Example209_FaceLagrangeMultiplier2D/">209 : Lagrange Multiplier on Faces</a></li><li><a class="tocitem" href="../examples/Example210_NonlinearPoisson2D/">210 : Nonlinear Poisson Problem 2D</a></li><li><a class="tocitem" href="../examples/Example211_NonlinearElasticityBimetal2D/">211 : Nonlinear Elasticity Bimetal 2D</a></li><li><a class="tocitem" href="../examples/Example212_NonlinearPoissonTransient2D/">212 : Nonlinear Poisson Transient 2D</a></li><li><a class="tocitem" href="../examples/Example214_TwoNonlinearCoupled2D/">214 : Two nonlinearly coupled PDEs (2D)</a></li><li><a class="tocitem" href="../examples/Example215_ObstacleProblem2D/">215 : Obstacle Problem 2D</a></li><li><a class="tocitem" href="../examples/Example221_StokesIterated2D/">221 : Stokes iterated penalty method 2D</a></li><li><a class="tocitem" href="../examples/Example222_NavierStokesAnderson2D/">222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration</a></li><li><a class="tocitem" href="../examples/Example223_NaturalConvection2D/">223 : Natural Convection 2D</a></li><li><a class="tocitem" href="../examples/Example224_FlowAroundCylinder2D/">224 : Flow around a cylinder 2D</a></li><li><a class="tocitem" href="../examples/Example225_CompressibleStokes2D/">225 : Compressible Stokes 2D</a></li><li><a class="tocitem" href="../examples/Example230_StokesHdivDG2D/">230 : Stokes Hdiv-DG 2D</a></li><li><a class="tocitem" href="../examples/Example231_StokesHdivP1RT/">231 : Stokes <span>$(P1 \oplus RT0) \times P0$</span></a></li><li><a class="tocitem" href="../examples/Example240_TransientFlowAroundCylinder2D/">240 : Transient Flow around a cylinder 2D</a></li><li><a class="tocitem" href="../examples/Example301_Poisson3D/">301 : Poisson-Problem 3D</a></li><li><a class="tocitem" href="../examples/Example302_BestapproximationHdiv3D/">302 : Bestapproximation Hdiv 3D</a></li><li><a class="tocitem" href="../examples/ExampleA01_RationalMassMatrix/">A01 : Rational Mass Matrix</a></li><li><a class="tocitem" href="../examples/ExampleA02_CommutingInterpolators2D/">A02 : Commuting Interpolators 2D</a></li><li><a class="tocitem" href="../examples/ExampleA03_CommutingInterpolators3D/">A03 : Commuting Interpolators 3D</a></li><li><a class="tocitem" href="../examples/ExampleA04_CustomLinearSolver/">A04 : Custom Linear Solvers</a></li><li><a class="tocitem" href="../examples/ExampleA05_DiffEQ/">A05 : Comparison with DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples/ExampleA06_LocalEquilibratedFluxes2D/">A06 : Local Equilibrated Fluxes 2D</a></li><li><a class="tocitem" href="../examples/ExampleA07_InterpolationBetweenMeshes/">A07 : Interpolation Between Meshes</a></li><li><a class="tocitem" href="../examples/ExampleA08_BasisPlotter/">A08 : Basis-Plotter</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Low-Level Structures</a></li><li class="is-active"><a href>Assembly Patterns</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Assembly Patterns</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/master/docs/src/assemblypatterns.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Assembly-Patterns"><a class="docs-heading-anchor" href="#Assembly-Patterns">Assembly Patterns</a><a id="Assembly-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly-Patterns" title="Permalink"></a></h1><p>The definition and assembly of an operator is essentially based on Assembly Patterns and a <a href="../pdeoperators/#Assembly-Type">Assembly Type</a> to choose the geometry information needed for providing quadrature and dof handling. The assembly pattern then basically evaluates the function operators and action for the ansatz and test functions and does the quadrature-weighted accumulation into matrices or vectors that represent the operators.</p><p>Each pattern comes with a number of arguments/quantities with associated <a href="../functionoperators/#Function-Operators">Function Operators</a> as well as one of the <a href="../pdeoperators/#Assembly-Type">Assembly Type</a> that states whether the form is evaluated over CELLS, FACES order BFACES (see above). Important note: this assembly type is relative to the grid of the first argument of the pattern. If this argument already lives ON<em>FACES and the pattern is also ON</em>FACES, it will ultimatively assemble on the faces of the faces (that are the edges of the grid with these faces). Moreover, patterns can have an <a href="../userdata/#Action">Action</a> that allow to make the evaluations parameter-, region- and/or function-dependent. Each pattern then has usually on to three implementation that writes into FEMatrix or FEVector (where e.g. a subset of arguments is fixed) or evaluates the pattern in the given FEVectorBlocks.</p><p>The patterns are used to assembly the PDE operators defined in a <a href="../pdedescription/#PDE-Description">PDE Description</a>.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.AssemblyPattern" href="#GradientRobustMultiPhysics.AssemblyPattern"><code>GradientRobustMultiPhysics.AssemblyPattern</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct AssemblyPattern{APT&lt;:AssemblyPatternType, T&lt;:Real, AT&lt;:AssemblyType, Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}</code></pre><p>each assembly pattern has one of the assembly pattern types (APT) that trigger different assemblies for the involved finite element spaces, operators and an assigned action. The assembly type (AT) determines if the assembly takes place on cells, faces or edges etc. (relatively to the assembly type of the first argument of the pattern)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/5838f87d6b9b684a6ffd5a47f8ee884944095ad6/src/assemblypatterns.jl#L244">source</a></section></article><p>The following table lists all available assembly patterns, their constuctor names and how they can be used for assembly or evaluations.</p><table><tr><th style="text-align: left">AssemblyPatternType</th><th style="text-align: left">constructor</th><th style="text-align: center">evaluate</th><th style="text-align: center">assembly into matrix</th><th style="text-align: center">assembly into vector</th></tr><tr><td style="text-align: left">APT_ItemIntegrator</td><td style="text-align: left">ItemIntegrator</td><td style="text-align: center">yes</td><td style="text-align: center">no</td><td style="text-align: center">no</td></tr><tr><td style="text-align: left">APT_LinearForm</td><td style="text-align: left">LinearForm</td><td style="text-align: center">no</td><td style="text-align: center">no</td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left">APT_BilinearForm</td><td style="text-align: left">BilinearForm</td><td style="text-align: center">no</td><td style="text-align: center">yes</td><td style="text-align: center">yes (1)</td></tr><tr><td style="text-align: left">APT_TrilinearForm</td><td style="text-align: left">TrilinearForm</td><td style="text-align: center">no</td><td style="text-align: center">yes (1)</td><td style="text-align: center">yes (2)</td></tr><tr><td style="text-align: left">APT_MultiLinearForm</td><td style="text-align: left">MultilinearForm</td><td style="text-align: center">no</td><td style="text-align: center">no</td><td style="text-align: center">yes (N-1)</td></tr><tr><td style="text-align: left">APT_NonlinearForm</td><td style="text-align: left">NonlinearForm</td><td style="text-align: center">no</td><td style="text-align: center">yes (L)</td><td style="text-align: center">yes (L)</td></tr></table><p>Number in brackets denotes the number of fixed arguments needed for this assembly, (L) means that a current solution is needed to evaluate (to evaluate the linearisation of the nonlinear form in this state). Evaluations of the other AssemblyPatterns may be possible in a future update, but currently have to be performed by maintaining a duplicate of the pattern rewritten as an ItemIntegrator.</p><h4 id="Constructor-details"><a class="docs-heading-anchor" href="#Constructor-details">Constructor details</a><a id="Constructor-details-1"></a><a class="docs-heading-anchor-permalink" href="#Constructor-details" title="Permalink"></a></h4><p>Below all constructors are detailed. (For the ItemIntegrator see <a href="../itemintegrators/#Item-Integrators">Item Integrators</a>.)</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.LinearForm" href="#GradientRobustMultiPhysics.LinearForm"><code>GradientRobustMultiPhysics.LinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function LinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AssemblyType},
    FE::Array{FESpace,1},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates a LinearForm assembly pattern with the given FESpaces, operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/5838f87d6b9b684a6ffd5a47f8ee884944095ad6/src/assemblypatterns/linearform.jl#L13-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.BilinearForm" href="#GradientRobustMultiPhysics.BilinearForm"><code>GradientRobustMultiPhysics.BilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function BilinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AssemblyType},
    FE::Array{FESpace,1},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates a general BilinearForm assembly pattern with the given FESpaces, operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/5838f87d6b9b684a6ffd5a47f8ee884944095ad6/src/assemblypatterns/bilinearform.jl#L53-L65">source</a></section><section><div><pre><code class="nohighlight hljs">function BilinearForm(
    operators::Array{AbstractFunctionOperator,1},
    action::AbstractAction = NoAction();
    name = &quot;auto&quot;,
    AT::Type{&lt;:AssemblyType} = ON_CELLS,
    APT::Type{&lt;:APT_BilinearForm} = APT_BilinearForm,
    apply_action_to = 1,
    regions::Array{Int,1} = [0],
    transposed_assembly::Bool = false,
    store::Bool = false)</code></pre><p>abstract bilinearform constructor that assembles</p><ul><li>b(u,v) = int<em>regions action(operator1(u)) * operator2(v) if apply</em>action_to = 1</li><li>b(u,v) = int<em>regions operator1(u) * action(operator2(v)) if apply</em>action_to = 2</li></ul><p>The optional arguments AT and regions specifies on which grid item the operator lives/assembles, while store toggles the separate storage for the operator (which is advisable if it is not alone i an otherweise nonlinear block of a PDEDescription). With the optional argument APT one can trigger different subpatterns like APT<em>SymmetricBilinearForm (assembles only a triangular block) or APT</em>LumpedBilinearForm (assembles only the diagonal).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/5838f87d6b9b684a6ffd5a47f8ee884944095ad6/src/pdeoperators.jl#L337-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.TrilinearForm" href="#GradientRobustMultiPhysics.TrilinearForm"><code>GradientRobustMultiPhysics.TrilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function TrilinearForm(
    T::Type{&lt;:Real},
    FES::Array{FESpace,1},          
    operators::Array{DataType,1},
    action::AbstractAction;
    regions::Array{Int,1} = [0])</code></pre><p>Creates a TrilinearForm assembly pattern with the given FESpaces, operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/5838f87d6b9b684a6ffd5a47f8ee884944095ad6/src/assemblypatterns/trilinearform.jl#L13-L24">source</a></section><section><div><pre><code class="nohighlight hljs">function TrilinearForm(
    operators::Array{AbstractFunctionOperator,1},
    a_from::Int,
    a_to::Int,
    action::AbstractAction;
    name = &quot;auto&quot;,
    AT::Type{&lt;:AssemblyType} = ON_CELLS,
    regions::Array{Int,1} = [0],
    transposed_assembly::Bool = false)</code></pre><p>abstract trilinearform constructor that assembles</p><ul><li>c(a,u,v) = (action(operators<a href="a">1</a>,operators<a href="u">2</a>), operators<a href="v">3</a>)</li></ul><p>where u and are the ansatz and test function coressponding to the PDE coordinates and a is an additional unknown of the PDE. The argument a can be moved to the other positions with a<em>to and gets it data from unknown a</em>from of the full PDEdescription.</p><p>The optional arguments AT and regions specifies on which grid item the operator lives/assembles,</p><p>Also note that this operator is always marked as nonlinear by the Solver configuration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/5838f87d6b9b684a6ffd5a47f8ee884944095ad6/src/pdeoperators.jl#L385-L407">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.MultilinearForm" href="#GradientRobustMultiPhysics.MultilinearForm"><code>GradientRobustMultiPhysics.MultilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function MultilinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AssemblyType},
    FE::Array{FESpace,1},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates a MultilinearForm assembly pattern with the given FESpaces, operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/5838f87d6b9b684a6ffd5a47f8ee884944095ad6/src/assemblypatterns/multilinearform.jl#L13-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.NonlinearForm" href="#GradientRobustMultiPhysics.NonlinearForm"><code>GradientRobustMultiPhysics.NonlinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function NonlinearForm(
    T::Type{&lt;:Real},
    FES::Array{FESpace,1},          # finite element spaces for each operator of the ansatz function and the last one refers to the test function
    operators::Array{DataType,1},   # operators that should be evaluated for the ansatz function and the last one refers to the test function
    action::AbstractAction;         # action that shoul have an AbstractNLActionKernel
    regions::Array{Int,1} = [0])</code></pre><p>Creates a NonlinearForm assembly pattern.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/5838f87d6b9b684a6ffd5a47f8ee884944095ad6/src/assemblypatterns/nonlinearform.jl#L13-L24">source</a></section><section><div><pre><code class="nohighlight hljs">function NonlinearForm(
    operator1::Array{DataType,1},
    coeff_from::Array{Int,1},
    operator2::Type{&lt;:AbstractFunctionOperator},
    action_kernel::Function,
    argsizes::Array{Int,1},
    dim::Int;
    name::String = &quot;nonlinear form&quot;,
    AT::Type{&lt;:AssemblyType} = ON_CELLS,
    ADnewton::Bool = false,
    action_kernel_rhs = nothing,
    factor = 1,
    regions = [0])</code></pre><p>generates an abstract nonlinearform operator G.  The array coeff_from stores the ids of the unknowns that should be used to evaluate the operators. The array argsizes is a vector with two entries where the first one is the length of the expected result vector and the second one is the length of the input vector.</p><p>If ADnewton == true, the specified action<em>kernel is automatically differentiated to assemble the Jacobian DG and setup a Newton iteration. The action</em>kernel has to be a function of the interface </p><pre><code class="nohighlight hljs">function name(result,input)</code></pre><p>where input is a vector of the operators of the solution and result is what then is multiplied with operator2 of the testfunction. Given some operator G(u), the Newton iteration reads DG u_next = DG u - G(u) which is added to the rest of the (linear) operators in the PDEDescription.</p><p>If ADnewton == false, the user is epected to prescribe a linearisation of the nonlinear operator. In this case the action_kernel has to satisfy the interface</p><pre><code class="nohighlight hljs">function name(result, input_current, input_ansatz)</code></pre><p>where input<em>current is a vector of the operators of the solution and input</em>ansatz is a vecor with the operators evaluated at one of the basis functions. If necessary, also a right-hand side action in the same format can be prescribed in action<em>kernel</em>rhs. </p><p>Note 1: The AD feature matured a bit, but still is to be considered experimental.</p><p>Note 2: The limitation that the nonlinearity only can depend on one unknown of the PDE was recently lifted, however the behavior how to assign this operator to the PDE may be revised in future. Currently, the nonlinearity can indeed depend on arbitrary unknowns (i.e. coeff<em>from may contain more than one different unknown ids), which will lead to copies of the operator assigned also to off-diagonal blocks which are then related to partial derivatives with respect to the other unknowns (i.e. input</em>ansatz will only contain the operator evaluations that coresspond to the unknown of the subblock it is evaluated at, all other entries are zero). The subblock assignment of the copies is done automatically by the add_operator! function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/5838f87d6b9b684a6ffd5a47f8ee884944095ad6/src/pdeoperators.jl#L564-L609">source</a></section></article><h4 id="Assemble"><a class="docs-heading-anchor" href="#Assemble">Assemble</a><a id="Assemble-1"></a><a class="docs-heading-anchor-permalink" href="#Assemble" title="Permalink"></a></h4><p>Below all assemble! functions of the patterns are listed. (For evaluation of the ItemIntegrator see <a href="../itemintegrators/#Item-Integrators">Item Integrators</a>.)</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!" href="#GradientRobustMultiPhysics.assemble!"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">assemble!(
    b::Union{AbstractArray{T,1},AbstractArray{T,2}},    # target vector/matrix
    AP::AssemblyPattern{APT,T,AT};                      # LinearForm pattern
    factor = 1)                                         # factor that is multiplied
    where {APT &lt;: APT_LinearForm, T, AT}</code></pre><p>Assembly of a LinearForm pattern AP into a vector or matrix (if action is vetor-valued).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/5838f87d6b9b684a6ffd5a47f8ee884944095ad6/src/assemblypatterns/linearform.jl#L33-L43">source</a></section><section><div><pre><code class="nohighlight hljs">assemble!(
    A::AbstractArray{T,2},                  # target matrix
    AP::AssemblyPattern{APT,T,AT};          # BilinearForm Pattern
    apply_action_to::Int = 1,               # action is applied to which argument?
    factor = 1,                             # factor that is multiplied
    transposed_assembly::Bool = false,      # transpose result?
    transpose_copy = Nothing)               # copy a transposed block to this matrix
    where {APT &lt;: APT_BilinearForm, T, AT}</code></pre><p>Assembly of a BilinearForm BLF into given two-dimensional AbstractArray (e.g. FEMatrixBlock or a ExtendableSparseMatrix).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/5838f87d6b9b684a6ffd5a47f8ee884944095ad6/src/assemblypatterns/bilinearform.jl#L94-L107">source</a></section><section><div><pre><code class="nohighlight hljs">assemble!(
    b::AbstractArray{T,1},          # target vector
    AP::AssemblyPattern{APT,T,AT},  # BilinearForm Pattern
    fixedFE::AbstractArray;         # coefficients for fixed argument
    apply_action_to::Int = 1,       # action is applied to 1st or 2nd argument?
    fixed_arguments = [1],        # which argument is fixed?
    factor = 1)                     # factor that is multiplied
    where {APT &lt;: APT_BilinearForm, T, AT}</code></pre><p>Assembly of a BilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the second argument is fixed (default) by the given coefficients in fixedFE. With apply<em>action</em>to=2 the action can be also applied to the second argument instead of the first one (default).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/5838f87d6b9b684a6ffd5a47f8ee884944095ad6/src/assemblypatterns/bilinearform.jl#L359-L374">source</a></section><section><div><pre><code class="nohighlight hljs">assemble!(
    assemble!(
    A::AbstractArray{T,2},                  # target matrix
    AP::AssemblyPattern{APT,T,AT},          # TrilinearForm pattern
    fixedFE::Array{&lt;:FEVectorBlock,1};      # coefficients for fixed argument
    fixed_argument = [1],                   # position of fixed argument (as an array)
    transposed_assembly::Bool = false,      # transpose result?
    factor = 1)                             # factor that is multiplied
    where {APT &lt;: APT_TrilinearForm, T, AT}</code></pre><p>Assembly of a TrilinearForm AP into given two-dimensional AbstractArray (e.g. a FEMatrixBlock). Here, one argument (specified by fixed_argument) is fixed by the given coefficients in fixedFE[1]. Note, that the action is (currently) always applied to the first and second argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/5838f87d6b9b684a6ffd5a47f8ee884944095ad6/src/assemblypatterns/trilinearform.jl#L39-L55">source</a></section><section><div><pre><code class="nohighlight hljs">assemble!(
    assemble!(
    b::AbstractVector,                      # target vector
    AP::AssemblyPattern{APT,T,AT},          # coefficients for fixed arguments
    fixedFE::Array{&lt;:FEVectorBlock,1};      # TrilinearForm pattern
    factor = 1)                             # factor that is multiplied
    where {APT &lt;: APT_TrilinearForm, T, AT}</code></pre><p>Assembly of a TrilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the first two arguments are fixed by the given coefficients in FE1 and FE2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/5838f87d6b9b684a6ffd5a47f8ee884944095ad6/src/assemblypatterns/trilinearform.jl#L220-L233">source</a></section><section><div><pre><code class="nohighlight hljs">assemble!(
    b::AbstractVector,                        # target vector
    FE::Array{&lt;:FEVectorBlock,1},             # coefficients of all but last argument
    AP::AssemblyPattern{APT,T,AT};            # Multilinearform pattern
    factor = 1)                               # factor that is multiplied
    where {APT &lt;: APT_MultilinearForm, T, AT}</code></pre><p>Assembly of a MultilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the all but the last arguments are fixed by the given coefficients in the components of FE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/5838f87d6b9b684a6ffd5a47f8ee884944095ad6/src/assemblypatterns/multilinearform.jl#L39-L51">source</a></section><section><div><pre><code class="nohighlight hljs">assemble!(
    A::AbstractArray{T,2},                 # target matrix
    AP::AssemblyPattern{APT,T,AT};         # NonlinearForm pattern
    FEB::Array{&lt;:FEVectorBlock,1};         # coefficients of current solution for each operator
    factor = 1,                            # factor that is multiplied
    transposed_assembly::Bool = false)     # transpose result?
    where {APT &lt;: APT_NonlinearForm, T, AT}</code></pre><p>Assembly of a NonlinearForm assembly pattern into given two-dimensional AbstractArray (e.g. FEMatrixBlock).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/5838f87d6b9b684a6ffd5a47f8ee884944095ad6/src/assemblypatterns/nonlinearform.jl#L42-L54">source</a></section><section><div><pre><code class="nohighlight hljs">assemble!(
    b::AbstractVector,                     # target vector
    AP::AssemblyPattern{APT,T,AT},         # NonlinearForm pattern
    FEB::Array{&lt;:FEVectorBlock,1};         # coefficients of current solution for each operator
    factor = 1)                            # factor that is multiplied
    where {APT &lt;: APT_NonlinearForm, T, AT}</code></pre><p>Assembly of a NonlinearForm AP into given AbstractVector (e.g. FEMatrixBlock).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/5838f87d6b9b684a6ffd5a47f8ee884944095ad6/src/assemblypatterns/nonlinearform.jl#L227-L238">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quadrature/">« Quadrature</a><a class="docs-footer-nextpage" href="../febasisevaluators/">FE Basis Evaluators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 2 November 2021 15:51">Tuesday 2 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
