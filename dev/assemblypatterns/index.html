<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Assembly Patterns · GradientRobustMultiPhysics.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../home/">GradientRobustMultiPhysics.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../home/">Home</a></li><li><a class="tocitem" href="../">Index</a></li><li><span class="tocitem">Problem Description</span><ul><li><a class="tocitem" href="../pdedescription/">PDE Description</a></li><li><a class="tocitem" href="../pdeoperators/">PDE Operators</a></li><li><a class="tocitem" href="../functionoperators/">Function Operators</a></li><li><a class="tocitem" href="../userdata/">User Data and Actions</a></li><li><a class="tocitem" href="../boundarydata/">Boundary Data</a></li><li><a class="tocitem" href="../globalconstraints/">Global Constraints</a></li><li><a class="tocitem" href="../pdeprototypes/">PDE Prototypes</a></li></ul></li><li><span class="tocitem">Discretisation</span><ul><li><a class="tocitem" href="../meshing/">Meshing</a></li><li><a class="tocitem" href="../fems/">Implemented Finite Elements</a></li><li><a class="tocitem" href="../fespace/">Finite Element Spaces and Arrays</a></li><li><a class="tocitem" href="../interpolations/">Finite Element Interpolations</a></li></ul></li><li><span class="tocitem">Solving</span><ul><li><a class="tocitem" href="../pdesolvers/">Fixed-Time Solvers</a></li><li><a class="tocitem" href="../timecontrolsolver/">Time-Dependent Solvers</a></li></ul></li><li><span class="tocitem">Postprocessing</span><ul><li><a class="tocitem" href="../itemintegrators/">Item Integrators</a></li><li><a class="tocitem" href="../pointevaluators/">Point Evaluators</a></li><li><a class="tocitem" href="../viewers/">Viewers</a></li><li><a class="tocitem" href="../export/">Data Export</a></li></ul></li><li><span class="tocitem">Low-Level Structures</span><ul><li><a class="tocitem" href="../quadrature/">Quadrature</a></li><li class="is-active"><a class="tocitem" href>Assembly Patterns</a></li><li><a class="tocitem" href="../febasisevaluators/">FE Basis Evaluators</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples_intro/">About the examples</a></li><li><a class="tocitem" href="../examples/Example101_Bestapproximation1D/">101 : L2-Bestapproximation 1D</a></li><li><a class="tocitem" href="../examples/Example102_RobinBoundaryCondition1D/">102 : Robin-Boundary Conditions 1D</a></li><li><a class="tocitem" href="../examples/Example201_PoissonProblem2D/">201 : Poisson-Problem 2D</a></li><li><a class="tocitem" href="../examples/Example202_LinearElasticity2D/">202 : Linear Elasticity</a></li><li><a class="tocitem" href="../examples/Example203_ReactionConvectionDiffusion2D/">203 : Reaction-Convection-Diffusion-Problem 2D</a></li><li><a class="tocitem" href="../examples/Example204_PoissonLshapeAdaptive2D/">204 : Poisson L-shape Adaptive Mesh Refinement</a></li><li><a class="tocitem" href="../examples/Example205_PlanarLatticeFlow2D/">205 : Planar Lattice Flow 2D</a></li><li><a class="tocitem" href="../examples/Example206_PressureRobustness2D/">206 : Pressure-robustness 2D</a></li><li><a class="tocitem" href="../examples/Example207_StokesTransient2D/">207 : Stokes Transient 2D</a></li><li><a class="tocitem" href="../examples/Example208_FlowTransport2D/">208 : Flow + Transport 2D</a></li><li><a class="tocitem" href="../examples/Example209_FaceLagrangeMultiplier2D/">209 : Lagrange Multiplier on Faces</a></li><li><a class="tocitem" href="../examples/Example210_NonlinearPoisson2D/">210 : Nonlinear Poisson Problem 2D</a></li><li><a class="tocitem" href="../examples/Example211_NonlinearElasticityBimetal2D/">211 : Nonlinear Elasticity Bimetal 2D</a></li><li><a class="tocitem" href="../examples/Example212_NonlinearPoissonTransient2D/">212 : Nonlinear Poisson Transient 2D</a></li><li><a class="tocitem" href="../examples/Example214_TwoNonlinearCoupled2D/">214 : Two nonlinearly coupled PDEs (2D)</a></li><li><a class="tocitem" href="../examples/Example215_ObstacleProblem2D/">215 : Obstacle Problem 2D</a></li><li><a class="tocitem" href="../examples/Example221_StokesIterated2D/">221 : Stokes iterated penalty method 2D</a></li><li><a class="tocitem" href="../examples/Example222_NavierStokesAnderson2D/">222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration</a></li><li><a class="tocitem" href="../examples/Example223_NaturalConvection2D/">223 : Natural Convection 2D</a></li><li><a class="tocitem" href="../examples/Example224_FlowAroundCylinder2D/">224 : Flow around a cylinder 2D</a></li><li><a class="tocitem" href="../examples/Example225_CompressibleStokes2D/">225 : Compressible Stokes 2D</a></li><li><a class="tocitem" href="../examples/Example230_StokesHdivDG2D/">230 : Stokes Hdiv-DG 2D</a></li><li><a class="tocitem" href="../examples/Example231_StokesHdivP1RT/">231 : Stokes <span>$(P1 \oplus RT0) \times P0$</span></a></li><li><a class="tocitem" href="../examples/Example240_TransientFlowAroundCylinder2D/">240 : Transient Flow around a cylinder 2D</a></li><li><a class="tocitem" href="../examples/Example250_LevelSetMethod2D/">250 : Level Set Method 2D</a></li><li><a class="tocitem" href="../examples/Example301_Poisson3D/">301 : Poisson-Problem 3D</a></li><li><a class="tocitem" href="../examples/Example302_BestapproximationHdiv3D/">302 : Bestapproximation Hdiv 3D</a></li><li><a class="tocitem" href="../examples/ExampleA01_RationalMassMatrix/">A01 : Rational Mass Matrix</a></li><li><a class="tocitem" href="../examples/ExampleA02_CommutingInterpolators2D/">A02 : Commuting Interpolators 2D</a></li><li><a class="tocitem" href="../examples/ExampleA03_CommutingInterpolators3D/">A03 : Commuting Interpolators 3D</a></li><li><a class="tocitem" href="../examples/ExampleA04_CustomLinearSolver/">A04 : Custom Linear Solvers</a></li><li><a class="tocitem" href="../examples/ExampleA05_DiffEQ/">A05 : Comparison with DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples/ExampleA06_LocalEquilibratedFluxes2D/">A06 : Local Equilibrated Fluxes 2D</a></li><li><a class="tocitem" href="../examples/ExampleA07_InterpolationBetweenMeshes/">A07 : Interpolation Between Meshes</a></li><li><a class="tocitem" href="../examples/ExampleA08_BasisPlotter/">A08 : Basis-Plotter</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Low-Level Structures</a></li><li class="is-active"><a href>Assembly Patterns</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Assembly Patterns</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/master/docs/src/assemblypatterns.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Assembly-Patterns"><a class="docs-heading-anchor" href="#Assembly-Patterns">Assembly Patterns</a><a id="Assembly-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly-Patterns" title="Permalink"></a></h1><p>The definition and assembly of an operator is essentially based on Assembly Patterns and a <a href="../pdeoperators/#Assembly-Type">Assembly Type</a> to choose the geometry information needed for providing quadrature and dof handling. The assembly pattern then basically evaluates the function operators and action for the ansatz and test functions and does the quadrature-weighted accumulation into matrices or vectors that represent the operators.</p><p>Each pattern comes with a number of arguments/quantities with associated <a href="../functionoperators/#Function-Operators">Function Operators</a> as well as one of the <a href="../pdeoperators/#Assembly-Type">Assembly Type</a> that states whether the form is evaluated over CELLS, FACES order BFACES (see above). Important note: this assembly type is relative to the grid of the first argument of the pattern. If this argument already lives ON<em>FACES and the pattern is also ON</em>FACES, it will ultimatively assemble on the faces of the faces (that are the edges of the grid with these faces). Moreover, patterns can have an <a href="../userdata/#Action">Action</a> that allow to make the evaluations parameter-, region- and/or function-dependent. Each pattern then has usually on to three implementation that writes into FEMatrix or FEVector (where e.g. a subset of arguments is fixed) or evaluates the pattern in the given FEVectorBlocks.</p><p>The patterns are used to assembly the PDE operators defined in a <a href="../pdedescription/#PDE-Description">PDE Description</a>.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.AssemblyPattern" href="#GradientRobustMultiPhysics.AssemblyPattern"><code>GradientRobustMultiPhysics.AssemblyPattern</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct AssemblyPattern{APT&lt;:AssemblyPatternType, T&lt;:Real, AT&lt;:AssemblyType, Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}</code></pre><p>each assembly pattern has one of the assembly pattern types (APT) that trigger different assemblies for the involved finite element spaces, operators and an assigned action. The assembly type (AT) determines if the assembly takes place on cells, faces or edges etc. (relatively to the assembly type of the first argument of the pattern)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns.jl#L244">source</a></section></article><p>The following table lists all available assembly patterns, their constuctor names and how they can be used for assembly or evaluations.</p><table><tr><th style="text-align: left">AssemblyPatternType</th><th style="text-align: left">constructor</th><th style="text-align: center">evaluate</th><th style="text-align: center">assembly into matrix</th><th style="text-align: center">assembly into vector</th></tr><tr><td style="text-align: left">APT_ItemIntegrator</td><td style="text-align: left">ItemIntegrator</td><td style="text-align: center">yes</td><td style="text-align: center">no</td><td style="text-align: center">no</td></tr><tr><td style="text-align: left">APT_LinearForm</td><td style="text-align: left">LinearForm</td><td style="text-align: center">no</td><td style="text-align: center">no</td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left">APT_BilinearForm</td><td style="text-align: left">BilinearForm</td><td style="text-align: center">no</td><td style="text-align: center">yes</td><td style="text-align: center">yes (1)</td></tr><tr><td style="text-align: left">APT_TrilinearForm</td><td style="text-align: left">TrilinearForm</td><td style="text-align: center">no</td><td style="text-align: center">yes (1)</td><td style="text-align: center">yes (2)</td></tr><tr><td style="text-align: left">APT_MultiLinearForm</td><td style="text-align: left">MultilinearForm</td><td style="text-align: center">no</td><td style="text-align: center">no</td><td style="text-align: center">yes (N-1)</td></tr><tr><td style="text-align: left">APT_NonlinearForm</td><td style="text-align: left">NonlinearForm</td><td style="text-align: center">no</td><td style="text-align: center">yes (L)</td><td style="text-align: center">yes (L)</td></tr></table><p>Number in brackets denotes the number of fixed arguments needed for this assembly, (L) means that a current solution is needed to evaluate (to evaluate the linearisation of the nonlinear form in this state). Evaluations of the other AssemblyPatterns may be possible in a future update, but currently have to be performed by maintaining a duplicate of the pattern rewritten as an ItemIntegrator.</p><h4 id="Constructor-details"><a class="docs-heading-anchor" href="#Constructor-details">Constructor details</a><a id="Constructor-details-1"></a><a class="docs-heading-anchor-permalink" href="#Constructor-details" title="Permalink"></a></h4><p>Below all assembly pattern types, constructor functions and evaluate/assembly functions are detailed. (For more on the ItemIntegrator also see <a href="../itemintegrators/#Item-Integrators">Item Integrators</a>.)</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.APT_ItemIntegrator" href="#GradientRobustMultiPhysics.APT_ItemIntegrator"><code>GradientRobustMultiPhysics.APT_ItemIntegrator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type APT_ItemIntegrator &lt;: AssemblyPatternType</code></pre><p>itemintegrator assembly pattern type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/itemintegrator.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ItemIntegrator" href="#GradientRobustMultiPhysics.ItemIntegrator"><code>GradientRobustMultiPhysics.ItemIntegrator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function ItemIntegrator(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AssemblyType},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    name = &quot;ItemIntegrator&quot;,
    regions::Array{Int,1} = [0])</code></pre><p>Creates an ItemIntegrator assembly pattern with the given operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/itemintegrator.jl#L13-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.L2DifferenceIntegrator-Tuple{Type{var&quot;#s126&quot;} where var&quot;#s126&quot;&lt;:Real, Int64, Any}" href="#GradientRobustMultiPhysics.L2DifferenceIntegrator-Tuple{Type{var&quot;#s126&quot;} where var&quot;#s126&quot;&lt;:Real, Int64, Any}"><code>GradientRobustMultiPhysics.L2DifferenceIntegrator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function L2DifferenceIntegrator(
    T::Type{&lt;:Real},
    ncomponents::Int,
    operator::Union{Type{&lt;:AbstractFunctionOperator},Array{DataType,1}};
    AT::Type{&lt;:AssemblyType} = ON_CELLS,
    name = &quot;L2 difference&quot;,
    quadorder = 2,
    regions = [0])</code></pre><p>Creates an ItemIntegrator that computes the L2 norm difference between two arguments evalauted with the same operator (or with different operators if operator is an array) where ncomponents is the expected length of each operator evaluation. Note that all arguments in an evaluation call need to be defined on the same grid !</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/itemintegrator.jl#L137-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.L2ErrorIntegrator" href="#GradientRobustMultiPhysics.L2ErrorIntegrator"><code>GradientRobustMultiPhysics.L2ErrorIntegrator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function L2ErrorIntegrator(
    T::Type{&lt;:Real},
    compare_data::UserData{AbstractDataFunction}, # can be omitted if zero
    operator::Type{&lt;:AbstractFunctionOperator};
    quadorder = &quot;auto&quot;,
    name = &quot;auto&quot;,
    factor = 1,
    AT::Type{&lt;:AssemblyType} = ON_CELLS,
    time = 0)</code></pre><p>Creates an ItemIntegrator that compares discrete FEVectorBlock operator-evaluations against the given compare<em>data and returns the L2-error || compare</em>data(x) - factor*discrete(x) ||. If quadorder is left on &quot;auto&quot; two times the quadorder of the data is used in the evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/itemintegrator.jl#L30-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.L2NormIntegrator-Tuple{Type{var&quot;#s124&quot;} where var&quot;#s124&quot;&lt;:Real, Int64, Any}" href="#GradientRobustMultiPhysics.L2NormIntegrator-Tuple{Type{var&quot;#s124&quot;} where var&quot;#s124&quot;&lt;:Real, Int64, Any}"><code>GradientRobustMultiPhysics.L2NormIntegrator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">L2NormIntegrator(
    T::Type{&lt;:Real},
    ncomponents::Int,
    operator::Type{&lt;:AbstractFunctionOperator};
    AT::Type{&lt;:AssemblyType} = ON_CELLS,
    name = &quot;L2 norm&quot;,
    quadorder = 2,
    regions = [0])</code></pre><p>Creates an ItemIntegrator that computes the L2 norm of an operator evaluation where ncomponents is the expected length of the operator evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/itemintegrator.jl#L91-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.evaluate!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractMatrix{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where {Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}, Union{FEVector{T, Tv, Ti}, Vector{var&quot;#s67&quot;} where var&quot;#s67&quot;&lt;:(FEVectorBlock{T, Tv, Ti, FEType, APT} where {FEType, APT}), FEVectorBlock{T, Tv, Ti, FEType, APT} where {FEType, APT}}}} where {APT&lt;:ItemIntegrator, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}" href="#GradientRobustMultiPhysics.evaluate!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractMatrix{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where {Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}, Union{FEVector{T, Tv, Ti}, Vector{var&quot;#s67&quot;} where var&quot;#s67&quot;&lt;:(FEVectorBlock{T, Tv, Ti, FEType, APT} where {FEType, APT}), FEVectorBlock{T, Tv, Ti, FEType, APT} where {FEType, APT}}}} where {APT&lt;:ItemIntegrator, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}"><code>GradientRobustMultiPhysics.evaluate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function evaluate!(
    b::AbstractArray{T,2},
    AP::AssemblyPattern{APT,T,AT},
    FEB::Union{&lt;:FEVector{T,Tv,Ti},&lt;:FEVectorBlock{T,Tv,Ti},Array{&lt;:FEVectorBlock{T,Tv,Ti},1}};
    skip_preps::Bool = false) where {APT &lt;: APT_ItemIntegrator, T&lt;: Real, AT &lt;: AssemblyType, Tv, Ti}</code></pre><p>Evaluation of an ItemIntegrator assembly pattern with given FEVectorBlock or FEVector FEB into given two-dimensional Array b.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/itemintegrator.jl#L176-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.evaluate-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where {Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}, Union{FEVector{T, Tv, Ti}, Vector{var&quot;#s126&quot;} where var&quot;#s126&quot;&lt;:(FEVectorBlock{T, Tv, Ti, FEType, APT} where {FEType, APT}), FEVectorBlock{T, Tv, Ti, FEType, APT} where {FEType, APT}}}} where {APT&lt;:ItemIntegrator, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}" href="#GradientRobustMultiPhysics.evaluate-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where {Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}, Union{FEVector{T, Tv, Ti}, Vector{var&quot;#s126&quot;} where var&quot;#s126&quot;&lt;:(FEVectorBlock{T, Tv, Ti, FEType, APT} where {FEType, APT}), FEVectorBlock{T, Tv, Ti, FEType, APT} where {FEType, APT}}}} where {APT&lt;:ItemIntegrator, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}"><code>GradientRobustMultiPhysics.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function evaluate(
    AP::AssemblyPattern{APT,T,AT},
    FEB::Union{&lt;:FEVector{T,Tv,Ti},&lt;:FEVectorBlock{T,Tv,Ti},Array{&lt;:FEVectorBlock{T,Tv,Ti},1}};
    skip_preps::Bool = false) where {APT &lt;: APT_ItemIntegrator, T&lt;: Real, AT &lt;: AssemblyType, Tv, Ti}
</code></pre><p>Evaluation of an ItemIntegrator assembly pattern with given FEVectorBlock or FEVector FEB, only returns accumulation over all items.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/itemintegrator.jl#L315-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.APT_BilinearForm" href="#GradientRobustMultiPhysics.APT_BilinearForm"><code>GradientRobustMultiPhysics.APT_BilinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type APT_BilinearForm &lt;: AssemblyPatternType</code></pre><p>bilinearform assembly pattern type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/bilinearform.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.APT_LumpedBilinearForm" href="#GradientRobustMultiPhysics.APT_LumpedBilinearForm"><code>GradientRobustMultiPhysics.APT_LumpedBilinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type APT_LumpedBilinearForm &lt;: BilinearForm</code></pre><p>lumped bilinearform assembly pattern type where only the diagonal elements on each item are assembled</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/bilinearform.jl#L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.APT_SymmetricBilinearForm" href="#GradientRobustMultiPhysics.APT_SymmetricBilinearForm"><code>GradientRobustMultiPhysics.APT_SymmetricBilinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type APT_SymmetricBilinearForm &lt;: BilinearForm</code></pre><p>symmetric bilinearform assembly pattern type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/bilinearform.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.BilinearForm" href="#GradientRobustMultiPhysics.BilinearForm"><code>GradientRobustMultiPhysics.BilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function BilinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AssemblyType},
    FE::Array{FESpace,1},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates a general BilinearForm assembly pattern with the given FESpaces, operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/bilinearform.jl#L53-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.LumpedBilinearForm" href="#GradientRobustMultiPhysics.LumpedBilinearForm"><code>GradientRobustMultiPhysics.LumpedBilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function LumpedBilinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AssemblyType},
    FE::Array{FESpace,1},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates a LumpedBilinearForm assembly pattern with the given FESpaces, operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/bilinearform.jl#L73-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.SymmetricBilinearForm" href="#GradientRobustMultiPhysics.SymmetricBilinearForm"><code>GradientRobustMultiPhysics.SymmetricBilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function SymmetricBilinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AssemblyType},
    FE::Array{FESpace,1},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates a symmetric BilinearForm assembly pattern with the given FESpaces, operators and action etc. Symmetry is not checked automatically, but is assumed during assembly!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/bilinearform.jl#L33-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractVector{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where {Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}, AbstractVector{T}}} where {APT&lt;:BilinearForm, T&lt;:Real, AT&lt;:AssemblyType}" href="#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractVector{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where {Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}, AbstractVector{T}}} where {APT&lt;:BilinearForm, T&lt;:Real, AT&lt;:AssemblyType}"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble!(
    b::AbstractArray{T,1},          # target vector
    AP::AssemblyPattern{APT,T,AT},  # BilinearForm Pattern
    fixedFE::AbstractArray;         # coefficients for fixed argument
    apply_action_to::Int = 1,       # action is applied to 1st or 2nd argument?
    fixed_arguments = [1],        # which argument is fixed?
    factor = 1)                     # factor that is multiplied
    where {APT &lt;: APT_BilinearForm, T, AT}</code></pre><p>Assembly of a BilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the second argument is fixed (default) by the given coefficients in fixedFE. With apply<em>action</em>to=2 the action can be also applied to the second argument instead of the first one (default).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/bilinearform.jl#L359-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractMatrix{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where ActionType&lt;:AbstractAction}} where {APT&lt;:BilinearForm, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}" href="#GradientRobustMultiPhysics.assemble!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractMatrix{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where ActionType&lt;:AbstractAction}} where {APT&lt;:BilinearForm, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble!(
    A::AbstractArray{T,2},                  # target matrix
    AP::AssemblyPattern{APT,T,AT};          # BilinearForm Pattern
    apply_action_to::Int = 1,               # action is applied to which argument?
    factor = 1,                             # factor that is multiplied
    transposed_assembly::Bool = false,      # transpose result?
    transpose_copy = Nothing)               # copy a transposed block to this matrix
    where {APT &lt;: APT_BilinearForm, T, AT}</code></pre><p>Assembly of a BilinearForm BLF into given two-dimensional AbstractArray (e.g. FEMatrixBlock or a ExtendableSparseMatrix).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/bilinearform.jl#L94-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.APT_TrilinearForm" href="#GradientRobustMultiPhysics.APT_TrilinearForm"><code>GradientRobustMultiPhysics.APT_TrilinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type APT_TrilinearForm &lt;: AssemblyPatternType</code></pre><p>trilinearform assembly pattern type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/trilinearform.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.TrilinearForm-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Type{var&quot;#s246&quot;} where var&quot;#s246&quot;&lt;:Real, Type{var&quot;#s245&quot;} where var&quot;#s245&quot;&lt;:AssemblyType, Vector{var&quot;#s244&quot;} where var&quot;#s244&quot;&lt;:(FESpace{Tv, Ti, FEType, AT} where {FEType&lt;:AbstractFiniteElement, AT&lt;:AssemblyType}), Vector{DataType}, AbstractAction}} where {Tv, Ti}" href="#GradientRobustMultiPhysics.TrilinearForm-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Type{var&quot;#s246&quot;} where var&quot;#s246&quot;&lt;:Real, Type{var&quot;#s245&quot;} where var&quot;#s245&quot;&lt;:AssemblyType, Vector{var&quot;#s244&quot;} where var&quot;#s244&quot;&lt;:(FESpace{Tv, Ti, FEType, AT} where {FEType&lt;:AbstractFiniteElement, AT&lt;:AssemblyType}), Vector{DataType}, AbstractAction}} where {Tv, Ti}"><code>GradientRobustMultiPhysics.TrilinearForm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function TrilinearForm(
    T::Type{&lt;:Real},
    FES::Array{FESpace,1},          
    operators::Array{DataType,1},
    action::AbstractAction;
    regions::Array{Int,1} = [0])</code></pre><p>Creates a TrilinearForm assembly pattern with the given FESpaces, operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/trilinearform.jl#L13-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractMatrix{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where {Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}, Vector{var&quot;#s124&quot;} where var&quot;#s124&quot;&lt;:FEVectorBlock}} where {APT&lt;:TrilinearForm, T&lt;:Real, AT&lt;:AssemblyType}" href="#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractMatrix{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where {Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}, Vector{var&quot;#s124&quot;} where var&quot;#s124&quot;&lt;:FEVectorBlock}} where {APT&lt;:TrilinearForm, T&lt;:Real, AT&lt;:AssemblyType}"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble!(
    assemble!(
    A::AbstractArray{T,2},                  # target matrix
    AP::AssemblyPattern{APT,T,AT},          # TrilinearForm pattern
    fixedFE::Array{&lt;:FEVectorBlock,1};      # coefficients for fixed argument
    fixed_argument = [1],                   # position of fixed argument (as an array)
    transposed_assembly::Bool = false,      # transpose result?
    factor = 1)                             # factor that is multiplied
    where {APT &lt;: APT_TrilinearForm, T, AT}</code></pre><p>Assembly of a TrilinearForm AP into given two-dimensional AbstractArray (e.g. a FEMatrixBlock). Here, one argument (specified by fixed_argument) is fixed by the given coefficients in fixedFE[1]. Note, that the action is (currently) always applied to the first and second argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/trilinearform.jl#L39-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractVector{T} where T, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where {Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}, Vector{var&quot;#s245&quot;} where var&quot;#s245&quot;&lt;:FEVectorBlock}} where {APT&lt;:TrilinearForm, T&lt;:Real, AT&lt;:AssemblyType}" href="#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractVector{T} where T, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where {Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}, Vector{var&quot;#s245&quot;} where var&quot;#s245&quot;&lt;:FEVectorBlock}} where {APT&lt;:TrilinearForm, T&lt;:Real, AT&lt;:AssemblyType}"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble!(
    assemble!(
    b::AbstractVector,                      # target vector
    AP::AssemblyPattern{APT,T,AT},          # coefficients for fixed arguments
    fixedFE::Array{&lt;:FEVectorBlock,1};      # TrilinearForm pattern
    factor = 1)                             # factor that is multiplied
    where {APT &lt;: APT_TrilinearForm, T, AT}</code></pre><p>Assembly of a TrilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the first two arguments are fixed by the given coefficients in FE1 and FE2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/trilinearform.jl#L220-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.APT_MultilinearForm" href="#GradientRobustMultiPhysics.APT_MultilinearForm"><code>GradientRobustMultiPhysics.APT_MultilinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type APT_MultilinearForm &lt;: AssemblyPatternType</code></pre><p>multilinearform assembly pattern type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/multilinearform.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.MultilinearForm-Tuple{Type{var&quot;#s473&quot;} where var&quot;#s473&quot;&lt;:Real, Type{var&quot;#s406&quot;} where var&quot;#s406&quot;&lt;:AssemblyType, Vector{FESpace}, Vector{DataType}, AbstractAction}" href="#GradientRobustMultiPhysics.MultilinearForm-Tuple{Type{var&quot;#s473&quot;} where var&quot;#s473&quot;&lt;:Real, Type{var&quot;#s406&quot;} where var&quot;#s406&quot;&lt;:AssemblyType, Vector{FESpace}, Vector{DataType}, AbstractAction}"><code>GradientRobustMultiPhysics.MultilinearForm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function MultilinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AssemblyType},
    FE::Array{FESpace,1},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates a MultilinearForm assembly pattern with the given FESpaces, operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/multilinearform.jl#L13-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractVector{T} where T, Vector{AbstractVector{T} where T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where {Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}}} where {APT&lt;:MultilinearForm, T&lt;:Real, AT&lt;:AssemblyType}" href="#GradientRobustMultiPhysics.assemble!-Union{Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractVector{T} where T, Vector{AbstractVector{T} where T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where {Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}}} where {APT&lt;:MultilinearForm, T&lt;:Real, AT&lt;:AssemblyType}"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble!(
    b::AbstractVector,                        # target vector
    FE::Array{&lt;:FEVectorBlock,1},             # coefficients of all but last argument
    AP::AssemblyPattern{APT,T,AT};            # Multilinearform pattern
    factor = 1)                               # factor that is multiplied
    where {APT &lt;: APT_MultilinearForm, T, AT}</code></pre><p>Assembly of a MultilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the all but the last arguments are fixed by the given coefficients in the components of FE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/multilinearform.jl#L39-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.APT_NonlinearForm" href="#GradientRobustMultiPhysics.APT_NonlinearForm"><code>GradientRobustMultiPhysics.APT_NonlinearForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type APT_NonlinearForm &lt;: AssemblyPatternType</code></pre><p>nonlinearform assembly pattern type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/nonlinearform.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.NonlinearForm-Tuple{Type{var&quot;#s473&quot;} where var&quot;#s473&quot;&lt;:Real, Type{var&quot;#s406&quot;} where var&quot;#s406&quot;&lt;:AssemblyType, Vector{FESpace}, Vector{DataType}, AbstractAction}" href="#GradientRobustMultiPhysics.NonlinearForm-Tuple{Type{var&quot;#s473&quot;} where var&quot;#s473&quot;&lt;:Real, Type{var&quot;#s406&quot;} where var&quot;#s406&quot;&lt;:AssemblyType, Vector{FESpace}, Vector{DataType}, AbstractAction}"><code>GradientRobustMultiPhysics.NonlinearForm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function NonlinearForm(
    T::Type{&lt;:Real},
    FES::Array{FESpace,1},          # finite element spaces for each operator of the ansatz function and the last one refers to the test function
    operators::Array{DataType,1},   # operators that should be evaluated for the ansatz function and the last one refers to the test function
    action::AbstractAction;         # action that shoul have an AbstractNLActionKernel
    regions::Array{Int,1} = [0])</code></pre><p>Creates a NonlinearForm assembly pattern.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/nonlinearform.jl#L13-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractMatrix{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where {Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}, Vector{var&quot;#s119&quot;} where var&quot;#s119&quot;&lt;:(FEVectorBlock{T, Tv, Ti, FEType, APT} where {FEType, APT})}} where {APT&lt;:NonlinearForm, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}" href="#GradientRobustMultiPhysics.assemble!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractMatrix{T}, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where {Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}, Vector{var&quot;#s119&quot;} where var&quot;#s119&quot;&lt;:(FEVectorBlock{T, Tv, Ti, FEType, APT} where {FEType, APT})}} where {APT&lt;:NonlinearForm, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble!(
    A::AbstractArray{T,2},                 # target matrix
    AP::AssemblyPattern{APT,T,AT};         # NonlinearForm pattern
    FEB::Array{&lt;:FEVectorBlock,1};         # coefficients of current solution for each operator
    factor = 1,                            # factor that is multiplied
    transposed_assembly::Bool = false)     # transpose result?
    where {APT &lt;: APT_NonlinearForm, T, AT}</code></pre><p>Assembly of a NonlinearForm assembly pattern into given two-dimensional AbstractArray (e.g. FEMatrixBlock).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/nonlinearform.jl#L42-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractVector{T} where T, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where {Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}, Vector{var&quot;#s126&quot;} where var&quot;#s126&quot;&lt;:(FEVectorBlock{T, Tv, Ti, FEType, APT} where {FEType, APT})}} where {APT&lt;:NonlinearForm, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}" href="#GradientRobustMultiPhysics.assemble!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{AbstractVector{T} where T, GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where {Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}, Vector{var&quot;#s126&quot;} where var&quot;#s126&quot;&lt;:(FEVectorBlock{T, Tv, Ti, FEType, APT} where {FEType, APT})}} where {APT&lt;:NonlinearForm, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble!(
    b::AbstractVector,                     # target vector
    AP::AssemblyPattern{APT,T,AT},         # NonlinearForm pattern
    FEB::Array{&lt;:FEVectorBlock,1};         # coefficients of current solution for each operator
    factor = 1)                            # factor that is multiplied
    where {APT &lt;: APT_NonlinearForm, T, AT}</code></pre><p>Assembly of a NonlinearForm AP into given AbstractVector (e.g. FEMatrixBlock).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/nonlinearform.jl#L227-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.evaluate-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where {Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}, Vector{var&quot;#s243&quot;} where var&quot;#s243&quot;&lt;:FEVectorBlock, FEVectorBlock{T, Tv, Ti, FEType, APT} where {FEType, APT}}} where {APT&lt;:NonlinearForm, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}" href="#GradientRobustMultiPhysics.evaluate-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AT}, Tuple{T}, Tuple{APT}, Tuple{GradientRobustMultiPhysics.AssemblyPattern{APT, T, AT, Tv, Ti, ActionType} where {Tv&lt;:Real, Ti&lt;:Integer, ActionType&lt;:AbstractAction}, Vector{var&quot;#s243&quot;} where var&quot;#s243&quot;&lt;:FEVectorBlock, FEVectorBlock{T, Tv, Ti, FEType, APT} where {FEType, APT}}} where {APT&lt;:NonlinearForm, T&lt;:Real, AT&lt;:AssemblyType, Tv, Ti}"><code>GradientRobustMultiPhysics.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assemble!(
    AP::AssemblyPattern{APT,T,AT},         # NonlinearForm pattern
    FEB::Array{&lt;:FEVectorBlock,1};         # coefficients of current solution for each operator
    FEBtest::FEVectorBlock;                # coefficients of test function for test function operator
    factor = 1)                            # factor that is multiplied
    where {APT &lt;: APT_NonlinearForm, T, AT}</code></pre><p>Evaluation of a NonlinearForm AP for given coefficients of ansatz and test function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/72c7a3db0dba732a1b4adc460655460fc5d82633/src/assemblypatterns/nonlinearform.jl#L375-L386">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quadrature/">« Quadrature</a><a class="docs-footer-nextpage" href="../febasisevaluators/">FE Basis Evaluators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 11 November 2021 17:23">Thursday 11 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
