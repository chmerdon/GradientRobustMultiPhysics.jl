<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Assembly Details · GradientRobustMultiPhysics.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GradientRobustMultiPhysics.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Problem Description</span><ul><li><a class="tocitem" href="../pdedescription/">PDE Description</a></li><li><a class="tocitem" href="../pdeoperators/">PDE Operators</a></li><li><a class="tocitem" href="../functionoperators/">Function Operators</a></li><li><a class="tocitem" href="../userdata/">User Data and Action Kernels</a></li><li><a class="tocitem" href="../boundarydata/">Boundary Data</a></li><li><a class="tocitem" href="../globalconstraints/">Global Constraints</a></li><li><a class="tocitem" href="../pdeprototypes/">PDE Prototypes</a></li></ul></li><li><span class="tocitem">Discretisation</span><ul><li><a class="tocitem" href="../meshing/">Meshing</a></li><li><a class="tocitem" href="../fems/">Implemented Finite Elements</a></li><li><a class="tocitem" href="../fespace/">Finite Element Spaces and Arrays</a></li><li><a class="tocitem" href="../interpolations/">Finite Element Interpolations</a></li><li><a class="tocitem" href="../quadrature/">Quadrature</a></li><li class="is-active"><a class="tocitem" href>Assembly Details</a><ul class="internal"><li><a class="tocitem" href="#Assembly-Patterns"><span>Assembly Patterns</span></a></li></ul></li></ul></li><li><span class="tocitem">Solving</span><ul><li><a class="tocitem" href="../pdesolvers/">Fixed-Time Solvers</a></li><li><a class="tocitem" href="../timecontrolsolver/">Time-Dependent Solvers</a></li></ul></li><li><span class="tocitem">Postprocessing</span><ul><li><a class="tocitem" href="../viewers/">Viewers</a></li><li><a class="tocitem" href="../export/">Data Export</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples_intro/">How to run the examples</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Examples (Intro)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/doc_1d_bestapprox/">1D L2-Bestapproximation</a></li><li><a class="tocitem" href="../examples/doc_2d_bestapprox_curlpreserve/">2D Curl-Preserving L2-Bestapproximation</a></li><li><a class="tocitem" href="../examples/doc_2d_commutinginterpolators/">Commuting Interpolators (2D)</a></li><li><a class="tocitem" href="../examples/doc_2d_convectiondiffusion/">2D Convection-Diffusion-Problem</a></li><li><a class="tocitem" href="../examples/doc_2d_cookmembrane/">2D Linear Elasticity</a></li><li><a class="tocitem" href="../examples/doc_2d_fe_on_faces/">2D Finite Elements on Faces</a></li><li><a class="tocitem" href="../examples/doc_2d_flowtransport/">2D Flow + Transport</a></li><li><a class="tocitem" href="../examples/doc_2d_liddrivencavity_anderson/">2D Lid-driven cavity (Anderson Acceleration)</a></li><li><a class="tocitem" href="../examples/doc_2d_lshape_adaptivity/">2D Adaptive Mesh Refinement (L-shape)</a></li><li><a class="tocitem" href="../examples/doc_2d_nonlin_poisson/">2D Nonlinear Poisson-Problem</a></li><li><a class="tocitem" href="../examples/doc_2d_nonlin_poisson_timedependent/">2D Nonlinear Poisson (time-dependent)</a></li><li><a class="tocitem" href="../examples/doc_2d_plaplace/">2D Nonlinear Poisson (p-Laplacian)</a></li><li><a class="tocitem" href="../examples/doc_2d_stokes_iterated/">2D Stokes (iterated penalty method)</a></li><li><a class="tocitem" href="../examples/doc_2d_stokes_probust/">2D Pressure-robustness</a></li><li><a class="tocitem" href="../examples/doc_2d_transientstokes/">2D Transient Stokes-Problem</a></li><li><a class="tocitem" href="../examples/doc_3d_bestapprox_divpreserve/">3D Divergence-Preserving L2-Bestapproximation</a></li><li><a class="tocitem" href="../examples/doc_3d_commutinginterpolators/">Commuting Interpolators (3D)</a></li><li><a class="tocitem" href="../examples/doc_3d_poisson/">3D Poisson-Problem</a></li><li><a class="tocitem" href="../examples/doc_rational_massmatrix/">Rational Mass Matrix</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Examples (Advanced)</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples_advanced/doc_2d_compressiblestokes/">2D Compressible Stokes</a></li><li><a class="tocitem" href="../examples_advanced/doc_2d_lshape_adaptivity_eq/">2D Equilibration Error Estimation (Global)</a></li><li><a class="tocitem" href="../examples_advanced/doc_2d_lshape_adaptivity_loceq/">2D Equilibration Error Estimation (Local)</a></li><li><a class="tocitem" href="../examples_advanced/doc_2d_naturalconvection/">2D Natural Convection</a></li><li><a class="tocitem" href="../examples_advanced/doc_2d_nonlin_diffeq/">2D Comparison with DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples_advanced/doc_2d_other_linsolver/">2D User-defined Linear Solvers</a></li><li><a class="tocitem" href="../examples_advanced/doc_2d_stokes_hdiv-dg/">2D DG-Hdiv discretisation for Stokes</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Discretisation</a></li><li class="is-active"><a href>Assembly Details</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Assembly Details</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/master/docs/src/assembly_details.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Assembly-Details"><a class="docs-heading-anchor" href="#Assembly-Details">Assembly Details</a><a id="Assembly-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly-Details" title="Permalink"></a></h1><p>The assembly of an operator is essentially based on a combination of <a href="../pdeoperators/#Assembly-Types">Assembly Types</a> and <a href="#Assembly-Patterns">Assembly Patterns</a>. The assembly type mainly allows to choose the geometry information needed for providing quadrature and dof handling. The assembly pattern then basically evaluates the function operators and action for the ansatz and test functions and does the quadrature-weighted accumulation into matrices or vectors that represent the operators.</p><h2 id="Assembly-Patterns"><a class="docs-heading-anchor" href="#Assembly-Patterns">Assembly Patterns</a><a id="Assembly-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly-Patterns" title="Permalink"></a></h2><p>Each Pattern comes with a number of arguments/quantities with associated <a href="../functionoperators/#Function-Operators">Function Operators</a> as well as one of the <a href="../pdeoperators/#Assembly-Types">Assembly Types</a> that states whether the form is evaluated over CELLS, FACES order BFACES (see above). Important note: this assembly type is relative to the grid of the first argument of the pattern. If this argument already lives ON<em>FACES and the pattern is also ON</em>FACES, it will ultimatively assemble on the faces of the faces (that are the edges of the grid with these faces). Moreover, patterns can have <a href="@ref">Abstract Actions</a> that allow to make the evaluations parameter-, region- and/or function-dependent. Each pattern then has usually on to three implementation that writes into FEMatrix or FEVector (where e.g. a subset of arguments is fixed) or evaluates the pattern in the given FEVectorBlocks.</p><p>The patterns are used to assembly the PDE operators defined in a <a href="../pdedescription/#PDE-Description">PDE Description</a>. However, it is also possible for the user to use them directly, see e.g. the example <a href="../examples/doc_2d_commutinginterpolators/#Commuting-Interpolators-(2D)">Commuting Interpolators (2D)</a>.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.AssemblyPattern" href="#GradientRobustMultiPhysics.AssemblyPattern"><code>GradientRobustMultiPhysics.AssemblyPattern</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct AssemblyPattern{APT&lt;:AssemblyPatternType, T&lt;:Real, AT&lt;:AbstractAssemblyType, ActionType&lt;:AbstractAction}</code></pre><p>each assembly pattern has one of the assembly pattern types (APT) that trigger different assemblies for the involved finite element spaces, operators and an assigned action. The assembly type (AT) determines if the assembly takes place on cells, faces or edges etc. (relatively to the assembly type of the first argument of the pattern)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/018a99a007014069abe8fbde1fd0db8137abd469/src/assemblypatterns.jl#L244">source</a></section></article><p>The following table lists all available assembly patterns, their constuctor names and how they can be used for assembly or evaluations.</p><table><tr><th style="text-align: left">AssemblyPatternType</th><th style="text-align: left">constructor</th><th style="text-align: center">evaluate</th><th style="text-align: center">assembly into matrix</th><th style="text-align: center">assembly into vector</th></tr><tr><td style="text-align: left">APT_ItemIntegrator</td><td style="text-align: left">ItemIntegrator</td><td style="text-align: center">yes</td><td style="text-align: center">no</td><td style="text-align: center">no</td></tr><tr><td style="text-align: left">APT_LinearForm</td><td style="text-align: left">LinearForm</td><td style="text-align: center">no</td><td style="text-align: center">no</td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left">APT_BilinearForm</td><td style="text-align: left">BilinearForm</td><td style="text-align: center">no</td><td style="text-align: center">yes</td><td style="text-align: center">yes (1)</td></tr><tr><td style="text-align: left">APT_TrilinearForm</td><td style="text-align: left">TrilinearForm</td><td style="text-align: center">no</td><td style="text-align: center">yes (1)</td><td style="text-align: center">yes (2)</td></tr><tr><td style="text-align: left">APT_MultiLinearForm</td><td style="text-align: left">MultilinearForm</td><td style="text-align: center">no</td><td style="text-align: center">no</td><td style="text-align: center">yes (N-1)</td></tr><tr><td style="text-align: left">APT_NonlinearForm</td><td style="text-align: left">NonlinearForm</td><td style="text-align: center">no</td><td style="text-align: center">yes (L)</td><td style="text-align: center">yes (L)</td></tr></table><p>Number in brackets denotes the number of fixed arguments needed for this assembly, (L) means that a current solution is needed to evaluate (to evaluate the linearisation of the nonlinear form in this state). Evaluations of the other AssemblyPatterns may be possible in a future update, but currently have to be performed by maintaining a duplicate of the pattern rewritten as an ItemIntegrator.</p><h4 id="Constructor-details"><a class="docs-heading-anchor" href="#Constructor-details">Constructor details</a><a id="Constructor-details-1"></a><a class="docs-heading-anchor-permalink" href="#Constructor-details" title="Permalink"></a></h4><p>Below all constructors are detailed.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ItemIntegrator" href="#GradientRobustMultiPhysics.ItemIntegrator"><code>GradientRobustMultiPhysics.ItemIntegrator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function ItemIntegrator(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AbstractAssemblyType},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates an ItemIntegrator assembly pattern with the given operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/018a99a007014069abe8fbde1fd0db8137abd469/src/assemblypatterns/itemintegrator.jl#L13-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.LinearForm" href="#GradientRobustMultiPhysics.LinearForm"><code>GradientRobustMultiPhysics.LinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function LinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AbstractAssemblyType},
    FE::Array{FESpace,1},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates a LinearForm assembly pattern with the given FESpaces, operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/018a99a007014069abe8fbde1fd0db8137abd469/src/assemblypatterns/linearform.jl#L13-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.BilinearForm" href="#GradientRobustMultiPhysics.BilinearForm"><code>GradientRobustMultiPhysics.BilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function BilinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AbstractAssemblyType},
    FE::Array{FESpace,1},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates a general BilinearForm assembly pattern with the given FESpaces, operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/018a99a007014069abe8fbde1fd0db8137abd469/src/assemblypatterns/bilinearform.jl#L43-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.TrilinearForm" href="#GradientRobustMultiPhysics.TrilinearForm"><code>GradientRobustMultiPhysics.TrilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function TrilinearForm(
    T::Type{&lt;:Real},
    FES::Array{FESpace,1},          
    operators::Array{DataType,1},
    action::AbstractAction;
    regions::Array{Int,1} = [0])</code></pre><p>Creates a TrilinearForm assembly pattern with the given FESpaces, operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/018a99a007014069abe8fbde1fd0db8137abd469/src/assemblypatterns/trilinearform.jl#L13-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.MultilinearForm" href="#GradientRobustMultiPhysics.MultilinearForm"><code>GradientRobustMultiPhysics.MultilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function MultilinearForm(
    T::Type{&lt;:Real},
    AT::Type{&lt;:AbstractAssemblyType},
    FE::Array{FESpace,1},
    operators::Array{DataType,1}, 
    action::AbstractAction; 
    regions::Array{Int,1} = [0])</code></pre><p>Creates a MultilinearForm assembly pattern with the given FESpaces, operators and action etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/018a99a007014069abe8fbde1fd0db8137abd469/src/assemblypatterns/multilinearform.jl#L13-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.NonlinearForm" href="#GradientRobustMultiPhysics.NonlinearForm"><code>GradientRobustMultiPhysics.NonlinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function NonlinearForm(
    T::Type{&lt;:Real},
    FES::Array{FESpace,1},          # finite element spaces for each operator of the ansatz function and the last one refers to the test function
    operators::Array{DataType,1},   # operators that should be evaluated for the ansatz function and the last one refers to the test function
    action::AbstractAction;         # action that shoul have an AbstractNLActionKernel
    regions::Array{Int,1} = [0])</code></pre><p>Creates a NonlinearForm assembly pattern.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/018a99a007014069abe8fbde1fd0db8137abd469/src/assemblypatterns/nonlinearform.jl#L13-L24">source</a></section></article><h4 id="Evaluate-and-Assemble"><a class="docs-heading-anchor" href="#Evaluate-and-Assemble">Evaluate and Assemble</a><a id="Evaluate-and-Assemble-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluate-and-Assemble" title="Permalink"></a></h4><p>Below all evaluate! and assemble! functions of the patterns are listed.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.evaluate!" href="#GradientRobustMultiPhysics.evaluate!"><code>GradientRobustMultiPhysics.evaluate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function evaluate!(
    b::AbstractArray{T,2},          # target vector
    AP::AssemblyPattern{APT,T,AT},  # ItemIntegrator pattern
    FEB::Array{&lt;:FEVectorBlock,1}   # coefficients for arguments
    where {APT &lt;: APT_ItemIntegrator, T, AT}</code></pre><p>Evaluation of an ItemIntegrator assembly pattern with given FEVectorBlocks FEB into given two-dimensional Array b.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/018a99a007014069abe8fbde1fd0db8137abd469/src/assemblypatterns/itemintegrator.jl#L97-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.evaluate" href="#GradientRobustMultiPhysics.evaluate"><code>GradientRobustMultiPhysics.evaluate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function evaluate(
    AP::AssemblyPattern{APT,T,AT},  # ItemIntegrator pattern
    FEB::Array{&lt;:FEVectorBlock,1})  # coefficients for arguments
    where {APT &lt;: APT_ItemIntegrator, T, AT}
</code></pre><p>Evaluation of an ItemIntegrator assembly pattern with given FEVectorBlocks FEB, only returns accumulation over all items.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/018a99a007014069abe8fbde1fd0db8137abd469/src/assemblypatterns/itemintegrator.jl#L232-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.assemble!" href="#GradientRobustMultiPhysics.assemble!"><code>GradientRobustMultiPhysics.assemble!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">assemble!(
    b::Union{AbstractArray{T,1},AbstractArray{T,2}},    # target vector/matrix
    AP::AssemblyPattern{APT,T,AT};                      # LinearForm pattern
    factor = 1)                                         # factor that is multiplied
    where {APT &lt;: APT_LinearForm, T, AT}</code></pre><p>Assembly of a LinearForm pattern AP into a vector or matrix (if action is vetor-valued).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/018a99a007014069abe8fbde1fd0db8137abd469/src/assemblypatterns/linearform.jl#L33-L43">source</a></section><section><div><pre><code class="language-none">assemble!(
    A::AbstractArray{T,2},                  # target matrix
    AP::AssemblyPattern{APT,T,AT};          # BilinearForm Pattern
    apply_action_to::Int = 1,               # action is applied to which argument?
    factor = 1,                             # factor that is multiplied
    transposed_assembly::Bool = false,      # transpose result?
    transpose_copy = Nothing)               # copy a transposed block to this matrix
    where {APT &lt;: APT_BilinearForm, T, AT}</code></pre><p>Assembly of a BilinearForm BLF into given two-dimensional AbstractArray (e.g. FEMatrixBlock or a ExtendableSparseMatrix).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/018a99a007014069abe8fbde1fd0db8137abd469/src/assemblypatterns/bilinearform.jl#L64-L77">source</a></section><section><div><pre><code class="language-none">assemble!(
    b::AbstractArray{T,1},          # target vector
    AP::AssemblyPattern{APT,T,AT},  # BilinearForm Pattern
    fixedFE::AbstractArray;         # coefficients for fixed argument
    apply_action_to::Int = 1,       # action is applied to 1st or 2nd argument?
    fixed_arguments = [1],        # which argument is fixed?
    factor = 1)                     # factor that is multiplied
    where {APT &lt;: APT_BilinearForm, T, AT}</code></pre><p>Assembly of a BilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the second argument is fixed (default) by the given coefficients in fixedFE. With apply<em>action</em>to=2 the action can be also applied to the second argument instead of the first one (default).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/018a99a007014069abe8fbde1fd0db8137abd469/src/assemblypatterns/bilinearform.jl#L274-L289">source</a></section><section><div><pre><code class="language-none">assemble!(
    assemble!(
    A::AbstractArray{T,2},                  # target matrix
    AP::AssemblyPattern{APT,T,AT},          # TrilinearForm pattern
    fixedFE::Array{&lt;:FEVectorBlock,1};      # coefficients for fixed argument
    fixed_argument = [1],                   # position of fixed argument (as an array)
    transposed_assembly::Bool = false,      # transpose result?
    factor = 1)                             # factor that is multiplied
    where {APT &lt;: APT_TrilinearForm, T, AT}</code></pre><p>Assembly of a TrilinearForm AP into given two-dimensional AbstractArray (e.g. a FEMatrixBlock). Here, one argument (specified by fixed_argument) is fixed by the given coefficients in fixedFE[1]. Note, that the action is (currently) always applied to the first and second argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/018a99a007014069abe8fbde1fd0db8137abd469/src/assemblypatterns/trilinearform.jl#L39-L55">source</a></section><section><div><pre><code class="language-none">assemble!(
    assemble!(
    b::AbstractVector,                      # target vector
    AP::AssemblyPattern{APT,T,AT},          # coefficients for fixed arguments
    fixedFE::Array{&lt;:FEVectorBlock,1};      # TrilinearForm pattern
    factor = 1)                             # factor that is multiplied
    where {APT &lt;: APT_TrilinearForm, T, AT}</code></pre><p>Assembly of a TrilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the first two arguments are fixed by the given coefficients in FE1 and FE2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/018a99a007014069abe8fbde1fd0db8137abd469/src/assemblypatterns/trilinearform.jl#L220-L233">source</a></section><section><div><pre><code class="language-none">assemble!(
    b::AbstractVector,                        # target vector
    FE::Array{&lt;:FEVectorBlock,1},             # coefficients of all but last argument
    AP::AssemblyPattern{APT,T,AT};            # Multilinearform pattern
    factor = 1)                               # factor that is multiplied
    where {APT &lt;: APT_MultilinearForm, T, AT}</code></pre><p>Assembly of a MultilinearForm AP into given one-dimensional AbstractArray (e.g. a FEVectorBlock). Here, the all but the last arguments are fixed by the given coefficients in the components of FE.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/018a99a007014069abe8fbde1fd0db8137abd469/src/assemblypatterns/multilinearform.jl#L39-L51">source</a></section><section><div><pre><code class="language-none">assemble!(
    A::AbstractArray{T,2},                 # target matrix
    AP::AssemblyPattern{APT,T,AT};         # NonlinearForm pattern
    FEB::Array{&lt;:FEVectorBlock,1};         # coefficients of current solution for each operator
    factor = 1,                            # factor that is multiplied
    transposed_assembly::Bool = false)     # transpose result?
    where {APT &lt;: APT_NonlinearForm, T, AT}</code></pre><p>Assembly of a NonlinearForm assembly pattern into given two-dimensional AbstractArray (e.g. FEMatrixBlock).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/018a99a007014069abe8fbde1fd0db8137abd469/src/assemblypatterns/nonlinearform.jl#L39-L51">source</a></section><section><div><pre><code class="language-none">assemble!(
    b::AbstractVector,                     # target vector
    AP::AssemblyPattern{APT,T,AT},         # NonlinearForm pattern
    FEB::Array{&lt;:FEVectorBlock,1};         # coefficients of current solution for each operator
    factor = 1)                            # factor that is multiplied
    where {APT &lt;: APT_NonlinearForm, T, AT}</code></pre><p>Assembly of a NonlinearForm AP into given AbstractVector (e.g. FEMatrixBlock).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/018a99a007014069abe8fbde1fd0db8137abd469/src/assemblypatterns/nonlinearform.jl#L222-L233">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quadrature/">« Quadrature</a><a class="docs-footer-nextpage" href="../pdesolvers/">Fixed-Time Solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 6 May 2021 18:05">Thursday 6 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
