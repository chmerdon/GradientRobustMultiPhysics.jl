<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PDE Operators · GradientRobustMultiPhysics.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GradientRobustMultiPhysics.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Problem Description</span><ul><li><a class="tocitem" href="../pdedescription/">PDE Description</a></li><li class="is-active"><a class="tocitem" href>PDE Operators</a><ul class="internal"><li><a class="tocitem" href="#Purpose"><span>Purpose</span></a></li><li><a class="tocitem" href="#Assembly-Type"><span>Assembly Type</span></a></li><li><a class="tocitem" href="#Special-Linear-Operators"><span>Special Linear Operators</span></a></li><li><a class="tocitem" href="#Custom-Linear-Operators"><span>Custom Linear Operators</span></a></li><li><a class="tocitem" href="#Lagrange-Multipliers"><span>Lagrange Multipliers</span></a></li><li><a class="tocitem" href="#Nonlinear-Operators"><span>Nonlinear Operators</span></a></li><li><a class="tocitem" href="#Other-Operators"><span>Other Operators</span></a></li></ul></li><li><a class="tocitem" href="../functionoperators/">Function Operators</a></li><li><a class="tocitem" href="../userdata/">User Data and Actions</a></li><li><a class="tocitem" href="../boundarydata/">Boundary Data</a></li><li><a class="tocitem" href="../globalconstraints/">Global Constraints</a></li><li><a class="tocitem" href="../pdeprototypes/">PDE Prototypes</a></li></ul></li><li><span class="tocitem">Discretisation</span><ul><li><a class="tocitem" href="../meshing/">Meshing</a></li><li><a class="tocitem" href="../fems/">Implemented Finite Elements</a></li><li><a class="tocitem" href="../fespace/">Finite Element Spaces and Arrays</a></li><li><a class="tocitem" href="../interpolations/">Finite Element Interpolations</a></li></ul></li><li><span class="tocitem">Solving</span><ul><li><a class="tocitem" href="../pdesolvers/">Fixed-Time Solvers</a></li><li><a class="tocitem" href="../timecontrolsolver/">Time-Dependent Solvers</a></li></ul></li><li><span class="tocitem">Postprocessing</span><ul><li><a class="tocitem" href="../itemintegrators/">Item Integrators</a></li><li><a class="tocitem" href="../viewers/">Viewers</a></li><li><a class="tocitem" href="../export/">Data Export</a></li></ul></li><li><span class="tocitem">Low-Level Structures</span><ul><li><a class="tocitem" href="../quadrature/">Quadrature</a></li><li><a class="tocitem" href="../assemblypatterns/">Assembly Patterns</a></li><li><a class="tocitem" href="../febasisevaluators/">FE Basis Evaluators</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples_intro/">About the examples</a></li><li><a class="tocitem" href="../examples/Example101_Bestapproximation1D/">101 : L2-Bestapproximation 1D</a></li><li><a class="tocitem" href="../examples/Example201_PoissonProblem2D/">201 : Poisson-Problem 2D</a></li><li><a class="tocitem" href="../examples/Example202_LinearElasticity2D/">202 : Linear Elasticity</a></li><li><a class="tocitem" href="../examples/Example203_ConvectionDiffusion2D/">203 : Convection-Diffusion-Problem 2D</a></li><li><a class="tocitem" href="../examples/Example204_PoissonLshapeAdaptive2D/">204 : Poisson L-shape Adaptive Mesh Refinement</a></li><li><a class="tocitem" href="../examples/Example205_BestapproximationHcurl2D/">205 : Bestapproximation Hcurl (2D)</a></li><li><a class="tocitem" href="../examples/Example206_PressureRobustness2D/">206 : Pressure-robustness 2D</a></li><li><a class="tocitem" href="../examples/Example207_StokesTransient2D/">207 : Stokes Transient 2D</a></li><li><a class="tocitem" href="../examples/Example208_FlowTransport2D/">208 : Flow + Transport 2D</a></li><li><a class="tocitem" href="../examples/Example209_FaceLagrangeMultiplier2D/">209 : Lagrange Multiplier on Faces</a></li><li><a class="tocitem" href="../examples/Example210_NonlinearPoisson2D/">210 : Nonlinear Poisson Problem 2D</a></li><li><a class="tocitem" href="../examples/Example212_NonlinearPoissonTransient2D/">212 : Nonlinear Poisson Transient 2D</a></li><li><a class="tocitem" href="../examples/Example221_StokesIterated2D/">221 : Stokes iterated penalty method 2D</a></li><li><a class="tocitem" href="../examples/Example222_NavierStokesAnderson2D/">222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration</a></li><li><a class="tocitem" href="../examples/Example223_NaturalConvection2D/">223 : Natural Convection 2D</a></li><li><a class="tocitem" href="../examples/Example224_FlowAroundCylinder2D/">224 : Flow around a cylinder 2D</a></li><li><a class="tocitem" href="../examples/Example225_CompressibleStokes2D/">225 : Compressible Stokes 2D</a></li><li><a class="tocitem" href="../examples/Example230_StokesHdivDG2D/">230 : Stokes Hdiv-DG 2D</a></li><li><a class="tocitem" href="../examples/Example301_Poisson3D/">301 : Poisson-Problem 3D</a></li><li><a class="tocitem" href="../examples/Example302_BestapproximationHdiv3D/">302 : Bestapproximation Hdiv 3D</a></li><li><a class="tocitem" href="../examples/ExampleA01_RationalMassMatrix/">A01 : Rational Mass Matrix</a></li><li><a class="tocitem" href="../examples/ExampleA02_CommutingInterpolators2D/">A02 : Commuting Interpolators 2D</a></li><li><a class="tocitem" href="../examples/ExampleA03_CommutingInterpolators3D/">A03 : Commuting Interpolators 3D</a></li><li><a class="tocitem" href="../examples/ExampleA04_CustomLinearSolver/">A04 : Custom Linear Solvers</a></li><li><a class="tocitem" href="../examples/ExampleA05_DiffEQ/">A05 : Comparison with DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples/ExampleA06_LocalEquilibratedFluxes2D/">A06 : Local Equilibrated Fluxes 2D</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Problem Description</a></li><li class="is-active"><a href>PDE Operators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PDE Operators</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/master/docs/src/pdeoperators.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PDE-Operators"><a class="docs-heading-anchor" href="#PDE-Operators">PDE Operators</a><a id="PDE-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#PDE-Operators" title="Permalink"></a></h1><h2 id="Purpose"><a class="docs-heading-anchor" href="#Purpose">Purpose</a><a id="Purpose-1"></a><a class="docs-heading-anchor-permalink" href="#Purpose" title="Permalink"></a></h2><p>The PDE consists of PDEOperators characterising some feature of the model (like friction, convection, exterior forces etc.), they describe the continuous weak form of the PDE. </p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.PDEOperator" href="#GradientRobustMultiPhysics.PDEOperator"><code>GradientRobustMultiPhysics.PDEOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct PDEOperator{T&lt;:Real, APT&lt;:AssemblyPatternType, AT&lt;:AbstractAssemblyType} &lt;: AbstractPDEOperator</code></pre><p>common structures for all finite element operators that are assembled with GradientRobustMultiPhysics; better look at the AssemblyPatternType and the constructors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/pdeoperators.jl#L57">source</a></section></article><p>The following table lists all available operators and physics-motivated constructors for them. Click on them or scroll down to find out more details.</p><table><tr><th style="text-align: left">Main constructors</th><th style="text-align: left">Special constructors</th><th style="text-align: left">Mathematically</th></tr><tr><td style="text-align: left"><a href="#GradientRobustMultiPhysics.AbstractBilinearForm"><code>AbstractBilinearForm</code></a></td><td style="text-align: left"></td><td style="text-align: left"><span>$(\mathrm{A}(\mathrm{FO}_1(u)),\mathrm{FO}_2(v))$</span> or <span>$(\mathrm{FO}_1(u),\mathrm{A}(\mathrm{FO}_2(v)))$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.LaplaceOperator"><code>LaplaceOperator</code></a></td><td style="text-align: left"><span>$(\kappa \nabla u,\nabla v)$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.ReactionOperator"><code>ReactionOperator</code></a></td><td style="text-align: left"><span>$(\alpha u, v)$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.LagrangeMultiplier"><code>LagrangeMultiplier</code></a></td><td style="text-align: left"><span>$(\mathrm{FO}_1(u), v)$</span> (automatically assembles 2nd transposed block)</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.ConvectionOperator"><code>ConvectionOperator</code></a></td><td style="text-align: left"><span>$(\beta \cdot \nabla u, v)$</span> (beta is function)</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.HookStiffnessOperator2D"><code>HookStiffnessOperator2D</code></a></td><td style="text-align: left"><span>$(\mathbb{C} \epsilon(u),\epsilon(v))$</span> (also 1D or 3D variants exist)</td></tr><tr><td style="text-align: left"><a href="#GradientRobustMultiPhysics.AbstractTrilinearForm"><code>AbstractTrilinearForm</code></a></td><td style="text-align: left"></td><td style="text-align: left"><span>$(\mathrm{A}(\mathrm{FO}_1(a),\mathrm{FO}_2(u)),\mathrm{FO}_3(v))$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.ConvectionOperator"><code>ConvectionOperator</code></a></td><td style="text-align: left"><span>$((a \cdot \nabla) u, v)$</span> (a is registered unknown)</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.ConvectionRotationFormOperator"><code>ConvectionRotationFormOperator</code></a></td><td style="text-align: left"><span>$((a \times \nabla) u,v)$</span> (a is registered unknown, only 2D for now)</td></tr><tr><td style="text-align: left"><a href="#GradientRobustMultiPhysics.GenerateNonlinearForm"><code>GenerateNonlinearForm</code></a></td><td style="text-align: left"></td><td style="text-align: left"><span>$(\mathrm{NA}(\mathrm{FO}_1(u),...,\mathrm{FO}_{N-1}(u)),\mathrm{FO}_N(v))$</span></td></tr><tr><td style="text-align: left"><a href="#GradientRobustMultiPhysics.RhsOperator"><code>RhsOperator</code></a></td><td style="text-align: left"></td><td style="text-align: left"><span>$(f \cdot \mathrm{FO}(v))$</span></td></tr></table><p>Legend: <span>$\mathrm{FO}$</span>  are placeholders for <a href="../functionoperators/#Function-Operators">Function Operators</a>, and <span>$\mathrm{A}$</span> stands for a (linear) <a href="../userdata/#Action">Action</a> (that only expects the operator value of the finite element function as an input) and <span>$\mathrm{NA}$</span> stands for a (nonlinear) <a href="../userdata/#Action">Action</a> (see <a href="#GradientRobustMultiPhysics.GenerateNonlinearForm"><code>GenerateNonlinearForm</code></a> for details).</p><h2 id="Assembly-Type"><a class="docs-heading-anchor" href="#Assembly-Type">Assembly Type</a><a id="Assembly-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly-Type" title="Permalink"></a></h2><p>Many PDE operators need a specification of that decides to which parts of the mesh the PDEOperator is associated (e.g. cells, faces, bfaces, edges), this is prescribed via the AssemblyType. The following assembly types are available. Additional to define where PDEOperators live and assemble, they can be also used as an argument for interpolation!.</p><table><tr><th style="text-align: left">AssemblyType</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left">AT_NODES</td><td style="text-align: left">interpolate at vertices of the mesh (only for H1-conforming FEM)</td></tr><tr><td style="text-align: left">ON_CELLS</td><td style="text-align: left">assemble/interpolate over the cells of the mesh</td></tr><tr><td style="text-align: left">ON_FACES</td><td style="text-align: left">assemble/interpolate over all faces of the mesh</td></tr><tr><td style="text-align: left">ON_IFACES</td><td style="text-align: left">assemble/interpolate over the interior faces of the mesh</td></tr><tr><td style="text-align: left">ON_BFACES</td><td style="text-align: left">assemble/interpolate over the boundary faces of the mesh</td></tr><tr><td style="text-align: left">ON_EDGES (*)</td><td style="text-align: left">assemble/interpolate over all edges of the mesh (in 3D)</td></tr><tr><td style="text-align: left">ON_BEDGES (*)</td><td style="text-align: left">assemble/interpolate over the boundary edges of the mesh (in 3D)</td></tr></table><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>(*) = only reasonable in 3D and still experimental, might have some issues</p></div></div><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.AT_NODES" href="#GradientRobustMultiPhysics.AT_NODES"><code>GradientRobustMultiPhysics.AT_NODES</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AT_NODES &lt;: AbstractAssemblyType</code></pre><p>causes interpolation at vertices of the grid (only for H1-conforming interpolations)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/assemblytypes.jl#L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ON_BEDGES" href="#GradientRobustMultiPhysics.ON_BEDGES"><code>GradientRobustMultiPhysics.ON_BEDGES</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type ON_BEDGES &lt;: AbstractAssemblyType</code></pre><p>causes assembly/interpolation on boundary edges of the grid (only in 3D)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/assemblytypes.jl#L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ON_BFACES" href="#GradientRobustMultiPhysics.ON_BFACES"><code>GradientRobustMultiPhysics.ON_BFACES</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type ON_BFACES &lt;: AbstractAssemblyType</code></pre><p>causes assembly/interpolation on boundary faces of the grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/assemblytypes.jl#L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ON_CELLS" href="#GradientRobustMultiPhysics.ON_CELLS"><code>GradientRobustMultiPhysics.ON_CELLS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type ON_CELLS &lt;: AbstractAssemblyType</code></pre><p>causes assembly/interpolation on cells of the grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/assemblytypes.jl#L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ON_EDGES" href="#GradientRobustMultiPhysics.ON_EDGES"><code>GradientRobustMultiPhysics.ON_EDGES</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type ON_EDGES &lt;: AbstractAssemblyType</code></pre><p>causes assembly/interpolation on edges of the grid (only in 3D)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/assemblytypes.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ON_FACES" href="#GradientRobustMultiPhysics.ON_FACES"><code>GradientRobustMultiPhysics.ON_FACES</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type ON_FACES &lt;: AbstractAssemblyType</code></pre><p>causes assembly/interpolation on faces of the grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/assemblytypes.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ON_IFACES" href="#GradientRobustMultiPhysics.ON_IFACES"><code>GradientRobustMultiPhysics.ON_IFACES</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type ON_IFACES &lt;: ON_FACES</code></pre><p>causes assembly/interpolation on interior faces of the grid</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/assemblytypes.jl#L31">source</a></section></article><h2 id="Special-Linear-Operators"><a class="docs-heading-anchor" href="#Special-Linear-Operators">Special Linear Operators</a><a id="Special-Linear-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Special-Linear-Operators" title="Permalink"></a></h2><p>Below you find the special constructors of available common linear, bilinear and trilinear forms.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.LaplaceOperator" href="#GradientRobustMultiPhysics.LaplaceOperator"><code>GradientRobustMultiPhysics.LaplaceOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">LaplaceOperator() -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, ON_CELLS}
LaplaceOperator(diffusion::Any; name, AT, gradient_operator, regions, store) -&gt; Union{Nothing, GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, ON_CELLS}}
</code></pre><p>constructor for a bilinearform that describes a(u,v) = (kappa * nabla u, nabla v) where kappa is some constant diffusion coefficient</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/pdeoperators.jl#L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ReactionOperator" href="#GradientRobustMultiPhysics.ReactionOperator"><code>GradientRobustMultiPhysics.ReactionOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ReactionOperator() -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, ON_CELLS}
ReactionOperator(coefficient::Any; name, AT, identity_operator, regions, store) -&gt; Union{Nothing, GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, ON_CELLS}}
</code></pre><p>constructor for a bilinearform that describes a(u,v) = (A(u),v) or (u,A(v)) with some user-specified action A</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/pdeoperators.jl#L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ConvectionOperator" href="#GradientRobustMultiPhysics.ConvectionOperator"><code>GradientRobustMultiPhysics.ConvectionOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function ConvectionOperator(
    a_from::Int, 
    beta_operator::Type{&lt;:AbstractFunctionOperator},
    xdim::Int,
    ncomponents::Int;
    name = &quot;auto&quot;,
    AT::Type{&lt;:AbstractAssemblyType} = ON_CELLS,
    fixed_argument::Int = 1,
    factor = 1,
    ansatzfunction_operator::Type{&lt;:AbstractFunctionOperator} = Gradient,
    testfunction_operator::Type{&lt;:AbstractFunctionOperator} = Identity,
    regions::Array{Int,1} = [0],
    auto_newton::Bool = false,
    quadorder = 0)</code></pre><p>constructs a trilinearform for a convection term of the form c(a,u,v) = (beta<em>operator(a)*grad(u),v) where a</em>from is the id of some unknown of the PDEDescription. xdim is the space dimension (= number of components of beta<em>operato(a)) and ncomponents is the number of components of u. With fixed</em>argument = 2 a and u can switch their places, i.e.  c(u,a,v) = (beta<em>operator(u)*grad(a),v), With auto</em>newton = true a Newton scheme for a(u,v) = (u*grad(u),v) is automatically derived (and fixed_argument is ignored).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/pdeoperators.jl#L395-L418">source</a></section><section><div><pre><code class="language-julia">ConvectionOperator(beta::UserData{AbstractDataFunction, FType, NFType, ndim} where {FType&lt;:Function, NFType&lt;:Function, ndim}, ncomponents::Int64; name, store, AT, ansatzfunction_operator, testfunction_operator, regions) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}
</code></pre><p>constructor for a bilinearform that describes a(u,v) = (beta*grad(u),v) with some user-specified DataFunction beta that writes into an result array of length ncomponents</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/pdeoperators.jl#L766">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ConvectionRotationFormOperator" href="#GradientRobustMultiPhysics.ConvectionRotationFormOperator"><code>GradientRobustMultiPhysics.ConvectionRotationFormOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ConvectionRotationFormOperator(beta::Int64, beta_operator::Type{var&quot;#s181&quot;} where var&quot;#s181&quot;&lt;:??, xdim::Int64, ncomponents::Int64; name, AT, factor, ansatzfunction_operator, testfunction_operator, regions) -&gt; Union{Nothing, GradientRobustMultiPhysics.PDEOperator{Float64, TrilinearForm, ON_CELLS}}
</code></pre><p>constructor for a trilinearform that describes a(u,v) = (beta x curl(u),v) where beta is the id of some unknown vector field of the PDEDescription, u and v are also vector-fields and x is the cross product (so far this is only implemented in 2D)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/pdeoperators.jl#L476">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.HookStiffnessOperator1D" href="#GradientRobustMultiPhysics.HookStiffnessOperator1D"><code>GradientRobustMultiPhysics.HookStiffnessOperator1D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HookStiffnessOperator1D(mu::Any; name, regions, gradient_operator, store) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}
</code></pre><p>constructor for a bilinearform that describes a(u,v) = (C grad(u), grad(v)) where C is the 1D stiffness tensor C grad(u) = mu grad(u)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/pdeoperators.jl#L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.HookStiffnessOperator2D" href="#GradientRobustMultiPhysics.HookStiffnessOperator2D"><code>GradientRobustMultiPhysics.HookStiffnessOperator2D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HookStiffnessOperator2D(mu::Any, lambda::Any; name, AT, regions, gradient_operator, store) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}
</code></pre><p>constructor for a bilinearform that describes a(u,v) = (C eps(u), eps(v)) where C is the 3D stiffness tensor for isotropic media in Voigt notation, i.e. C eps(u) = 2 mu eps(u) + lambda tr(eps(u)) for Lame parameters mu and lambda</p><pre><code class="language-none">In Voigt notation C is a 3 x 3 matrix
C = [c11,c12,  0
     c12,c11,  0
       0,  0,c33]

where c33 = shear_modulus, c12 = lambda and c11 = 2*c33 + c12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/pdeoperators.jl#L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.HookStiffnessOperator3D" href="#GradientRobustMultiPhysics.HookStiffnessOperator3D"><code>GradientRobustMultiPhysics.HookStiffnessOperator3D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HookStiffnessOperator3D(mu::Any, lambda::Any; name, AT, regions, gradient_operator, store) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}
</code></pre><p>constructor for a bilinearform that describes a(u,v) = (C eps(u), eps(v)) where C is the 3D stiffness tensor for isotropic media in Voigt notation, i.e. C eps(u) = 2 mu eps(u) + lambda tr(eps(u)) for Lame parameters mu and lambda</p><pre><code class="language-none">In Voigt notation C is a 6 x 6 matrix
C = [c11,c12,c12,  0,  0,  0
     c12,c11,c12,  0,  0,  0
     c12,c12,c11,  0,  0,  0
       0,  0,  0,c44,  0,  0
       0,  0,  0,  0,c44,  0
       0,  0,  0,  0,  0,c44]   

where c44 = shear_modulus, c12 = lambda and c11 = 2*c44 + c12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/pdeoperators.jl#L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.RhsOperator" href="#GradientRobustMultiPhysics.RhsOperator"><code>GradientRobustMultiPhysics.RhsOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">RhsOperator(operator::Type{var&quot;#s205&quot;} where var&quot;#s205&quot;&lt;:??, action::AbstractAction; name, AT, regions, factor, store) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, LinearForm, ON_CELLS}
</code></pre><p>generates a linearform from an action</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/pdeoperators.jl#L646">source</a></section><section><div><pre><code class="language-julia">RhsOperator(operator::Type{var&quot;#s179&quot;} where var&quot;#s179&quot;&lt;:??, regions::Vector{Int64}, data::UserData{var&quot;#s127&quot;, FType, NFType, ndim} where {var&quot;#s127&quot;&lt;:AbstractDataFunction, FType&lt;:Function, NFType&lt;:Function, ndim}; name, AT, factor, store) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, LinearForm, ON_CELLS}
</code></pre><p>generates a linearform from a given UserData{&lt;:DataFunction} (whose result dimension has to be 1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/pdeoperators.jl#L668">source</a></section></article><h2 id="Custom-Linear-Operators"><a class="docs-heading-anchor" href="#Custom-Linear-Operators">Custom Linear Operators</a><a id="Custom-Linear-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Linear-Operators" title="Permalink"></a></h2><p>It is possible to define custom bilineraforms and trilinearforms by specifiyng <a href="../functionoperators/#Function-Operators">Function Operators</a> and (in case of bilinearform optionally) an <a href="../userdata/#Action">Action</a>.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.AbstractBilinearForm" href="#GradientRobustMultiPhysics.AbstractBilinearForm"><code>GradientRobustMultiPhysics.AbstractBilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function AbstractBilinearForm(
    operators::Array{AbstractFunctionOperator,1},
    action::AbstractAction = NoAction();
    name = &quot;auto&quot;,
    AT::Type{&lt;:AbstractAssemblyType} = ON_CELLS,
    apply_action_to = 1,
    regions::Array{Int,1} = [0],
    transposed_assembly::Bool = false,
    store::Bool = false)</code></pre><p>abstract bilinearform constructor that assembles</p><ul><li>b(u,v) = int<em>regions action(operator1(u)) * operator2(v) if apply</em>action_to = 1</li><li>b(u,v) = int<em>regions operator1(u) * action(operator2(v)) if apply</em>action_to = 2</li></ul><p>The optional arguments AT and regions specifies on which grid item the operator lives/assembles, while store toggles the separate storage for the operator (which is advisable if it is not alone i an otherweise nonlinear block of a PDEDescription). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/pdeoperators.jl#L298-L317">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.AbstractTrilinearForm" href="#GradientRobustMultiPhysics.AbstractTrilinearForm"><code>GradientRobustMultiPhysics.AbstractTrilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function AbstractTrilinearForm(
    operators::Array{AbstractFunctionOperator,1},
    a_from::Int,
    a_to::Int,
    action::AbstractAction;
    name = &quot;auto&quot;,
    AT::Type{&lt;:AbstractAssemblyType} = ON_CELLS,
    regions::Array{Int,1} = [0],
    transposed_assembly::Bool = false)</code></pre><p>abstract trilinearform constructor that assembles</p><ul><li>c(a,u,v) = int_regions action(operator1(a),operator2(u)) * operator3(v)</li></ul><p>where u and are the ansatz and test function coressponding to the PDE coordinates and a is an additional unknown of the PDE. The argument a can be moved to the other positions with a<em>to and gets it data from unknown a</em>from of the full PDEdescription.</p><p>The optional arguments AT and regions specifies on which grid item the operator lives/assembles,</p><p>Also note that this operator is always marked as nonlinear by the Solver configuration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/pdeoperators.jl#L344-L366">source</a></section></article><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><p>Below some examples for operators are given:</p><pre><code class="language-julia"># Example 1 : div-div bilinearform with a factor λ (e.g. for divergence-penalisation)
operator = AbstractBilinearForm([Divergence,Divergence]; name = &quot;λ (div(u),div(v))&quot;, factor = λ)

# Example 2 : Gradient jump stabilisation with an item-dependent action and a factor s (e.g. for convection stabilisation)
xFaceVolumes::Array{Float64,1} = xgrid[FaceVolumes]
function stabilisation_kernel(result, input, item)
    result .= input 
    result .*= xFaceVolumes[item]^2
end
action = Action(Float64,stabilisation_kernel, [2,2]; dependencies = &quot;I&quot;, quadorder = 0 )
operator = AbstractBilinearForm([Jump(Gradient), Jump(Gradient)], action; AT = ON_IFACES, name = &quot;s |F|^2 [∇(u)]⋅[∇(v)]&quot;, factor = s)
</code></pre><h2 id="Lagrange-Multipliers"><a class="docs-heading-anchor" href="#Lagrange-Multipliers">Lagrange Multipliers</a><a id="Lagrange-Multipliers-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrange-Multipliers" title="Permalink"></a></h2><p>There is a special bilinearform intended to use for the assembly of Lagrange multipliers that automatically copies itself to the transposed block of the PDEdescription.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.LagrangeMultiplier" href="#GradientRobustMultiPhysics.LagrangeMultiplier"><code>GradientRobustMultiPhysics.LagrangeMultiplier</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">LagrangeMultiplier(operator::Type{var&quot;#s205&quot;} where var&quot;#s205&quot;&lt;:??; name, AT, action, regions, store, factor) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}
</code></pre><p>constructor for a bilinearform that describes a(u,v) = (A(operator(u)), id(v)) and assembles a second transposed block at the block of the transposed PDE coordinates. It is intended to use to render one unknown of the PDE the Lagrange multiplier for another unknown by putting this operator on the coressponding subdiagonal block of the PDE description.</p><p>Example: LagrangeMultiplier(Divergence) is used to render the pressure the LagrangeMultiplier for the velocity divergence constraint in the Stokes prototype.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/pdeoperators.jl#L188">source</a></section></article><h2 id="Nonlinear-Operators"><a class="docs-heading-anchor" href="#Nonlinear-Operators">Nonlinear Operators</a><a id="Nonlinear-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Operators" title="Permalink"></a></h2><p>Nonlinear Operators can be setup in two ways. The manual way requires the user to define an action with a nonlinear action kernel (see <a href="../userdata/#Action-Kernel">Action Kernel</a>) that specifies the linearisation of the nonlinearity. There is also an automatic way where the user specifies only a function (where the input can be used nonlinearly) which is then automatically differentiated to generate the linearised action kernel, see below for details.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.GenerateNonlinearForm" href="#GradientRobustMultiPhysics.GenerateNonlinearForm"><code>GradientRobustMultiPhysics.GenerateNonlinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function GenerateNonlinearForm(
    name::String,
    operator1::Array{DataType,1},
    coeff_from::Array{Int,1},
    operator2::Type{&lt;:AbstractFunctionOperator},
    action_kernel::Function,
    argsizes::Array{Int,1},
    dim::Int;
    AT::Type{&lt;:AbstractAssemblyType} = ON_CELLS,
    ADnewton::Bool = false,
    action_kernel_rhs = nothing,
    regions = [0])</code></pre><p>generates an abstract nonlinearform operator G.  The array coeff_from stores the ids of the unknowns that should be used to evaluate the operators. The array argsizes is a vector with two entries where the first one is the length of the expected result vector and the second one is the length of the input vector.</p><p>If ADnewton == true, the specified action<em>kernel is automatically differentiated to assemble the Jacobian DG and setup a Newton iteration. The action</em>kernel has to be a function of the interface </p><pre><code class="language-none">function name(result,input)</code></pre><p>where input is a vector of the operators of the solution and result is what then is multiplied with operator2 of the testfunction. Given some operator G(u), the Newton iteration reads DG u_next = DG u - G(u) which is added to the rest of the (linear) operators in the PDEDescription.</p><p>If ADnewton == false, the user is epected to prescribe a linearisation of the nonlinear operator. In this case the action_kernel has to satisfy the interface</p><pre><code class="language-none">function name(result, input_current, input_ansatz)</code></pre><p>where input<em>current is a vector of the operators of the solution and input</em>ansatz is a vecor with the operators evaluated at one of the basis functions. If necessary, also a right-hand side action in the same format can be prescribed in action<em>kernel</em>rhs.</p><p>Note: this is a highly experimental feature at the moment and will possibly only work when all operators are associated with the same unknown.</p><p>can only be applied in PDE LHS</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/pdeoperators.jl#L523-L562">source</a></section></article><h2 id="Other-Operators"><a class="docs-heading-anchor" href="#Other-Operators">Other Operators</a><a id="Other-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Operators" title="Permalink"></a></h2><p>There are some more operators that do not fit into the structures above. Also, in the future, the goal is to open up the operator level for exterior code to setup operators that are assembled elsewhere.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.FVConvectionDiffusionOperator" href="#GradientRobustMultiPhysics.FVConvectionDiffusionOperator"><code>GradientRobustMultiPhysics.FVConvectionDiffusionOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FVConvectionDiffusionOperator(beta_from::Int64; diffusion) -&gt; FVConvectionDiffusionOperator
</code></pre><p>finite-volume convection diffusion operator (for cell-wise P0 rho)</p><ul><li>div(diffusion * grad(rho) + beta rho)</li></ul><p>For diffusion = 0, the upwind divergence: div_upw(beta*rho) is generated  For diffusion &gt; 0, TODO</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/pdeoperators.jl#L1184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.DiagonalOperator" href="#GradientRobustMultiPhysics.DiagonalOperator"><code>GradientRobustMultiPhysics.DiagonalOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiagonalOperator() -&gt; DiagonalOperator
DiagonalOperator(value::Real) -&gt; DiagonalOperator
DiagonalOperator(value::Real, onlynz::Bool; regions) -&gt; DiagonalOperator
</code></pre><p>puts <em>value</em> on the diagonal entries of the cell dofs within given <em>regions</em></p><p>if <em>onlyz</em> == true only values that are zero are changed</p><p>can only be applied in PDE LHS</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/pdeoperators.jl#L1143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.CopyOperator" href="#GradientRobustMultiPhysics.CopyOperator"><code>GradientRobustMultiPhysics.CopyOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CopyOperator(copy_from::Any, factor::Any) -&gt; CopyOperator
</code></pre><p>copies entries from TargetVector to rhs block</p><p>can only be applied in PDE RHS</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/b2705ada06b120d5fa0574c77ca9bc59811b5d25/src/pdeoperators.jl#L1163">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pdedescription/">« PDE Description</a><a class="docs-footer-nextpage" href="../functionoperators/">Function Operators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 21 May 2021 14:06">Friday 21 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
