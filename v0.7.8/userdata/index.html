<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User Data and Actions · GradientRobustMultiPhysics.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../home/">GradientRobustMultiPhysics.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../home/">Home</a></li><li><a class="tocitem" href="../">Index</a></li><li><span class="tocitem">Problem Description</span><ul><li><a class="tocitem" href="../pdedescription/">PDE Description</a></li><li><a class="tocitem" href="../pdeoperators/">PDE Operators</a></li><li><a class="tocitem" href="../functionoperators/">Function Operators</a></li><li class="is-active"><a class="tocitem" href>User Data and Actions</a><ul class="internal"><li><a class="tocitem" href="#Data-Function"><span>Data Function</span></a></li><li><a class="tocitem" href="#Extended-Data-Function"><span>Extended Data Function</span></a></li><li><a class="tocitem" href="#Action-Kernel"><span>Action Kernel</span></a></li><li><a class="tocitem" href="#Action"><span>Action</span></a></li><li><a class="tocitem" href="#NLAction-Kernel"><span>NLAction Kernel</span></a></li></ul></li><li><a class="tocitem" href="../boundarydata/">Boundary Data</a></li><li><a class="tocitem" href="../globalconstraints/">Global Constraints</a></li><li><a class="tocitem" href="../pdeprototypes/">PDE Prototypes</a></li></ul></li><li><span class="tocitem">Discretisation</span><ul><li><a class="tocitem" href="../meshing/">Meshing</a></li><li><a class="tocitem" href="../fems/">Implemented Finite Elements</a></li><li><a class="tocitem" href="../fespace/">Finite Element Spaces and Arrays</a></li><li><a class="tocitem" href="../interpolations/">Finite Element Interpolations</a></li></ul></li><li><span class="tocitem">Solving</span><ul><li><a class="tocitem" href="../pdesolvers/">Fixed-Time Solvers</a></li><li><a class="tocitem" href="../timecontrolsolver/">Time-Dependent Solvers</a></li></ul></li><li><span class="tocitem">Postprocessing</span><ul><li><a class="tocitem" href="../itemintegrators/">Item Integrators</a></li><li><a class="tocitem" href="../pointevaluators/">Point Evaluators</a></li><li><a class="tocitem" href="../viewers/">Viewers</a></li><li><a class="tocitem" href="../export/">Data Export</a></li></ul></li><li><span class="tocitem">Low-Level Structures</span><ul><li><a class="tocitem" href="../quadrature/">Quadrature</a></li><li><a class="tocitem" href="../assemblypatterns/">Assembly Patterns</a></li><li><a class="tocitem" href="../febasisevaluators/">FE Basis Evaluators</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples_intro/">About the examples</a></li><li><a class="tocitem" href="../examples/Example101_Bestapproximation1D/">101 : L2-Bestapproximation 1D</a></li><li><a class="tocitem" href="../examples/Example102_RobinBoundaryCondition1D/">102 : Robin-Boundary Conditions 1D</a></li><li><a class="tocitem" href="../examples/Example201_PoissonProblem2D/">201 : Poisson-Problem 2D</a></li><li><a class="tocitem" href="../examples/Example202_LinearElasticity2D/">202 : Linear Elasticity</a></li><li><a class="tocitem" href="../examples/Example203_ReactionConvectionDiffusion2D/">203 : Reaction-Convection-Diffusion-Problem 2D</a></li><li><a class="tocitem" href="../examples/Example203_ReactionConvectionDiffusionSUPG2D/">203 : Reaction-Convection-Diffusion-Problem SUPG 2D</a></li><li><a class="tocitem" href="../examples/Example204_PoissonLshapeAdaptive2D/">204 : Poisson L-shape Adaptive Mesh Refinement</a></li><li><a class="tocitem" href="../examples/Example205_PlanarLatticeFlow2D/">205 : Planar Lattice Flow 2D</a></li><li><a class="tocitem" href="../examples/Example206_PressureRobustness2D/">206 : Pressure-robustness 2D</a></li><li><a class="tocitem" href="../examples/Example207_StokesTransient2D/">207 : Stokes Transient 2D</a></li><li><a class="tocitem" href="../examples/Example208_FlowTransport2D/">208 : Flow + Transport 2D</a></li><li><a class="tocitem" href="../examples/Example209_FaceLagrangeMultiplier2D/">209 : Lagrange Multiplier on Faces</a></li><li><a class="tocitem" href="../examples/Example210_NonlinearPoisson2D/">210 : Nonlinear Poisson Problem 2D</a></li><li><a class="tocitem" href="../examples/Example211_NonlinearElasticityBimetal2D/">211 : Nonlinear Elasticity Bimetal 2D</a></li><li><a class="tocitem" href="../examples/Example212_NonlinearPoissonTransient2D/">212 : Nonlinear Poisson Transient 2D</a></li><li><a class="tocitem" href="../examples/Example214_TwoNonlinearCoupled2D/">214 : Two nonlinearly coupled PDEs (2D)</a></li><li><a class="tocitem" href="../examples/Example215_ObstacleProblem2D/">215 : Obstacle Problem 2D</a></li><li><a class="tocitem" href="../examples/Example221_StokesIterated2D/">221 : Stokes iterated penalty method 2D</a></li><li><a class="tocitem" href="../examples/Example222_NavierStokesAnderson2D/">222 : Navier-Stokes Lid-driven cavity + Anderson Acceleration</a></li><li><a class="tocitem" href="../examples/Example223_NaturalConvection2D/">223 : Natural Convection 2D</a></li><li><a class="tocitem" href="../examples/Example224_FlowAroundCylinder2D/">224 : Flow around a cylinder 2D</a></li><li><a class="tocitem" href="../examples/Example225_CompressibleStokes2D/">225 : Compressible Stokes 2D</a></li><li><a class="tocitem" href="../examples/Example230_StokesHdivDG2D/">230 : Stokes Hdiv-DG 2D</a></li><li><a class="tocitem" href="../examples/Example231_StokesHdivP1RT/">231 : Stokes <span>$(P1 \oplus RT0) \times P0$</span></a></li><li><a class="tocitem" href="../examples/Example240_TransientFlowAroundCylinder2D/">240 : Transient Flow around a cylinder 2D</a></li><li><a class="tocitem" href="../examples/Example250_LevelSetMethod2D/">250 : Level Set Method 2D</a></li><li><a class="tocitem" href="../examples/Example301_Poisson3D/">301 : Poisson-Problem 3D</a></li><li><a class="tocitem" href="../examples/Example302_BestapproximationHdiv3D/">302 : Bestapproximation Hdiv 3D</a></li><li><a class="tocitem" href="../examples/ExampleA01_RationalMassMatrix/">A01 : Rational Mass Matrix</a></li><li><a class="tocitem" href="../examples/ExampleA02_CommutingInterpolators2D/">A02 : Commuting Interpolators 2D</a></li><li><a class="tocitem" href="../examples/ExampleA03_CommutingInterpolators3D/">A03 : Commuting Interpolators 3D</a></li><li><a class="tocitem" href="../examples/ExampleA04_CustomLinearSolver/">A04 : Custom Linear Solvers</a></li><li><a class="tocitem" href="../examples/ExampleA05_DiffEQ/">A05 : Comparison with DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples/ExampleA06_LocalEquilibratedFluxes2D/">A06 : Local Equilibrated Fluxes 2D</a></li><li><a class="tocitem" href="../examples/ExampleA07_InterpolationBetweenMeshes/">A07 : Interpolation Between Meshes</a></li><li><a class="tocitem" href="../examples/ExampleA08_BasisPlotter/">A08 : Basis-Plotter</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Problem Description</a></li><li class="is-active"><a href>User Data and Actions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>User Data and Actions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/master/docs/src/userdata.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="User-Data-and-Actions"><a class="docs-heading-anchor" href="#User-Data-and-Actions">User Data and Actions</a><a id="User-Data-and-Actions-1"></a><a class="docs-heading-anchor-permalink" href="#User-Data-and-Actions" title="Permalink"></a></h1><p>There is a variety of different user data, like scalar- and vector-valued constants, time-dependent data, region-dependent data or plain functions that depend on the the space coordinates. Also dependency on the item number of the reference coordinates of the quadrature point in the quadrature item are sometimes desireable. To allow for flexible user-specified data, all functions have to be negotiated by the UserData interface that fixes the order and number of the arguments in the interface via a user-given substring of &quot;XTRIL&quot; where each character stands for a dependency. The following table explains the meaning of each character.</p><table><tr><th style="text-align: center">Character</th><th style="text-align: left">Explanation</th></tr><tr><td style="text-align: center">X</td><td style="text-align: left">depends on (vector-valued) space coordinates</td></tr><tr><td style="text-align: center">T</td><td style="text-align: left">depends on time coordinate</td></tr><tr><td style="text-align: center">R</td><td style="text-align: left">depends on region number</td></tr><tr><td style="text-align: center">I</td><td style="text-align: left">depends on item number</td></tr><tr><td style="text-align: center">L</td><td style="text-align: left">depends on local coordinates in reference geometry of item</td></tr></table><p>Also note that all functions are expected to write their result into the first argument.</p><h2 id="Data-Function"><a class="docs-heading-anchor" href="#Data-Function">Data Function</a><a id="Data-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Function" title="Permalink"></a></h2><p>The simplest form of user data is called DataFunction which allows additional dependencies on space or time coordinates. The following tables lists all allowed substrings of &quot;XTRIL&quot; and the expected interface of the function provided by the user.</p><table><tr><th style="text-align: center">dependency string</th><th style="text-align: left">Expected interface</th></tr><tr><td style="text-align: center">&quot;&quot;</td><td style="text-align: left">function f!(result) ... end  (constant data)</td></tr><tr><td style="text-align: center">&quot;X&quot;</td><td style="text-align: left">function f!(result,x) ... end  (space-dependent data)</td></tr><tr><td style="text-align: center">&quot;T&quot;</td><td style="text-align: left">function f!(result,t) ... end  (time-dependent constant-in-space data)</td></tr><tr><td style="text-align: center">&quot;XT&quot;</td><td style="text-align: left">function f!(result,x,t) ... end  (space and time-dependent data)</td></tr></table><p>DataFunctions can be used to define boundary data, right-hand side functions and can be interpolated by the finite element standard interpolations.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.DataFunction" href="#GradientRobustMultiPhysics.DataFunction"><code>GradientRobustMultiPhysics.DataFunction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function DataFunction(
    f::Function,                    # user function with interface f(result, _other dependencies_)
    dimensions::Array{Int,1};       # [length(result), length(x)]
    name = &quot;user data function&quot;,
    dependencies::String = &quot;&quot;,      # substring of &quot;XT&quot; encoding other dependencies in f interface
    quadorder::Int = 0)             # quadrature order added to operator&#39;s quadorder that evalute f</code></pre><p>Provides a negotation interface for some user-defined function that  can be used in integrate! and boundary or right-hand side data assignments. The function f has to obey the interface</p><pre><code class="nohighlight hljs">f(result, [X, T])</code></pre><p>where the parameters X (= space coordinates) and T ( = time) are optional. Which of them are used has to be specified in the  String dependencies. The array dimensions specifies the expected length of result and input and quadorder determines the additional quadrature order to be used if this function is involved in some quadrature-requireing procedure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/a5752fc497bfaf0abb05f355c705fed34ed0ade7/src/userdata.jl#L124-L143">source</a></section><section><div><pre><code class="nohighlight hljs">function DataFunction(c::Array{&lt;:Real,1}; name = &quot;constant user data&quot;, quadorder::Int = 0)</code></pre><p>Directly generates a DataFunction from a given array c, i.e. a DataFunction that is constant and has no dependencies on x or t.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/a5752fc497bfaf0abb05f355c705fed34ed0ade7/src/userdata.jl#L158-L164">source</a></section></article><h2 id="Extended-Data-Function"><a class="docs-heading-anchor" href="#Extended-Data-Function">Extended Data Function</a><a id="Extended-Data-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Extended-Data-Function" title="Permalink"></a></h2><p>There are also ExtendedDataFunction that allow the additional dependencies R (region), I (item number) and L (local coordinates). The dependencies are stated via a string in the constructor that should be a substring of &quot;XTRIL&quot;. However, extended data functions cannot be used everywhere.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ExtendedDataFunction" href="#GradientRobustMultiPhysics.ExtendedDataFunction"><code>GradientRobustMultiPhysics.ExtendedDataFunction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function ExtendedDataFunction(
    f::Function,                    # user function with interface f(result, _other dependencies_)
    dimensions::Array{Int,1};       # [length(result), length(x)]
    name = &quot;user data function&quot;,
    dependencies::String = &quot;&quot;,      # substring of &quot;XTRIL&quot; encoding other dependencies in f interface
    quadorder::Int = 0)             # quadrature order added to operator&#39;s quadorder that evalute f</code></pre><p>Provides a negotation interface for some data function with extended dependencies (region number, item number and local coordinates) that can be used in integrate!. The function f has to obey the interface</p><pre><code class="nohighlight hljs">f(result, [X, T, R, I, L])</code></pre><p>where the parameters X (= space coordinates) and T ( = time) are optional. Which of them are used has to be specified in the  String dependencies. The array dimensions specifies the expected length of result and X (if X-depdendent, otherwise will be ignored) and quadorder determines the additional quadrature order to be used if this function is involved in some quadrature-requireing procedure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/a5752fc497bfaf0abb05f355c705fed34ed0ade7/src/userdata.jl#L177-L196">source</a></section></article><h2 id="Action-Kernel"><a class="docs-heading-anchor" href="#Action-Kernel">Action Kernel</a><a id="Action-Kernel-1"></a><a class="docs-heading-anchor-permalink" href="#Action-Kernel" title="Permalink"></a></h2><p>Another form of user data are action kernels that are used to define an AbstractAction. Actions modify (usually a subset of) arguments of <a href="../assemblypatterns/#Assembly-Patterns">Assembly Patterns</a> and so allow parameter-dependent assemblies.  Also, a trilinear form always needs an action that holds instructions how to prepare the first two arguments such that it can be evaluated with the testfunction operator. To use them, the user defines some kernel function for the action that has the interface. Kernel functions also allow the full range of dependencies, hence any substring of &quot;XTRIL&quot;.</p><p>However, between the result argument and the further dependencies they get an input argument which (during assembly) carries the operator-evaluations of the arguments that go into the action. Hence the usual interface of a action kernel function looks like this:</p><pre><code class="language-julia hljs">function action_kernel!(result,input,[X,T,R,I,L])
    # result = modified input, e.g.
    # multiplication with some parameter that can depend on
    # X = space coordinates
    # T = time
    # R = region number
    # I = item number (cell, face or edge number depending on assembly type)
    # L = local coordinates on item reference domain
end</code></pre><p>During assembly, input (in general) takes the role of all non-testfunction arguments and the result vector will be the one that is multiplied with the testfunctions. Additionally, the kernel function can depend on X, T, R, I and L as specified above. Once again note, that time-dependency of the kernel function is inherited to the action and later to the whole PDEOperator and so triggers reassembly of the associated PDEoperator in each time step.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ActionKernel" href="#GradientRobustMultiPhysics.ActionKernel"><code>GradientRobustMultiPhysics.ActionKernel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function ActionKernel(
    f::Function,                    # user function with interface f(result, _other dependencies_)
    dimensions::Array{Int,1};       # [length(result), length(input)]
    name = &quot;user action kernel&quot;,
    dependencies::String = &quot;&quot;,      # substring of &quot;XTRIL&quot; encoding other dependencies in f interface
    quadorder::Int = 0)             # quadrature order added to actions/operators that evaluate this action kernel</code></pre><p>Provides a negotation interface for some function that can be used in the Action constructor to define a user-defined operator action. The function has to obey the interface</p><pre><code class="nohighlight hljs">f(result, input, [X, T, R, I, L])</code></pre><p>where the parameters X (= space coordinates), T ( = time), R (= region number), I (= item number), L (= local coordinates) are optional. Which of them are used has to be specified in the String dependencies.</p><p>The input vector usually provides the FunctionOperator evaluations of (a subset of) the ansatz arguments of the assembly pattern where the action is used. The array dimensions specifies the expected length of result and input and quadorder determines the additional quadrature order to be used if this function (or its derived action) is involved in an assembly process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/a5752fc497bfaf0abb05f355c705fed34ed0ade7/src/userdata.jl#L16-L37">source</a></section></article><h2 id="Action"><a class="docs-heading-anchor" href="#Action">Action</a><a id="Action-1"></a><a class="docs-heading-anchor-permalink" href="#Action" title="Permalink"></a></h2><p>Actions are used by abstract user-defined PDEOperators and consist of an action kernel plus some additional infrastructure. To generate an action from an action kernel or directly from a function works via the following constructors.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.Action" href="#GradientRobustMultiPhysics.Action"><code>GradientRobustMultiPhysics.Action</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function Action(
    T::Type{&lt;:Real},
    kernel::UserData{&lt;:AbstractActionKernel};
    name::String = &quot;user action&quot;)</code></pre><p>Creates an Action from a given specified action kernel that then can be used in an assembly pattern. T specifies the number format that should match the number format of the used quadrature rules and grid coordinates in the mesh (usually T).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/a5752fc497bfaf0abb05f355c705fed34ed0ade7/src/actions.jl#L73-L83">source</a></section><section><div><pre><code class="nohighlight hljs">function Action{T &lt;: Real}(
    kernel_function::Function,
    dimensions::Array{Int,1};
    name = &quot;user action&quot;,
    dependencies = &quot;&quot;,
    quadorder = 0)</code></pre><p>Creates an Action directly from a kernel function (plus additional information to complement the action kernel) that then can be used in an assembly pattern. T specifies the number format that should match the number format of the used quadrature rules and grid coordinates in the mesh (default if omitted: T = Float64).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/a5752fc497bfaf0abb05f355c705fed34ed0ade7/src/actions.jl#L103-L115">source</a></section></article><h2 id="NLAction-Kernel"><a class="docs-heading-anchor" href="#NLAction-Kernel">NLAction Kernel</a><a id="NLAction-Kernel-1"></a><a class="docs-heading-anchor-permalink" href="#NLAction-Kernel" title="Permalink"></a></h2><p>For the manual linearisation (=without automatic differentiation) of <a href="../pdeoperators/#Nonlinear-Operators">Nonlinear Operators</a> assembly pattern, the user can also insert nonlinear action kernels that have a second input argument for the operator-evaluations of the current solution. But since this feature is still experimental, it will not explained in more detail, yet.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.NLActionKernel" href="#GradientRobustMultiPhysics.NLActionKernel"><code>GradientRobustMultiPhysics.NLActionKernel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function NLActionKernel(
    f::Function,
    dimensions::Array{Int,1};
    name = &quot;nonlinear user action kernel&quot;,
    dependencies::String = &quot;&quot;,
    quadorder::Int = 0)</code></pre><p>Provides a negotation interface for some function to be used as a nonlinear action kernel that can be used in the NonlinearOperator constructor without automatic differentiation. The function f has to obey the interface</p><pre><code class="nohighlight hljs">f(result, input_current, input_ansatz)</code></pre><p>and can be seen as a linearisation of a nonlinearity that can depend on the operator evaluation of the current iterate (input<em>current) and, as usual, the operator evaluations of the ansatz function (input</em>ansatz).</p><p>No further dependencies are allowed currently. Note, that this is a work-in-progress feature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/a5752fc497bfaf0abb05f355c705fed34ed0ade7/src/userdata.jl#L84-L103">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../functionoperators/">« Function Operators</a><a class="docs-footer-nextpage" href="../boundarydata/">Boundary Data »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 16 November 2021 20:24">Tuesday 16 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
