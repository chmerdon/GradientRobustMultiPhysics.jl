<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PDE Operators · GradientRobustMultiPhysics.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">GradientRobustMultiPhysics.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../package_index/">Index</a></li><li><span class="tocitem">Problem Description</span><ul><li><a class="tocitem" href="../pdedescription/">PDE Description</a></li><li class="is-active"><a class="tocitem" href>PDE Operators</a><ul class="internal"><li><a class="tocitem" href="#Purpose"><span>Purpose</span></a></li><li><a class="tocitem" href="#Assembly-Type"><span>Assembly Type</span></a></li><li><a class="tocitem" href="#Custom-Linear-Operators"><span>Custom Linear Operators</span></a></li><li><a class="tocitem" href="#Special-Linear-Operators"><span>Special Linear Operators</span></a></li><li><a class="tocitem" href="#Nonlinear-Operators"><span>Nonlinear Operators</span></a></li><li><a class="tocitem" href="#Other-Operators"><span>Other Operators</span></a></li></ul></li><li><a class="tocitem" href="../functionoperators/">Function Operators</a></li><li><a class="tocitem" href="../userdata/">User Data and Actions</a></li><li><a class="tocitem" href="../boundarydata/">Boundary Data</a></li><li><a class="tocitem" href="../globalconstraints/">Global Constraints</a></li><li><a class="tocitem" href="../pdeprototypes/">PDE Prototypes</a></li></ul></li><li><span class="tocitem">Discretisation</span><ul><li><a class="tocitem" href="../meshing/">Meshing</a></li><li><a class="tocitem" href="../fems/">Implemented Finite Elements</a></li><li><a class="tocitem" href="../fespace/">Finite Element Spaces and Arrays</a></li><li><a class="tocitem" href="../interpolations/">Finite Element Interpolations</a></li></ul></li><li><span class="tocitem">Solving</span><ul><li><a class="tocitem" href="../pdesolvers/">Fixed-Time Solvers</a></li><li><a class="tocitem" href="../timecontrolsolver/">Time-Dependent Solvers</a></li></ul></li><li><span class="tocitem">Postprocessing</span><ul><li><a class="tocitem" href="../itemintegrators/">Item Integrators</a></li><li><a class="tocitem" href="../pointevaluators/">Point Evaluators</a></li><li><a class="tocitem" href="../viewers/">Viewers</a></li><li><a class="tocitem" href="../export/">Data Export</a></li></ul></li><li><span class="tocitem">Low-Level Structures</span><ul><li><a class="tocitem" href="../quadrature/">Quadrature</a></li><li><a class="tocitem" href="../assemblypatterns/">Assembly Patterns</a></li><li><a class="tocitem" href="../febasisevaluators/">FE Evaluators</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples_intro/">About the examples</a></li><li><a class="tocitem" href="../examples/Example101_Bestapproximation1D/">101 : L2-Bestapproximation 1D</a></li><li><a class="tocitem" href="../examples/Example102_RobinBoundaryCondition1D/">102 : Robin-Boundary Conditions 1D</a></li><li><a class="tocitem" href="../examples/Example103_BurgersEquation1D/">103 : Burger&#39;s Equation 1D</a></li><li><a class="tocitem" href="../examples/Example201_PoissonProblem2D/">201 : Poisson-Problem 2D</a></li><li><a class="tocitem" href="../examples/Example202_LinearElasticity2D/">202 : Linear Elasticity</a></li><li><a class="tocitem" href="../examples/Example203_ReactionConvectionDiffusion2D/">203 : Reaction-Convection-Diffusion-Problem 2D</a></li><li><a class="tocitem" href="../examples/Example204_ReactionConvectionDiffusionSUPG2D/">204 : Reaction-Convection-Diffusion-Problem SUPG 2D</a></li><li><a class="tocitem" href="../examples/Example205_NonlinearPoisson2D/">205 : Nonlinear Poisson Problem 2D</a></li><li><a class="tocitem" href="../examples/Example206_NonlinearPoissonTransient2D/">206 : Nonlinear Poisson Transient 2D</a></li><li><a class="tocitem" href="../examples/Example207_NonlinearElasticityBimetal2D/">207 : Nonlinear Elasticity Bimetal 2D</a></li><li><a class="tocitem" href="../examples/Example208_ObstacleProblem2D/">208 : Obstacle Problem 2D</a></li><li><a class="tocitem" href="../examples/Example209_FaceLagrangeMultiplier2D/">209 : Lagrange Multiplier on Faces</a></li><li><a class="tocitem" href="../examples/Example210_PoissonLshapeAdaptive2D/">210 : Poisson L-shape Adaptive Mesh Refinement</a></li><li><a class="tocitem" href="../examples/Example212_WaveEquation2D/">212 : Wave Equation 2D</a></li><li><a class="tocitem" href="../examples/Example215_TwoNonlinearCoupled2D/">215 : Two nonlinearly coupled PDEs (2D)</a></li><li><a class="tocitem" href="../examples/Example220_PlanarLatticeFlow2D/">220 : Planar Lattice Flow 2D</a></li><li><a class="tocitem" href="../examples/Example221_StokesIterated2D/">221 : Stokes iterated penalty method 2D</a></li><li><a class="tocitem" href="../examples/Example222_PressureRobustness2D/">222 : Pressure-robustness 2D</a></li><li><a class="tocitem" href="../examples/Example223_StokesHdivDG2D/">223 : Stokes Hdiv-DG 2D</a></li><li><a class="tocitem" href="../examples/Example224_StokesSVRTEnrichment/">224 : Stokes <span>$SV + RT enrichment$</span></a></li><li><a class="tocitem" href="../examples/Example225_NavierStokesAnderson2D/">225 : Navier-Stokes Lid-driven cavity + Anderson Acceleration</a></li><li><a class="tocitem" href="../examples/Example226_StokesTransient2D/">226 : Stokes Transient 2D</a></li><li><a class="tocitem" href="../examples/Example227_FlowTransport2D/">227 : Flow + Transport 2D</a></li><li><a class="tocitem" href="../examples/Example230_FlowAroundCylinder2D/">230 : Flow around a cylinder 2D</a></li><li><a class="tocitem" href="../examples/Example231_TransientFlowAroundCylinder2D/">231 : Transient Flow around a cylinder 2D</a></li><li><a class="tocitem" href="../examples/Example235_NaturalConvectionTriangle2D/">235 : Natural Convection Triangle 2D</a></li><li><a class="tocitem" href="../examples/Example236_NaturalConvectionSquare2D/">236 : Natural Convection Square 2D</a></li><li><a class="tocitem" href="../examples/Example240_CompressibleStokes2D/">240 : Compressible Stokes 2D</a></li><li><a class="tocitem" href="../examples/Example250_LevelSetMethod2D/">250 : Level Set Method 2D</a></li><li><a class="tocitem" href="../examples/Example260_CahnHilliard2D/">260 : Cahn-Hilliard Equations 2D</a></li><li><a class="tocitem" href="../examples/Example301_Poisson3D/">301 : Poisson-Problem 3D</a></li><li><a class="tocitem" href="../examples/Example302_BestapproximationHdiv3D/">302 : Bestapproximation Hdiv 3D</a></li><li><a class="tocitem" href="../examples/ExampleA01_RationalMassMatrix/">A01 : Rational Mass Matrix</a></li><li><a class="tocitem" href="../examples/ExampleA02_CommutingInterpolators2D/">A02 : Commuting Interpolators 2D</a></li><li><a class="tocitem" href="../examples/ExampleA03_CommutingInterpolators3D/">A03 : Commuting Interpolators 3D</a></li><li><a class="tocitem" href="../examples/ExampleA04_CustomLinearSolver/">A04 : Custom Linear Solvers</a></li><li><a class="tocitem" href="../examples/ExampleA05_DiffEQ/">A05 : Comparison with DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples/ExampleA06_LocalEquilibratedFluxes2D/">A06 : Local Equilibrated Fluxes 2D</a></li><li><a class="tocitem" href="../examples/ExampleA07_InterpolationBetweenMeshes/">A07 : Interpolation Between Meshes</a></li><li><a class="tocitem" href="../examples/ExampleA08_BasisPlotter/">A08 : Basis-Plotter</a></li><li><a class="tocitem" href="../examples/ExampleA09_PoissonLowLevel/">A09 : Poisson-Problem with low level structures</a></li><li><a class="tocitem" href="../examples/ExampleA10_PoissonPeriodic/">A10 : Poisson-Problem with periodic boundary</a></li><li><a class="tocitem" href="../examples/ExampleA11_NavierStokesFixpointIterations/">A11 : Navier-Stokes Fixed-point iterations</a></li><li><a class="tocitem" href="../examples/ExampleA12_NavierStokesPeriodic/">A12 : Navier-Stokes-Problem with periodic boundary</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Problem Description</a></li><li class="is-active"><a href>PDE Operators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>PDE Operators</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/master/docs/src/pdeoperators.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="PDE-Operators"><a class="docs-heading-anchor" href="#PDE-Operators">PDE Operators</a><a id="PDE-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#PDE-Operators" title="Permalink"></a></h1><h2 id="Purpose"><a class="docs-heading-anchor" href="#Purpose">Purpose</a><a id="Purpose-1"></a><a class="docs-heading-anchor-permalink" href="#Purpose" title="Permalink"></a></h2><p>The PDEDescription consists of PDEOperators characterising some feature of the model (like friction, convection, exterior forces, optimality conditions etc.) and describe the continuous weak form of the PDE. They can be separated roughly into two categories: linear operators and nonlinear operators.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.PDEOperator" href="#GradientRobustMultiPhysics.PDEOperator"><code>GradientRobustMultiPhysics.PDEOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct PDEOperator{T&lt;:Real, APT&lt;:AssemblyPatternType, AT&lt;:AssemblyType} &lt;: AbstractPDEOperator</code></pre><p>common structures for all finite element operators that are assembled with GradientRobustMultiPhysics; better look at the AssemblyPatternType and the constructors</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2de267c58675986f6a0525f1b2b96d4bf2b1b844/src/pdeoperators.jl#L56">source</a></section></article><p>The following table lists all available operators and available physics-motivated constructors for them. Click on them or scroll down to find out more details.</p><table><tr><th style="text-align: left">Main constructors</th><th style="text-align: left">Special constructors</th><th style="text-align: left">Mathematically</th></tr><tr><td style="text-align: left"><a href="#GradientRobustMultiPhysics.LinearForm"><code>LinearForm</code></a></td><td style="text-align: left"></td><td style="text-align: left"><span>$(\mathrm{A}(...), \mathrm{FO}(v))$</span></td></tr><tr><td style="text-align: left"><a href="#GradientRobustMultiPhysics.BilinearForm"><code>BilinearForm</code></a></td><td style="text-align: left"></td><td style="text-align: left"><span>$(\mathrm{A}(...,\mathrm{FO}_1(u)), \mathrm{FO}_2(v))$</span> or <span>$(\mathrm{FO}_1(u), \mathrm{A}(\mathrm{FO}_2(v)))$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.LaplaceOperator"><code>LaplaceOperator</code></a></td><td style="text-align: left"><span>$(\kappa \nabla u, \nabla v)$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.ReactionOperator"><code>ReactionOperator</code></a></td><td style="text-align: left"><span>$(\alpha u, v)$</span></td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.LagrangeMultiplier"><code>LagrangeMultiplier</code></a></td><td style="text-align: left"><span>$(\mathrm{FO}_1(u), v)$</span> (automatically assembles 2nd transposed block)</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.ConvectionOperator"><code>ConvectionOperator</code></a></td><td style="text-align: left"><span>$(\beta \cdot \nabla u, v)$</span> (beta is function or registered unknown)</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.HookStiffnessOperator2D"><code>HookStiffnessOperator2D</code></a></td><td style="text-align: left"><span>$(\mathbb{C} \epsilon(u), \epsilon(v))$</span> (also 1D or 3D variants exist)</td></tr><tr><td style="text-align: left"></td><td style="text-align: left"><a href="#GradientRobustMultiPhysics.ConvectionRotationFormOperator"><code>ConvectionRotationFormOperator</code></a></td><td style="text-align: left"><span>$((a \times \nabla) u, v)$</span> (a is registered unknown, only 2D for now)</td></tr><tr><td style="text-align: left"><a href="#GradientRobustMultiPhysics.NonlinearForm"><code>NonlinearForm</code></a></td><td style="text-align: left"></td><td style="text-align: left"></td></tr></table><p>Legend: <span>$\mathrm{FO}$</span>  are placeholders for <a href="../functionoperators/#Function-Operators">Function Operators</a>, and <span>$\mathrm{A}$</span> stands for a (linear) <a href="../userdata/#Action">Action</a> (its role is explained in the main constructors).</p><h2 id="Assembly-Type"><a class="docs-heading-anchor" href="#Assembly-Type">Assembly Type</a><a id="Assembly-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly-Type" title="Permalink"></a></h2><p>Many PDE operators need a specification that decides on which set of entities of the mesh (e.g. cells, faces, bfaces, edges) a PDEOperator lives and has to be assembled. This can be steered by the AssemblyType of ExtendableGrids. The AssemblyType can be also used as an argument for <a href="../interpolations/#Finite-Element-Interpolations">Finite Element Interpolations</a>. The following AssemblyTypes are available. </p><table><tr><th style="text-align: left">AssemblyType</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left">AT_NODES</td><td style="text-align: left">interpolate at vertices of the mesh (only for H1-conforming FEM)</td></tr><tr><td style="text-align: left">ON_CELLS</td><td style="text-align: left">assemble/interpolate on the cells of the mesh</td></tr><tr><td style="text-align: left">ON_FACES</td><td style="text-align: left">assemble/interpolate on all faces of the mesh</td></tr><tr><td style="text-align: left">ON_IFACES</td><td style="text-align: left">assemble/interpolate on the interior faces of the mesh</td></tr><tr><td style="text-align: left">ON_BFACES</td><td style="text-align: left">assemble/interpolate on the boundary faces of the mesh</td></tr><tr><td style="text-align: left">ON_EDGES (*)</td><td style="text-align: left">assemble/interpolate on all edges of the mesh (in 3D)</td></tr><tr><td style="text-align: left">ON_BEDGES (*)</td><td style="text-align: left">assemble/interpolate on the boundary edges of the mesh (in 3D)</td></tr></table><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>(*) = only reasonable in 3D and still experimental, might have some issues</p></div></div><h2 id="Custom-Linear-Operators"><a class="docs-heading-anchor" href="#Custom-Linear-Operators">Custom Linear Operators</a><a id="Custom-Linear-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-Linear-Operators" title="Permalink"></a></h2><p>It is possible to define custom linearforms and bilinearforms by specifying <a href="../functionoperators/#Function-Operators">Function Operators</a> an <a href="../userdata/#Action">Action</a> that determines how the operators are combined for the dot-product with the test function operator.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.LinearForm" href="#GradientRobustMultiPhysics.LinearForm"><code>GradientRobustMultiPhysics.LinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LinearForm(operator::Type{&lt;:??}, action::AbstractAction; name, AT, regions, factor, store) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, LinearForm, ON_CELLS}
</code></pre><p>generates a LinearForm L(v) = (f,operator(v)) from an action</p><ul><li>operator : operator applied to test function</li><li>action   : action that computes a result to be multiplied with test function operator</li></ul><p>Optional arguments:</p><ul><li>regions           : specifies in which regions the operator should assemble, default [0] means all regions</li><li>name              : name for this LinearForm that is used in print messages</li><li>AT                : specifies on which entities of the grid the LinearForm is assembled (default: ON_CELLS)</li><li>factor            : additional factor that is multiplied during assembly</li><li>store             : stores a vector of the discretised LinearForm with the latest assembly result</li></ul><p>Details on the action: The action is an Action consisting of a kernel function with interface (result, input, ...) and additional argument information. During assembly input is ignored (only in this constructor for LinearForms). The result computed by the kernel function is multiplied (dot product) with the operator evaluation of the test function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2de267c58675986f6a0525f1b2b96d4bf2b1b844/src/pdeoperators.jl#L638">source</a></section><section><div><pre><code class="language-julia hljs">LinearForm(operator::Type{&lt;:??}, f::GradientRobustMultiPhysics.AbstractUserDataType; name, kwargs...) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, LinearForm, ON_CELLS}
</code></pre><p>generates a LinearForm L(v) = (f,operator(v)) from a DataFunction</p><ul><li>operator : operator applied to test function</li><li>action   : DataFunction, evaluation is multiplied with test function operator</li></ul><p>Optional arguments:</p><ul><li>regions           : specifies in which regions the operator should assemble, default [0] means all regions</li><li>name              : name for this LinearForm that is used in print messages</li><li>AT                : specifies on which entities of the grid the LinearForm is assembled (default: ON_CELLS)</li><li>factor            : additional factor that is multiplied during assembly</li><li>store             : stores a vector of the discretised LinearForm with the latest assembly result</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2de267c58675986f6a0525f1b2b96d4bf2b1b844/src/pdeoperators.jl#L677">source</a></section><section><div><pre><code class="language-julia hljs">LinearForm(operator_test::Type{&lt;:??})
LinearForm(operator_test::Type{&lt;:??}, operators_current::Vector{DataType}) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, LinearForm, ON_CELLS}
LinearForm(operator_test::Type{&lt;:??}, operators_current::Vector{DataType}, coeff_from::Vector{Int64}) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, LinearForm, ON_CELLS}
LinearForm(operator_test::Type{&lt;:??}, operators_current::Vector{DataType}, coeff_from::Vector{Int64}, action::AbstractAction; regions, name, AT, factor, store) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, LinearForm, ON_CELLS}
</code></pre><p>Creates a (PDE description level) LinearForm based on:</p><ul><li>operator_test     : operator for the test function (assumes linearity for that part)</li><li>operators_current : additional operators for other unknowns</li><li>coeff<em>from        : either PDE unknown ids or block ids for CurrentSolution given to assembly</em>operator! that should be used for operators_current</li><li>action            : an Action with kernel of interface (result, input, kwargs) that takes input (= all but last operator evaluations) and computes result to be dot-producted with test function evaluation                     (if no action is specified, the full input vector is dot-producted with the test function operator evaluation)</li></ul><p>Optional arguments:</p><ul><li>regions: specifies in which regions the operator should assemble, default [0] means all regions</li><li>name : name for this LinearForm that is used in print messages</li><li>AT : specifies on which entities of the grid the LinearForm is assembled (default: ON_CELLS)</li><li>factor : additional factor that is multiplied during assembly</li><li>store : stores a vector of the LinearForm with the latest assembly result (e.g. when the operators sits in a system block that has to be reassembled in an iterative scheme)</li></ul><p>Details on the action: The action is an Action consisting of a kernel function with interface (result, input, ...) and additional argument information. During assembly input will be filled with the operator evaluations of the other unknowns (i.e. operators<em>current). The result computed by the kernel function is multiplied (dot product) with the operator evaluation of the test function (i.e. operator</em>test). If no action is given, the assembly tries to multiply the operator evaluations (that would have been given as input) directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2de267c58675986f6a0525f1b2b96d4bf2b1b844/src/pdeoperators.jl#L708">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.BilinearForm" href="#GradientRobustMultiPhysics.BilinearForm"><code>GradientRobustMultiPhysics.BilinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BilinearForm(operators_linear::Vector{DataType}, operators_current::Vector{DataType}, coeff_from::Vector{Int64}, action::AbstractAction; name, AT, APT, apply_action_to, factor, regions, transposed_assembly, also_transposed_block, transpose_factor, store) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}
</code></pre><p>generates a BilinearForm defined by the following arguments:</p><ul><li>operators_linear  : operator for the two linear arguments (usually ansatz and test function)</li><li>operators_current : additional operators for other unknowns</li><li>coeff<em>from        : either PDE unknown ids or block ids for CurrentSolution given to assembly</em>operator! that should be used for operators_current</li><li>action            : tells how to further combine the operators<em>current+operator</em>ansatz evaluations (=input of action) to a result that is multiplied with the test function operator                     (if no action is specified, the full input vector is dot-producted with the test function operator evaluation)</li></ul><p>Optional arguments:</p><ul><li>apply<em>action</em>to   : specifies which of the two linear arguments is part of the action input ([1] = ansatz, [2] = test)</li><li>regions           : specifies in which regions the operator should assemble, default [0] means all regions</li><li>name              : name for this BilinearForm that is used in print messages</li><li>AT                : specifies on which entities of the grid the BilinearForm is assembled (default: ON_CELLS)</li><li>APT               : specifies the subtype of the APT_BilinearForm AssemblyPattern used for assembly (e.g. for lumping (wip))</li><li>factor            : additional factor that is multiplied during assembly</li><li>transposed_assembly : transposes the resulting assembled matrix (consider true here for non-symmetric operators)</li><li>also<em>transposed</em>block : when true toggles assembly of transposed system matrix block</li><li>transpose_factor  : factor for transposed block (default = factor)</li><li>store             : stores a matrix of the BilinearForm with the latest assembly result                     (e.g. when the operators sits in a system block that has to be reassembled in an iterative scheme)</li></ul><p>Details on the action: The action is an Action consisting of a kernel function with interface (result, input, ...) and additional argument information. During assembly input will be filled with the operator evaluations of the other unknowns (i.e. operator<em>current, if specified) and appended to that the operator evaluation of one of the two linear argument (decided by apply</em>action_to). The result computed by the kernel function is multiplied (dot product) with the operator evaluation of the other linear argument. If no action is given, the assembly tries to multiply the operator evaluations (that would have been given as input) directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2de267c58675986f6a0525f1b2b96d4bf2b1b844/src/pdeoperators.jl#L322">source</a></section><section><div><pre><code class="language-julia hljs">BilinearForm(operators_linear::Vector{DataType}) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}
BilinearForm(operators_linear::Vector{DataType}, action::AbstractAction; kwargs...) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}
</code></pre><p>same as other constructor but with operators_current = <a href="no other implicit dependencies"></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2de267c58675986f6a0525f1b2b96d4bf2b1b844/src/pdeoperators.jl#L398">source</a></section></article><h2 id="Special-Linear-Operators"><a class="docs-heading-anchor" href="#Special-Linear-Operators">Special Linear Operators</a><a id="Special-Linear-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Special-Linear-Operators" title="Permalink"></a></h2><p>Below you find special constructors of available common linear and bilinear forms.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.LaplaceOperator" href="#GradientRobustMultiPhysics.LaplaceOperator"><code>GradientRobustMultiPhysics.LaplaceOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LaplaceOperator() -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, ON_CELLS}
LaplaceOperator(κ; name, AT, ∇, regions, store) -&gt; Union{Nothing, GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, ON_CELLS}}
</code></pre><p>constructor for a bilinearform that describes a(u,v) = κ (∇u,∇v) where kappa is some constant (diffusion) coefficient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2de267c58675986f6a0525f1b2b96d4bf2b1b844/src/pdeoperators.jl#L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ReactionOperator" href="#GradientRobustMultiPhysics.ReactionOperator"><code>GradientRobustMultiPhysics.ReactionOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ReactionOperator() -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, ON_CELLS}
ReactionOperator(α) -&gt; Union{Nothing, GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}, GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, ON_CELLS}}
ReactionOperator(α, ncomponents; name, AT, id, regions, store) -&gt; Union{Nothing, GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}, GradientRobustMultiPhysics.PDEOperator{Float64, SymmetricBilinearForm, ON_CELLS}}
</code></pre><p>constructor for a bilinearform a(u,v) = (αu,v) or (u,αv) with some coefficient α that can be a number or an AbstractDataFunction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2de267c58675986f6a0525f1b2b96d4bf2b1b844/src/pdeoperators.jl#L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.LagrangeMultiplier" href="#GradientRobustMultiPhysics.LagrangeMultiplier"><code>GradientRobustMultiPhysics.LagrangeMultiplier</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">LagrangeMultiplier(operator::Type{&lt;:??}; name, AT, action, regions, store, factor) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}
</code></pre><p>constructor for a bilinearform that describes a(u,v) = (A(operator(u)), id(v)) and assembles a second transposed block at the block of the transposed PDE coordinates. It is intended to use to render one unknown of the PDE the Lagrange multiplier for another unknown by putting this operator on the coressponding subdiagonal block of the PDE description.</p><p>Example: LagrangeMultiplier(Divergence) is used to render the pressure the LagrangeMultiplier for the velocity divergence constraint in the Stokes prototype.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2de267c58675986f6a0525f1b2b96d4bf2b1b844/src/pdeoperators.jl#L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ConvectionOperator" href="#GradientRobustMultiPhysics.ConvectionOperator"><code>GradientRobustMultiPhysics.ConvectionOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ConvectionOperator(a_from::Int64, a_operator::Type{&lt;:??}, xdim::Int64, ncomponents::Int64; name, AT, a_to, factor, ansatz_operator, test_operator, regions, newton, store, transposed_assembly, bonus_quadorder) -&gt; Union{GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}, GradientRobustMultiPhysics.PDEOperator{Float64, NonlinearForm, ON_CELLS}}
</code></pre><p>constructs a convection term of the form c(a,u,v) = (a<em>operator(a)*ansatz</em>operator(u),test_operator(v)) as a BilinearForm (or NonlinearForm, see newton argument)</p><ul><li>a_from      : id of registered unknown to be used in the spot a</li><li>a_operator  : operator applied to a</li><li>xdim        : expected space dimension</li><li>ncomponents : expected numer of components of a</li></ul><p>optional arguments:</p><ul><li>newton          : generates a NonlinearForm instead of a BilinearForm that triggers assembly of Newton terms for c(u,u,v)</li><li>a<em>to            : position of a argument, set a</em>to = 2 to trigger assembly of c(u,a,v)</li><li>ansatz_operator : operator used in the spot u (default: Gradient)</li><li>test_operator   : operator used in the spot v (default: Identity)</li><li>factor          : additional factor multiplied in assemblxy (default: 1)</li><li>regions         : specifies in which regions the operator should assemble, default [0] means all regions</li><li>name            : name for this operator that is used in print messages</li><li>AT              : specifies on which entities of the grid the operator is assembled (default: ON_CELLS)</li><li>store           : stores a matrix of the operator with the latest assembly result</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2de267c58675986f6a0525f1b2b96d4bf2b1b844/src/pdeoperators.jl#L411">source</a></section><section><div><pre><code class="language-julia hljs">ConvectionOperator(β::GradientRobustMultiPhysics.AbstractUserDataType, ncomponents::Int64; name, store, AT, ansatz_operator, test_operator, transposed_assembly, regions) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}
</code></pre><p>constructor for a bilinearform that describes a(u,v) = ((β ⋅ ∇) u,v) with some user-specified DataFunction β. The user also has to specify the number of components (ncomponents) the convection is applied to. The operators for u and v can be changed (if this leads to something reasonable).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2de267c58675986f6a0525f1b2b96d4bf2b1b844/src/pdeoperators.jl#L760">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.ConvectionRotationFormOperator" href="#GradientRobustMultiPhysics.ConvectionRotationFormOperator"><code>GradientRobustMultiPhysics.ConvectionRotationFormOperator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ConvectionRotationFormOperator(beta::Int64, beta_operator::Type{&lt;:??}, xdim::Int64, ncomponents::Int64; name, AT, factor, ansatz_operator, test_operator, regions)
</code></pre><p>constructor for a bilinearform a(u,v) = (beta x curl(u),v) where beta is the id of some unknown vector field of the PDEDescription, u and v are also vector-fields and x is the cross product (so far this is only implemented in 2D)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2de267c58675986f6a0525f1b2b96d4bf2b1b844/src/pdeoperators.jl#L512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.HookStiffnessOperator1D" href="#GradientRobustMultiPhysics.HookStiffnessOperator1D"><code>GradientRobustMultiPhysics.HookStiffnessOperator1D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HookStiffnessOperator1D(μ; name, regions, ∇, store) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}
</code></pre><p>constructor for a bilinearform a(u,v) = (μ ∇u,∇v) where C is the 1D stiffness tensor for given μ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2de267c58675986f6a0525f1b2b96d4bf2b1b844/src/pdeoperators.jl#L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.HookStiffnessOperator2D" href="#GradientRobustMultiPhysics.HookStiffnessOperator2D"><code>GradientRobustMultiPhysics.HookStiffnessOperator2D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HookStiffnessOperator2D(μ, λ; name, AT, regions, ϵ, store) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}
</code></pre><p>constructor for a bilinearform a(u,v) = (C ϵ(u), ϵ(v)) where C is the 2D stiffness tensor for isotropic media in Voigt notation, i.e. ℂ ϵ(u) = 2 μ ϵ(u) + λ tr(ϵ(u)) for Lame parameters μ and λ</p><pre><code class="nohighlight hljs">In Voigt notation ℂ is a 3 x 3 matrix
ℂ = [c11,c12,  0
     c12,c11,  0
       0,  0,c33]

where c33 = μ, c12 = λ and c11 = 2*c33 + c12</code></pre><p>Note: ϵ is the symmetric part of the gradient (in Voigt notation)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2de267c58675986f6a0525f1b2b96d4bf2b1b844/src/pdeoperators.jl#L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.HookStiffnessOperator3D" href="#GradientRobustMultiPhysics.HookStiffnessOperator3D"><code>GradientRobustMultiPhysics.HookStiffnessOperator3D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HookStiffnessOperator3D(μ, λ; name, AT, regions, ϵ, store) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, BilinearForm, ON_CELLS}
</code></pre><p>constructor for a bilinearform a(u,v) = (C ϵ(u), ϵ(v)) where C is the 3D stiffness tensor for isotropic media in Voigt notation, i.e. ℂ ϵ(u) = 2 μ ϵ(u) + λ tr(ϵ(u)) for Lame parameters μ and λ</p><pre><code class="nohighlight hljs">In Voigt notation ℂ is a 6 x 6 matrix
ℂ = [c11,c12,c12,  0,  0,  0
     c12,c11,c12,  0,  0,  0
     c12,c12,c11,  0,  0,  0
       0,  0,  0,c44,  0,  0
       0,  0,  0,  0,c44,  0
       0,  0,  0,  0,  0,c44]   

where c44 = μ, c12 = λ and c11 = 2*c44 + c12</code></pre><p>Note: ϵ is the symmetric part of the gradient (in Voigt notation)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2de267c58675986f6a0525f1b2b96d4bf2b1b844/src/pdeoperators.jl#L275">source</a></section></article><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><p>Below some examples for operators for custom forms are given:</p><pre><code class="language-julia hljs"># Example 1 : div-div bilinearform with a factor λ (e.g. for divergence-penalisation)
operator = BilinearForm([Divergence,Divergence]; factor = λ, name = &quot;λ (div(u),div(v))&quot;)

# Example 2 : Gradient jump stabilisation with an item-dependent action and a factor s (e.g. for convection stabilisation)
xFaceVolumes::Array{Float64,1} = xgrid[FaceVolumes]
function stabilisation_kernel(result, input, item)
    result .= input 
    result .*= xFaceVolumes[item]^2
end
action = Action(stabilisation_kernel, [2,2]; dependencies = &quot;I&quot;, quadorder = 0 )
operator = BilinearForm([Jump(Gradient), Jump(Gradient)], action; AT = ON_IFACES, factor = s, name = &quot;s |F|^2 [∇(u)]⋅[∇(v)]&quot;)
</code></pre><h2 id="Nonlinear-Operators"><a class="docs-heading-anchor" href="#Nonlinear-Operators">Nonlinear Operators</a><a id="Nonlinear-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Operators" title="Permalink"></a></h2><p>Nonlinear Operators can be used to auotmatically setup the required Newton terms for the fixpoint algorithms. If the user does not define the jacobian for the kernel function, automatic differentation is used to compute them (with optional sparsity detection), see below for details.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.NonlinearForm" href="#GradientRobustMultiPhysics.NonlinearForm"><code>GradientRobustMultiPhysics.NonlinearForm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">NonlinearForm(operator_test::Type{&lt;:??}, operators_current::Vector{DataType}, coeff_from::Vector{Int64}, action_kernel, argsizes::Vector{Int64}; name, AT, newton, sparse_jacobian, jacobian, dependencies, bonus_quadorder, store, factor, regions) -&gt; GradientRobustMultiPhysics.PDEOperator{Float64, NonlinearForm, ON_CELLS}
</code></pre><p>generates a NonlinearForm defined by the following arguments:</p><ul><li>operator_test     : operator for the test function</li><li>operators_current : additional operators for other unknowns</li><li>coeff<em>from        : either PDE unknown ids or block ids for CurrentSolution given to assembly</em>operator! that should be used for operators_current</li><li>action_kernel     : function of interface (result, input, ...) that computes the nonlinear quantity that should be multiplied with the testfunction operator</li><li>argsizes          : dimensions of [result, input] of kernel function</li></ul><p>Optional arguments:</p><ul><li>dependencies      : code String for additional dependencies of the kernel/jacobians (substring of &quot;XTI&quot;)</li><li>jacobian          : default = &quot;auto&quot; triggers automatic computation of jacobians by ForwardDiff, otherwise user can specify a function of interface (jacobian, input, ...) with matching dimensions and dependencies</li><li>sparse_jacobian   : use sparsity detection and sparse matrixes for local jacobians ?</li><li>regions           : specifies in which regions the operator should assemble, default [0] means all regions</li><li>name              : name for this NonlinearForm that is used in print messages</li><li>AT                : specifies on which entities of the grid the NonlinearForm is assembled (default: ON_CELLS)</li><li>factor            : additional factor that is multiplied during assembly</li><li>store             : stores a matrix of the discretised NonlinearForm with the latest assembly result</li><li>bonus_quadorder   : increases the quadrature order in assembly accordingly (additional to usual quadorder based on used FESpaces)</li></ul><p>Some details: Given some operator G(u), the Newton iteration reads DG u_next = DG u - G(u) which is added to the rest of the (linear) operators in the PDEDescription. The local jacobians (= jacobians of the operator kernel) to build DG needed for this are computed by automatic differentation (ForwardDiff). The user can also specify a jacobian kernel function by hand (which may improve assembly times).</p><p>For default dependencies both the kernel functions for the operator and its jacobian have to satisfy the interface</p><pre><code class="nohighlight hljs">function name(result,input,...)</code></pre><p>where input is a vector of the operators of the solution and result is either what then is multiplied with operator2 of the testfunction (or the jacobian).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2de267c58675986f6a0525f1b2b96d4bf2b1b844/src/pdeoperators.jl#L555">source</a></section></article><h2 id="Other-Operators"><a class="docs-heading-anchor" href="#Other-Operators">Other Operators</a><a id="Other-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Other-Operators" title="Permalink"></a></h2><p>There are some more operators that do not fit into the structures above. Also, in the future, the goal is to open up the operator level for exterior code to setup operators that are assembled elsewhere.</p><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.FVConvectionDiffusionOperator" href="#GradientRobustMultiPhysics.FVConvectionDiffusionOperator"><code>GradientRobustMultiPhysics.FVConvectionDiffusionOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FVConvectionDiffusionOperator(beta_from::Int64; μ) -&gt; FVConvectionDiffusionOperator{Float64}
</code></pre><p>finite-volume convection diffusion operator (for cell-wise P0 rho)</p><ul><li>div(μ ∇ρ + β ρ)</li></ul><p>For μ = 0, the upwind divergence div_upw(β ρ) is generated  For μ &gt; 0, TODO</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2de267c58675986f6a0525f1b2b96d4bf2b1b844/src/pdeoperators.jl#L1264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.DiagonalOperator" href="#GradientRobustMultiPhysics.DiagonalOperator"><code>GradientRobustMultiPhysics.DiagonalOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DiagonalOperator() -&gt; DiagonalOperator{Float64}
DiagonalOperator(value::Real; name, onlynz, regions) -&gt; DiagonalOperator
</code></pre><p>puts <em>value</em> on the diagonal entries of the cell dofs within given <em>regions</em></p><p>if <em>onlyz</em> == true only values that are zero are changed</p><p>can only be applied in PDE LHS</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2de267c58675986f6a0525f1b2b96d4bf2b1b844/src/pdeoperators.jl#L1177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradientRobustMultiPhysics.CopyOperator" href="#GradientRobustMultiPhysics.CopyOperator"><code>GradientRobustMultiPhysics.CopyOperator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CopyOperator(copy_from, factor) -&gt; CopyOperator
</code></pre><p>copies entries from TargetVector to rhs block</p><p>can only be applied in PDE RHS</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chmerdon/GradientRobustMultiPhysics.jl/blob/2de267c58675986f6a0525f1b2b96d4bf2b1b844/src/pdeoperators.jl#L1231">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pdedescription/">« PDE Description</a><a class="docs-footer-nextpage" href="../functionoperators/">Function Operators »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 17 October 2022 19:38">Monday 17 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
